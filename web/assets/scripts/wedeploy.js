!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";function n(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var r,n=i(t),s=n.source,h=n.id,p=n.path,u=c[h]&&p in c[h].nsps,f=e.forceNew||e["force new connection"]||!1===e.multiplex||u;return f?r=a(s,e):(c[h]||(c[h]=a(s,e)),r=c[h]),n.query&&!e.query&&(e.query=n.query),r.socket(n.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(1),s=r(4),a=r(10);r(3)("socket.io-client");t.exports=e=n;var c=e.managers={};e.protocol=s.protocol,e.connect=n,e.Manager=r(10),e.Socket=r(36)},function(t,e,r){(function(e){"use strict";function n(t,r){var n=t;r=r||e.location,null==t&&(t=r.protocol+"//"+r.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?r.protocol+t:r.host+t),/^(https?|wss?):\/\//.test(t)||(t="undefined"!=typeof r?r.protocol+"//"+t:"https://"+t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var i=n.host.indexOf(":")!==-1,s=i?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+s+":"+n.port,n.href=n.protocol+"://"+s+(r&&r.port===n.port?"":":"+n.port),n}var o=r(2);r(3)("socket.io-client:url");t.exports=n}).call(e,function(){return this}())},function(t,e){var r=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,n=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=r.exec(t||""),a={},c=14;c--;)a[n[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e){"use strict";t.exports=function(){return function(){}}},function(t,e,r){function n(){}function o(t){var r=""+t.type;return e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(r+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(r+=t.nsp+","),null!=t.id&&(r+=t.id),null!=t.data&&(r+=JSON.stringify(t.data)),r}function i(t,e){function r(t){var r=l.deconstructPacket(t),n=o(r.packet),i=r.buffers;i.unshift(n),e(i)}l.removeBlobs(t,r)}function s(){this.reconstructor=null}function a(t){var r=0,n={type:Number(t.charAt(0))};if(null==e.types[n.type])return p();if(e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type){for(var o="";"-"!==t.charAt(++r)&&(o+=t.charAt(r),r!=t.length););if(o!=Number(o)||"-"!==t.charAt(r))throw new Error("Illegal attachments");n.attachments=Number(o)}if("/"===t.charAt(r+1))for(n.nsp="";++r;){var i=t.charAt(r);if(","===i)break;if(n.nsp+=i,r===t.length)break}else n.nsp="/";var s=t.charAt(r+1);if(""!==s&&Number(s)==s){for(n.id="";++r;){var i=t.charAt(r);if(null==i||Number(i)!=i){--r;break}if(n.id+=t.charAt(r),r===t.length)break}n.id=Number(n.id)}return t.charAt(++r)&&(n=c(n,t.substr(r))),n}function c(t,e){try{t.data=JSON.parse(e)}catch(t){return p()}return t}function h(t){this.reconPack=t,this.buffers=[]}function p(){return{type:e.ERROR,data:"parser error"}}var u=(r(3)("socket.io-parser"),r(5)),f=r(6),l=r(8),d=r(9);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=n,e.Decoder=s,n.prototype.encode=function(t,r){if(t.type!==e.EVENT&&t.type!==e.ACK||!f(t.data)||(t.type=t.type===e.EVENT?e.BINARY_EVENT:e.BINARY_ACK),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)i(t,r);else{var n=o(t);r([n])}},u(s.prototype),s.prototype.add=function(t){var r;if("string"==typeof t)r=a(t),e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type?(this.reconstructor=new h(r),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",r)):this.emit("decoded",r);else{if(!d(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");r=this.reconstructor.takeBinaryData(t),r&&(this.reconstructor=null,this.emit("decoded",r))}},s.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},h.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=l.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},h.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,r){function n(t){if(t)return o(t)}function o(t){for(var e in n.prototype)t[e]=n.prototype[e];return t}t.exports=n,n.prototype.on=n.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},n.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},n.prototype.off=n.prototype.removeListener=n.prototype.removeAllListeners=n.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r=this._callbacks["$"+t];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n,o=0;o<r.length;o++)if(n=r[o],n===e||n.fn===e){r.splice(o,1);break}return this},n.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),r=this._callbacks["$"+t];if(r){r=r.slice(0);for(var n=0,o=r.length;n<o;++n)r[n].apply(this,e)}return this},n.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},n.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,r){(function(e){function n(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var r=0,i=t.length;r<i;r++)if(n(t[r]))return!0;return!1}if("function"==typeof e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||"function"==typeof e.ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return n(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&&n(t[c]))return!0;return!1}var o=r(7),i=Object.prototype.toString,s="function"==typeof e.Blob||"[object BlobConstructor]"===i.call(e.Blob),a="function"==typeof e.File||"[object FileConstructor]"===i.call(e.File);t.exports=n}).call(e,function(){return this}())},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e,r){(function(t){function n(t,e){if(!t)return t;if(s(t)){var r={_placeholder:!0,num:e.length};return e.push(t),r}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=n(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=n(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var r=0;r<t.length;r++)t[r]=o(t[r],e);else if("object"==typeof t)for(var n in t)t[n]=o(t[n],e);return t}var i=r(7),s=r(9),a=Object.prototype.toString,c="function"==typeof t.Blob||"[object BlobConstructor]"===a.call(t.Blob),h="function"==typeof t.File||"[object FileConstructor]"===a.call(t.File);e.deconstructPacket=function(t){var e=[],r=t.data,o=t;return o.data=n(r,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function r(t,a,p){if(!t)return t;if(c&&t instanceof Blob||h&&t instanceof File){n++;var u=new FileReader;u.onload=function(){p?p[a]=this.result:o=this.result,--n||e(o)},u.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)r(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)r(t[l],l,t)}var n=0,o=t;r(o),n||e(o)}}).call(e,function(){return this}())},function(t,e){(function(e){function r(t){return e.Buffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer}t.exports=r}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e){if(!(this instanceof n))return new n(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new f({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var r=e.parser||c;this.encoder=new r.Encoder,this.decoder=new r.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(11),s=r(36),a=r(5),c=r(4),h=r(38),p=r(39),u=(r(3)("socket.io-client:manager"),r(34)),f=r(40),l=Object.prototype.hasOwnProperty;t.exports=n,n.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)l.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},n.prototype.updateSocketIds=function(){for(var t in this.nsps)l.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},n.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(n.prototype),n.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},n.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},n.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},n.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},n.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},n.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},n.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},n.prototype.open=n.prototype.connect=function(t,e){if(~this.readyState.indexOf("open"))return this;this.engine=i(this.uri,this.opts);var r=this.engine,n=this;this.readyState="opening",this.skipReconnect=!1;var o=h(r,"open",function(){n.onopen(),t&&t()}),s=h(r,"error",function(e){if(n.cleanup(),n.readyState="closed",n.emitAll("connect_error",e),t){var r=new Error("Connection error");r.data=e,t(r)}else n.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout,c=setTimeout(function(){o.destroy(),r.close(),r.emit("error","timeout"),n.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},n.prototype.onopen=function(){this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(h(t,"data",p(this,"ondata"))),this.subs.push(h(t,"ping",p(this,"onping"))),this.subs.push(h(t,"pong",p(this,"onpong"))),this.subs.push(h(t,"error",p(this,"onerror"))),this.subs.push(h(t,"close",p(this,"onclose"))),this.subs.push(h(this.decoder,"decoded",p(this,"ondecoded")))},n.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},n.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},n.prototype.ondata=function(t){this.decoder.add(t)},n.prototype.ondecoded=function(t){this.emit("packet",t)},n.prototype.onerror=function(t){this.emitAll("error",t)},n.prototype.socket=function(t,e){function r(){~u(o.connecting,n)||o.connecting.push(n)}var n=this.nsps[t];if(!n){n=new s(this,t,e),this.nsps[t]=n;var o=this;n.on("connecting",r),n.on("connect",function(){n.id=o.generateId(t)}),this.autoConnect&&r()}return n},n.prototype.destroy=function(t){var e=u(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},n.prototype.packet=function(t){var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(r){for(var n=0;n<r.length;n++)e.engine.write(r[n],t.options);e.encoding=!1,e.processPacketQueue()}))},n.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},n.prototype.cleanup=function(){for(var t=this.subs.length,e=0;e<t;e++){var r=this.subs.shift();r.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},n.prototype.close=n.prototype.disconnect=function(){this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},n.prototype.onclose=function(t){this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},n.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();this.reconnecting=!0;var r=setTimeout(function(){t.skipReconnect||(t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):t.onreconnect()}))},e);this.subs.push({destroy:function(){clearTimeout(r)}})}},n.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,r){t.exports=r(12)},function(t,e,r){t.exports=r(13),t.exports.parser=r(20)},function(t,e,r){(function(e){function n(t,r){if(!(this instanceof n))return new n(t,r);r=r||{},t&&"object"==typeof t&&(r=t,t=null),t?(t=h(t),r.hostname=t.host,r.secure="https"===t.protocol||"wss"===t.protocol,r.port=t.port,t.query&&(r.query=t.query)):r.host&&(r.hostname=h(r.host).host),this.secure=null!=r.secure?r.secure:e.location&&"https:"===location.protocol,r.hostname&&!r.port&&(r.port=this.secure?"443":"80"),this.agent=r.agent||!1,this.hostname=r.hostname||(e.location?location.hostname:"localhost"),this.port=r.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=r.query||{},"string"==typeof this.query&&(this.query=u.decode(this.query)),this.upgrade=!1!==r.upgrade,this.path=(r.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!r.forceJSONP,this.jsonp=!1!==r.jsonp,this.forceBase64=!!r.forceBase64,this.enablesXDR=!!r.enablesXDR,this.timestampParam=r.timestampParam||"t",this.timestampRequests=r.timestampRequests,this.transports=r.transports||["polling","websocket"],this.transportOptions=r.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=r.policyPort||843,this.rememberUpgrade=r.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=r.onlyBinaryUpgrades,this.perMessageDeflate=!1!==r.perMessageDeflate&&(r.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=r.pfx||null,this.key=r.key||null,this.passphrase=r.passphrase||null,this.cert=r.cert||null,this.ca=r.ca||null,this.ciphers=r.ciphers||null,this.rejectUnauthorized=void 0===r.rejectUnauthorized||r.rejectUnauthorized,this.forceNode=!!r.forceNode;var o="object"==typeof e&&e;o.global===o&&(r.extraHeaders&&Object.keys(r.extraHeaders).length>0&&(this.extraHeaders=r.extraHeaders),r.localAddress&&(this.localAddress=r.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e}var i=r(14),s=r(5),a=(r(3)("engine.io-client:socket"),r(34)),c=r(20),h=r(2),p=r(35),u=r(28);t.exports=n,n.priorWebsocketSuccess=!1,s(n.prototype),n.protocol=c.protocol,n.Socket=n,n.Transport=r(19),n.transports=r(14),n.parser=r(20),n.prototype.createTransport=function(t){var e=o(this.query);e.EIO=c.protocol,e.transport=t;var r=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var n=new i[t]({query:e,socket:this,agent:r.agent||this.agent,hostname:r.hostname||this.hostname,port:r.port||this.port,secure:r.secure||this.secure,path:r.path||this.path,forceJSONP:r.forceJSONP||this.forceJSONP,jsonp:r.jsonp||this.jsonp,forceBase64:r.forceBase64||this.forceBase64,enablesXDR:r.enablesXDR||this.enablesXDR,timestampRequests:r.timestampRequests||this.timestampRequests,timestampParam:r.timestampParam||this.timestampParam,policyPort:r.policyPort||this.policyPort,pfx:r.pfx||this.pfx,key:r.key||this.key,passphrase:r.passphrase||this.passphrase,cert:r.cert||this.cert,ca:r.ca||this.ca,ciphers:r.ciphers||this.ciphers,rejectUnauthorized:r.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:r.perMessageDeflate||this.perMessageDeflate,extraHeaders:r.extraHeaders||this.extraHeaders,forceNode:r.forceNode||this.forceNode,localAddress:r.localAddress||this.localAddress,requestTimeout:r.requestTimeout||this.requestTimeout,protocols:r.protocols||void 0});return n},n.prototype.open=function(){var t;if(this.rememberUpgrade&&n.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},n.prototype.setTransport=function(t){var e=this;this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},n.prototype.probe=function(t){function e(){if(u.onlyBinaryUpgrades){var t=!this.supportsBinary&&u.transport.supportsBinary;p=p||t}p||(h.send([{type:"ping",data:"probe"}]),h.once("packet",function(t){if(!p)if("pong"===t.type&&"probe"===t.data){if(u.upgrading=!0,u.emit("upgrading",h),!h)return;n.priorWebsocketSuccess="websocket"===h.name,u.transport.pause(function(){p||"closed"!==u.readyState&&(c(),u.setTransport(h),h.send([{type:"upgrade"}]),u.emit("upgrade",h),h=null,u.upgrading=!1,u.flush())})}else{var e=new Error("probe error");e.transport=h.name,u.emit("upgradeError",e)}}))}function r(){p||(p=!0,c(),h.close(),h=null)}function o(t){var e=new Error("probe error: "+t);e.transport=h.name,r(),u.emit("upgradeError",e)}function i(){o("transport closed")}function s(){o("socket closed")}function a(t){h&&t.name!==h.name&&r()}function c(){h.removeListener("open",e),h.removeListener("error",o),h.removeListener("close",i),u.removeListener("close",s),u.removeListener("upgrading",a)}var h=this.createTransport(t,{probe:1}),p=!1,u=this;n.priorWebsocketSuccess=!1,h.once("open",e),h.once("error",o),h.once("close",i),this.once("close",s),this.once("upgrading",a),h.open()},n.prototype.onOpen=function(){if(this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause)for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])},n.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(p(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}},n.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},n.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},n.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},n.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},n.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},n.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},n.prototype.write=n.prototype.send=function(t,e,r){return this.sendPacket("message",t,e,r),this},n.prototype.sendPacket=function(t,e,r,n){if("function"==typeof e&&(n=e,e=void 0),"function"==typeof r&&(n=r,r=null),"closing"!==this.readyState&&"closed"!==this.readyState){r=r||{},r.compress=!1!==r.compress;var o={type:t,data:e,options:r};this.emit("packetCreate",o),this.writeBuffer.push(o),n&&this.once("flush",n),this.flush()}},n.prototype.close=function(){function t(){n.onClose("forced close"),n.transport.close()}function e(){n.removeListener("upgrade",e),n.removeListener("upgradeError",e),t()}function r(){n.once("upgrade",e),n.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():t()}):this.upgrading?r():t()}return this},n.prototype.onError=function(t){n.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},n.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){var r=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),r.writeBuffer=[],r.prevBufferLen=0}},n.prototype.filterUpgrades=function(t){for(var e=[],r=0,n=t.length;r<n;r++)~a(this.transports,t[r])&&e.push(t[r]);return e}}).call(e,function(){return this}())},function(t,e,r){(function(t){function n(e){var r,n=!1,a=!1,c=!1!==e.jsonp;if(t.location){var h="https:"===location.protocol,p=location.port;p||(p=h?443:80),n=e.hostname!==location.hostname||p!==e.port,a=e.secure!==h}if(e.xdomain=n,e.xscheme=a,r=new o(e),"open"in r&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=r(15),i=r(17),s=r(31),a=r(32);e.polling=n,e.websocket=a}).call(e,function(){return this}())},function(t,e,r){(function(e){var n=r(16);t.exports=function(t){var r=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!r||n))return new XMLHttpRequest}catch(t){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(t){}if(!r)try{return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(e){t.exports=!1}},function(t,e,r){(function(e){function n(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var r="https:"===location.protocol,n=location.port;n||(n=r?443:80),this.xd=t.hostname!==e.location.hostname||n!==t.port,this.xs=t.secure!==r}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=r(15),c=r(18),h=r(5),p=r(29);r(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,p(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var r="string"!=typeof t&&void 0!==t,n=this.request({method:"POST",data:t,isBinary:r}),o=this;n.on("success",e),n.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=n},o.prototype.doPoll=function(){var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},h(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var r=this.xhr=new a(t),n=this;try{r.open(this.method,this.uri,this.async);try{if(this.extraHeaders){r.setDisableHeaderCheck&&r.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&r.setRequestHeader(o,this.extraHeaders[o])}}catch(t){}if("POST"===this.method)try{this.isBinary?r.setRequestHeader("Content-type","application/octet-stream"):r.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{r.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in r&&(r.withCredentials=!0),this.requestTimeout&&(r.timeout=this.requestTimeout),this.hasXDR()?(r.onload=function(){n.onLoad()},r.onerror=function(){n.onError(r.responseText)}):r.onreadystatechange=function(){if(2===r.readyState){var t;try{t=r.getResponseHeader("Content-Type")}catch(t){}"application/octet-stream"===t&&(r.responseType="arraybuffer")}4===r.readyState&&(200===r.status||1223===r.status?n.onLoad():setTimeout(function(){n.onError(r.status)},0))},r.send(this.data)}catch(t){return void setTimeout(function(){n.onError(t)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=n:this.xhr.onreadystatechange=n,t)try{this.xhr.abort()}catch(t){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(t){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(t){this.onError(t)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,r){function n(t){var e=t&&t.forceBase64;h&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=r(19),i=r(28),s=r(20),a=r(29),c=r(30);r(3)("engine.io-client:polling");t.exports=n;var h=function(){var t=r(15),e=new t({xdomain:!1});return null!=e.responseType}();a(n,o),n.prototype.name="polling",n.prototype.doOpen=function(){this.poll()},n.prototype.pause=function(t){function e(){r.readyState="paused",t()}var r=this;if(this.readyState="pausing",this.polling||!this.writable){var n=0;this.polling&&(n++,this.once("pollComplete",function(){--n||e()})),this.writable||(n++,this.once("drain",function(){--n||e()}))}else e()},n.prototype.poll=function(){this.polling=!0,this.doPoll(),this.emit("poll")},n.prototype.onData=function(t){var e=this,r=function(t,r,n){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,r),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState&&this.poll())},n.prototype.doClose=function(){function t(){e.write([{type:"close"}])}var e=this;"open"===this.readyState?t():this.once("open",t)},n.prototype.write=function(t){var e=this;this.writable=!1;var r=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,r)})},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",r="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(r=":"+this.port),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t}},function(t,e,r){function n(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=r(20),i=r(5);t.exports=n,i(n.prototype),n.prototype.onError=function(t,e){var r=new Error(t);return r.type="TransportError",r.description=e,this.emit("error",r),this},n.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},n.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},n.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},n.prototype.onOpen=function(){this.readyState="open",
this.writable=!0,this.emit("open")},n.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},n.prototype.onPacket=function(t){this.emit("packet",t)},n.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,r){(function(t){function n(t,r){var n="b"+e.packets[t.type]+t.data.data;return r(n)}function o(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return n(s.buffer)}function i(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,r,!0,n)},o.readAsArrayBuffer(t.data)}function s(t,r,n){if(!r)return e.encodeBase64Packet(t,n);if(g)return i(t,r,n);var o=new Uint8Array(1);o[0]=v[t.type];var s=new w([o.buffer,t.data]);return n(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(t){return!1}return t}function c(t,e,r){for(var n=new Array(t.length),o=l(t.length,r),i=function(t,r,o){e(r,function(e,r){n[t]=r,o(e,n)})},s=0;s<t.length;s++)i(s,t[s],o)}var h,p=r(21),u=r(6),f=r(22),l=r(23),d=r(24);t&&t.ArrayBuffer&&(h=r(26));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=p(v),k={type:"error",data:"parser error"},w=r(27);e.encodePacket=function(e,r,i,a){"function"==typeof r&&(a=r,r=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,r,a);if(w&&c instanceof t.Blob)return s(e,r,a);if(c&&c.base64)return n(e,a);var h=v[e.type];return void 0!==e.data&&(h+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(""+h)},e.encodeBase64Packet=function(r,n){var o="b"+e.packets[r.type];if(w&&r.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];n(o+t)},i.readAsDataURL(r.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(r.data))}catch(t){for(var a=new Uint8Array(r.data),c=new Array(a.length),h=0;h<a.length;h++)c[h]=a[h];s=String.fromCharCode.apply(null,c)}return o+=t.btoa(s),n(o)},e.decodePacket=function(t,r,n){if(void 0===t)return k;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),r);if(n&&(t=a(t),t===!1))return k;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:k}var i=new Uint8Array(t),o=i[0],s=f(t,1);return w&&"blob"===r&&(s=new w([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var r=b[t.charAt(0)];if(!h)return{type:r,data:{base64:!0,data:t.substr(1)}};var n=h.decode(t.substr(1));return"blob"===e&&w&&(n=new w([n])),{type:r,data:n}},e.encodePayload=function(t,r,n){function o(t){return t.length+":"+t}function i(t,n){e.encodePacket(t,!!s&&r,!1,function(t){n(null,o(t))})}"function"==typeof r&&(n=r,r=null);var s=u(t);return r&&s?w&&!g?e.encodePayloadAsBlob(t,n):e.encodePayloadAsArrayBuffer(t,n):t.length?void c(t,i,function(t,e){return n(e.join(""))}):n("0:")},e.decodePayload=function(t,r,n){if("string"!=typeof t)return e.decodePayloadAsBinary(t,r,n);"function"==typeof r&&(n=r,r=null);var o;if(""===t)return n(k,0,1);for(var i,s,a="",c=0,h=t.length;c<h;c++){var p=t.charAt(c);if(":"===p){if(""===a||a!=(i=Number(a)))return n(k,0,1);if(s=t.substr(c+1,i),a!=s.length)return n(k,0,1);if(s.length){if(o=e.decodePacket(s,r,!1),k.type===o.type&&k.data===o.data)return n(k,0,1);var u=n(o,c+i,h);if(!1===u)return}c+=i,a=""}else a+=p}return""!==a?n(k,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){return r(null,t)})}return t.length?void c(t,n,function(t,e){var n=e.reduce(function(t,e){var r;return r="string"==typeof e?e.length:e.byteLength,t+r.toString().length+r+2},0),o=new Uint8Array(n),i=0;return e.forEach(function(t){var e="string"==typeof t,r=t;if(e){for(var n=new Uint8Array(t.length),s=0;s<t.length;s++)n[s]=t.charCodeAt(s);r=n.buffer}e?o[i++]=0:o[i++]=1;for(var a=r.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var n=new Uint8Array(r),s=0;s<n.length;s++)o[i++]=n[s]}),r(o.buffer)}):r(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var n=new Uint8Array(t.length),o=0;o<t.length;o++)n[o]=t.charCodeAt(o);t=n.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,w){var c=new w([e.buffer,a.buffer,t]);r(null,c)}})}c(t,n,function(t,e){return r(new w(e))})},e.decodePayloadAsBinary=function(t,r,n){"function"==typeof r&&(n=r,r=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",h=1;255!==s[h];h++){if(c.length>310)return n(k,0,1);c+=s[h]}o=f(o,2+c.length),c=parseInt(c);var p=f(o,0,c);if(a)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(t){var u=new Uint8Array(p);p="";for(var h=0;h<u.length;h++)p+=String.fromCharCode(u[h])}i.push(p),o=f(o,c)}var l=i.length;i.forEach(function(t,o){n(e.decodePacket(t,r,!0),o,l)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],r=Object.prototype.hasOwnProperty;for(var n in t)r.call(t,n)&&e.push(n);return e}},function(t,e){t.exports=function(t,e,r){var n=t.byteLength;if(e=e||0,r=r||n,t.slice)return t.slice(e,r);if(e<0&&(e+=n),r<0&&(r+=n),r>n&&(r=n),e>=n||e>=r||0===n)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(r-e),s=e,a=0;s<r;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function r(t,e,r){function o(t,n){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=r):0!==o.count||i||e(null,n)}var i=!1;return r=r||n,o.count=t,0===t?e():o}function n(){}t.exports=r},function(t,e,r){var n;(function(t,o){!function(i){function s(t){for(var e,r,n=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(r=t.charCodeAt(o++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),o--)):n.push(e);return n}function a(t){for(var e,r=t.length,n=-1,o="";++n<r;)e=t[n],e>65535&&(e-=65536,o+=k(e>>>10&1023|55296),e=56320|1023&e),o+=k(e);return o}function c(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function h(t,e){return k(t>>e&63|128)}function p(t,e){if(0==(4294967168&t))return k(t);var r="";return 0==(4294965248&t)?r=k(t>>6&31|192):0==(4294901760&t)?(c(t,e)||(t=65533),r=k(t>>12&15|224),r+=h(t,6)):0==(4292870144&t)&&(r=k(t>>18&7|240),r+=h(t,12),r+=h(t,6)),r+=k(63&t|128)}function u(t,e){e=e||{};for(var r,n=!1!==e.strict,o=s(t),i=o.length,a=-1,c="";++a<i;)r=o[a],c+=p(r,n);return c}function f(){if(b>=v)throw Error("Invalid byte index");var t=255&g[b];if(b++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function l(t){var e,r,n,o,i;if(b>v)throw Error("Invalid byte index");if(b==v)return!1;if(e=255&g[b],b++,0==(128&e))return e;if(192==(224&e)){if(r=f(),i=(31&e)<<6|r,i>=128)return i;throw Error("Invalid continuation byte")}if(224==(240&e)){if(r=f(),n=f(),i=(15&e)<<12|r<<6|n,i>=2048)return c(i,t)?i:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(r=f(),n=f(),o=f(),i=(7&e)<<18|r<<12|n<<6|o,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}function d(t,e){e=e||{};var r=!1!==e.strict;g=s(t),v=g.length,b=0;for(var n,o=[];(n=l(r))!==!1;)o.push(n);return a(o)}var y="object"==typeof e&&e,m=("object"==typeof t&&t&&t.exports==y&&t,"object"==typeof o&&o);m.global!==m&&m.window!==m||(i=m);var g,v,b,k=String.fromCharCode,w={version:"2.1.2",encode:u,decode:d};n=function(){return w}.call(e,r,e,t),!(void 0!==n&&(t.exports=n))}(this)}).call(e,r(25)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=new Uint8Array(256),n=0;n<t.length;n++)r[t.charCodeAt(n)]=n;e.encode=function(e){var r,n=new Uint8Array(e),o=n.length,i="";for(r=0;r<o;r+=3)i+=t[n[r]>>2],i+=t[(3&n[r])<<4|n[r+1]>>4],i+=t[(15&n[r+1])<<2|n[r+2]>>6],i+=t[63&n[r+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,n,o,i,s,a=.75*t.length,c=t.length,h=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var p=new ArrayBuffer(a),u=new Uint8Array(p);for(e=0;e<c;e+=4)n=r[t.charCodeAt(e)],o=r[t.charCodeAt(e+1)],i=r[t.charCodeAt(e+2)],s=r[t.charCodeAt(e+3)],u[h++]=n<<2|o>>4,u[h++]=(15&o)<<4|i>>2,u[h++]=(3&i)<<6|63&s;return p}}()},function(t,e){(function(e){function r(t){for(var e=0;e<t.length;e++){var r=t[e];if(r.buffer instanceof ArrayBuffer){var n=r.buffer;if(r.byteLength!==n.byteLength){var o=new Uint8Array(r.byteLength);o.set(new Uint8Array(n,r.byteOffset,r.byteLength)),n=o.buffer}t[e]=n}}}function n(t,e){e=e||{};var n=new i;r(t);for(var o=0;o<t.length;o++)n.append(t[o]);return e.type?n.getBlob(e.type):n.getBlob()}function o(t,e){return r(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(t){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(t){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?n:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e="";for(var r in t)t.hasOwnProperty(r)&&(e.length&&(e+="&"),e+=encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return e},e.decode=function(t){for(var e={},r=t.split("&"),n=0,o=r.length;n<o;n++){var i=r[n].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){"use strict";function r(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function n(t){var e=0;for(p=0;p<t.length;p++)e=e*a+c[t.charAt(p)];return e}function o(){var t=r(+new Date);return t!==i?(h=0,i=t):t+"."+r(h++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},h=0,p=0;p<a;p++)c[s[p]]=p;o.encode=r,o.decode=n,t.exports=o},function(t,e,r){(function(e){function n(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var r=this;a.push(function(t){r.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){r.script&&(r.script.onerror=n)},!1)}var i=r(18),s=r(29);t.exports=o;var a,c=/\n/g,h=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var r=document.getElementsByTagName("script")[0];r?r.parentNode.insertBefore(e,r):(document.head||document.body).appendChild(e),this.script=e;var n="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);n&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function r(){n(),e()}function n(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var t='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(t)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),p=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=p,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),n(),t=t.replace(h,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(t){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&r()}:this.iframe.onload=r}}).call(e,function(){return this}())},function(t,e,r){(function(e){function n(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=p&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(u=o),i.call(this,t)}var o,i=r(19),s=r(20),a=r(28),c=r(29),h=r(30),p=(r(3)("engine.io-client:websocket"),e.WebSocket||e.MozWebSocket);if("undefined"==typeof window)try{o=r(33)}catch(t){}var u=p;u||"undefined"!=typeof window||(u=o),t.exports=n,c(n,i),n.prototype.name="websocket",n.prototype.supportsBinary=!0,n.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,r={agent:this.agent,perMessageDeflate:this.perMessageDeflate};r.pfx=this.pfx,r.key=this.key,r.passphrase=this.passphrase,r.cert=this.cert,r.ca=this.ca,r.ciphers=this.ciphers,r.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(r.headers=this.extraHeaders),this.localAddress&&(r.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new u(t,e):new u(t):new u(t,e,r)}catch(t){return this.emit("error",t)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},n.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},n.prototype.write=function(t){function r(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,n.supportsBinary,function(i){if(!n.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),n.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<n.perMessageDeflate.threshold&&(s.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(i):n.ws.send(i,s)}catch(t){}--o||r()})}(t[i])},n.prototype.onClose=function(){i.prototype.onClose.call(this)},n.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",r="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(r=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=h()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t},n.prototype.check=function(){return!(!u||"__initialize"in u&&this.name===n.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e){(function(e){var r=/^[\],:{}\s]*$/,n=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,o=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,i=/(?:^|:|,)(?:\s*\[)+/g,s=/^\s+/,a=/\s+$/;t.exports=function(t){return"string"==typeof t&&t?(t=t.replace(s,"").replace(a,""),e.JSON&&JSON.parse?JSON.parse(t):r.test(t.replace(n,"@").replace(o,"]").replace(i,""))?new Function("return "+t)():void 0):null}}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e,r){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,r&&r.query&&(this.query=r.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(4),s=r(5),a=r(37),c=r(38),h=r(39),p=(r(3)("socket.io-client:socket"),r(28));t.exports=e=n;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},f=s.prototype.emit;s(n.prototype),n.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",h(this,"onopen")),c(t,"packet",h(this,"onpacket")),c(t,"close",h(this,"onclose"))]}},n.prototype.open=n.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},n.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},n.prototype.emit=function(t){if(u.hasOwnProperty(t))return f.apply(this,arguments),this;var e=a(arguments),r={type:i.EVENT,data:e};return r.options={},r.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(this.acks[this.ids]=e.pop(),r.id=this.ids++),this.connected?this.packet(r):this.sendBuffer.push(r),delete this.flags,this},n.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},n.prototype.onopen=function(){if("/"!==this.nsp)if(this.query){var t="object"===o(this.query)?p.encode(this.query):this.query;this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},n.prototype.onclose=function(t){this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},n.prototype.onpacket=function(t){if(t.nsp===this.nsp)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},n.prototype.onevent=function(t){var e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?f.apply(this,e):this.receiveBuffer.push(e)},n.prototype.ack=function(t){var e=this,r=!1;return function(){if(!r){r=!0;var n=a(arguments);e.packet({type:i.ACK,id:t,data:n})}}},n.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e&&(e.apply(this,t.data),delete this.acks[t.id])},n.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},n.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)f.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},n.prototype.ondisconnect=function(){this.destroy(),this.onclose("io server disconnect")},n.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},n.prototype.close=n.prototype.disconnect=function(){return this.connected&&this.packet({type:i.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},n.prototype.compress=function(t){return this.flags=this.flags||{},this.flags.compress=t,this}},function(t,e){function r(t,e){var r=[];e=e||0;for(var n=e||0;n<t.length;n++)r[n-e]=t[n];return r}t.exports=r},function(t,e){"use strict";function r(t,e,r){return t.on(e,r),{destroy:function(){t.removeListener(e,r)}}}t.exports=r},function(t,e){var r=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var n=r.call(arguments,2);return function(){return e.apply(t,n.concat(r.call(arguments)))}}},function(t,e){function r(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=r,r.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),r=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-r:t+r}return 0|Math.min(t,this.max)},r.prototype.reset=function(){this.attempts=0},r.prototype.setMin=function(t){this.ms=t},r.prototype.setMax=function(t){this.max=t},r.prototype.setJitter=function(t){this.jitter=t}}])});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(17);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(48);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(49);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(51);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(52);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(53);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Embodied = function () {
  /**
  * Constructs a Embodied instance.
  * @constructor
  */
  function Embodied() {
    _classCallCheck(this, Embodied);

    this.body_ = {};
  }

  /**
  * Gets the json object that represents this instance.
  * @return {!Object}
  */


  _createClass(Embodied, [{
    key: 'body',
    value: function body() {
      return this.body_;
    }

    /**
    * If the given object is an instance of Embodied, this will
    * return its body content. Otherwise this will return the
    * original object.
    * @param {*} obj
    * @return {*}
    * @static
    */

  }, {
    key: 'toString',


    /**
    * Gets the json string that represents this instance.
    * @return {string}
    */
    value: function toString() {
      return JSON.stringify(this.body());
    }
  }], [{
    key: 'toBody',
    value: function toBody(obj) {
      return obj instanceof Embodied ? obj.body() : obj;
    }
  }]);

  return Embodied;
}();

exports.default = Embodied;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TreeNode = exports.MultiMap = undefined;

var _MultiMap = __webpack_require__(43);

var _MultiMap2 = _interopRequireDefault(_MultiMap);

var _TreeNode = __webpack_require__(44);

var _TreeNode2 = _interopRequireDefault(_TreeNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.MultiMap = _MultiMap2.default;
exports.TreeNode = _TreeNode2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertUriWithNoPath = exports.assertUserSignedIn = exports.assertResponseSucceeded = exports.assertObject = exports.assertFunction = exports.assertNotNull = exports.assertDefAndNotNull = exports.assertBrowserEnvironment = undefined;

var _metal = __webpack_require__(0);

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Throws an exception if the current environment is not a browser.
 */
function assertBrowserEnvironment() {
  if (!_globals2.default.window) {
    throw new Error('Sign-in type not supported in this environment');
  }
}

/**
 * Throws an exception if given value is undefined or null.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertDefAndNotNull(value, errorMessage) {
  if (!_metal.core.isDefAndNotNull(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Throws an exception if given value is null.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertNotNull(value, errorMessage) {
  if (_metal.core.isNull(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Throws an exception if given value is not a function.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertFunction(value, errorMessage) {
  if (!_metal.core.isFunction(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Throws an exception if given value is not an object.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertObject(value, errorMessage) {
  if (!_metal.core.isObject(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Checks if a response has succeeded. The function checks if the `succeeded`
 * method of response object returns true. Throws an exception if the returned
 * value is false.
 * @param {!Object} response The response to be checked.
 * @return {Object} The response itself if valid. Otherwise throws an exception.
 */
function assertResponseSucceeded(response) {
  if (!response.succeeded()) {
    throw response.body();
  }
  return response;
}

/**
 * Checks if a valid user is provided to the function. Throws an exception
 * in case of an invalid user.
 * @param {!Object} user The user to be checked.
 */
function assertUserSignedIn(user) {
  if (!_metal.core.isDefAndNotNull(user)) {
    throw new Error('You must be signed-in to perform this operation');
  }
}

/**
 * Checks if an URL with a valid path is provided. Throws an exception
 * if the provided URL doesn't have a valid path.
 * @param {!string} url The URL to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertUriWithNoPath(url, errorMessage) {
  var uri = new _metalUri2.default(url);
  if (uri.getPathname().length > 1) {
    throw new Error(errorMessage);
  }
}

exports.assertBrowserEnvironment = assertBrowserEnvironment;
exports.assertDefAndNotNull = assertDefAndNotNull;
exports.assertNotNull = assertNotNull;
exports.assertFunction = assertFunction;
exports.assertObject = assertObject;
exports.assertResponseSucceeded = assertResponseSucceeded;
exports.assertUserSignedIn = assertUserSignedIn;
exports.assertUriWithNoPath = assertUriWithNoPath;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied2 = __webpack_require__(1);

var _Embodied3 = _interopRequireDefault(_Embodied2);

var _FilterBody = __webpack_require__(20);

var _FilterBody2 = _interopRequireDefault(_FilterBody);

var _Geo = __webpack_require__(15);

var _Geo2 = _interopRequireDefault(_Geo);

var _Range = __webpack_require__(8);

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for building filters.
 * @extends {Embodied}
 */
var Filter = function (_Embodied) {
		_inherits(Filter, _Embodied);

		/**
  * Constructs a {@link Filter} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
		function Filter(field, operatorOrValue, opt_value) {
				_classCallCheck(this, Filter);

				var _this = _possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this));

				_this.body_ = new _FilterBody2.default(field, operatorOrValue, opt_value);
				return _this;
		}

		/**
  * Adds a filter to be composed with this filter using the given operator.
  * @param {string} operator
  * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
  *   the name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @return {Filter} Returns the {@link Filter} object itself, so calls can be
  *   chained.
  * @chainable
  */


		_createClass(Filter, [{
				key: 'add',
				value: function add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
						var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
						this.body_.add(operator, filter);
						return this;
				}

				/**
    * Adds filters to be composed with this filter using the given operator.
    * @param {string} operator
    * @param {...*} filters A variable amount of filters to be composed.
    * @return {Filter} Returns the {@link Filter} object itself, so calls can be
    *   chained.
    * @chainable
    */

		}, {
				key: 'addMany',
				value: function addMany(operator) {
						var _body_;

						for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
								filters[_key - 1] = arguments[_key];
						}

						(_body_ = this.body_).addMany.apply(_body_, [operator].concat(filters));
						return this;
				}

				/**
    * Adds a filter to be composed with this filter using the "and" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    *   the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {Filter} Returns the {@link Filter} object itself, so calls can be
    *   chained.
    * @chainable
    */

		}, {
				key: 'and',
				value: function and(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "any" operator.
    * @param {string} field The name of the field to filter by.
    * @param {Array|*} values A variable amount of values to be used with
    *   the "any" operator. Can be passed either as a single array or as
    *   separate params.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'body',


				/**
    * Gets the json object that represents this filter.
    * @return {!Object}
    */
				value: function body() {
						return this.body_.getObject();
				}

				/**
    * Returns a {@link Filter} instance that uses the "gd" operator.
    * @param {string} field The field's name.
    * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
    * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
    *   the distance value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'or',


				/**
    * Adds a filter to be composed with this filter using the "or" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    * the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {Filter} Returns the {@link Filter} object itself, so calls can be
    *   chained.
    * @chainable
    */
				value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
				}

				/**
    * Converts the given arguments into a {@link Filter} instance.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    * the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    */

		}], [{
				key: 'any',
				value: function any(field) {
						for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								values[_key2 - 1] = arguments[_key2];
						}

						if (values.length === 1 && Array.isArray(values[0])) {
								values = values[0];
						}
						return new Filter(field, 'any', values);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gp" operator.
    * This is a special use case of `Filter.polygon` for bounding
    * boxes.
    * @param {string} field The field's name.
    * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
    *   a bounding box's upper left coordinate.
    * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'boundingBox',
				value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
						if (boxOrUpperLeft instanceof _Geo2.default.BoundingBox) {
								return Filter.polygon.apply(Filter, [field].concat(_toConsumableArray(boxOrUpperLeft.getPoints())));
						} else {
								return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
						}
				}
		}, {
				key: 'distance',
				value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
						var location = locationOrCircle;
						var range = opt_rangeOrDistance;
						if (locationOrCircle instanceof _Geo2.default.Circle) {
								location = locationOrCircle.getCenter();
								range = _Range2.default.to(locationOrCircle.getRadius());
						} else if (!(opt_rangeOrDistance instanceof _Range2.default)) {
								range = _Range2.default.to(opt_rangeOrDistance);
						}
						return Filter.distanceInternal_(field, location, range);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gd" operator. This
    * is just an internal helper used by `Filter.distance`.
    * @param {string} field The field's name.
    * @param {*} location A location coordinate.
    * @param {Range} range A `Range` instance.
    * @return {!Filter}
    * @protected
    * @static
    */

		}, {
				key: 'distanceInternal_',
				value: function distanceInternal_(field, location, range) {
						var value = {
								location: _Embodied3.default.toBody(location)
						};
						range = range.body();
						if (range.from) {
								value.min = range.from;
						}
						if (range.to) {
								value.max = range.to;
						}
						return Filter.field(field, 'gd', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'equal',
				value: function equal(field, value) {
						return new Filter(field, '=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "exists" operator.
    * @param {string} field The field's name.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'exists',
				value: function exists(field) {
						return Filter.field(field, 'exists', null);
				}

				/**
    * Returns a {@link Filter} instance that uses the "fuzzy" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
    *   be the query, otherwise it should be the fuzziness value.
    * @param {number=} opt_fuzziness The fuzziness value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'fuzzy',
				value: function fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
						return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
				}

				/**
    * Returns a {@link Filter} instance that uses the given fuzzy operator. This
    * is an internal implementation used by the `Filter.fuzzy` method.
    * @param {string} operator The fuzzy operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
    *   be the query, otherwise it should be the fuzziness value.
    * @param {number=} opt_fuzziness The fuzziness value.
    * @return {!Filter}
    * @protected
    * @static
    */

		}, {
				key: 'fuzzyInternal_',
				value: function fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
						var arg2IsString = _metal.core.isString(opt_queryOrFuzziness);

						var value = {
								query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
						};
						var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
						if (fuzziness) {
								value.fuzziness = fuzziness;
						}

						var field = arg2IsString ? fieldOrQuery : Filter.ALL;
						return Filter.field(field, operator, value);
				}

				/**
    * Returns a {@link Filter} instance that uses the ">" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'gt',
				value: function gt(field, value) {
						return new Filter(field, '>', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the ">=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'gte',
				value: function gte(field, value) {
						return new Filter(field, '>=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "match" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'match',
				value: function match(fieldOrQuery, opt_query) {
						var field = _metal.core.isString(opt_query) ? fieldOrQuery : Filter.ALL;
						var query = _metal.core.isString(opt_query) ? opt_query : fieldOrQuery;
						return Filter.field(field, 'match', query);
				}

				/**
    * Returns a {@link Filter} instance that uses the "missing" operator.
    * @param {string} field The field's name.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'missing',
				value: function missing(field) {
						return Filter.field(field, 'missing', null);
				}

				/**
    * Returns a {@link Filter} instance that uses the "phrase" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'phrase',
				value: function phrase(fieldOrQuery, opt_query) {
						var field = _metal.core.isString(opt_query) ? fieldOrQuery : Filter.ALL;
						var query = _metal.core.isString(opt_query) ? opt_query : fieldOrQuery;
						return Filter.field(field, 'phrase', query);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gp" operator.
    * @param {string} field The name of the field.
    * @param {...!Object} points Objects representing points in the polygon.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'polygon',
				value: function polygon(field) {
						for (var _len3 = arguments.length, points = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
								points[_key3 - 1] = arguments[_key3];
						}

						points = points.map(function (point) {
								return _Embodied3.default.toBody(point);
						});
						return Filter.field(field, 'gp', points);
				}

				/**
    * Returns a {@link Filter} instance that uses the "prefix" operator.
    * @param {string} fieldOrQuery If no second argument is given, this should
    *   be the query string, in which case all fields will be matched. Otherwise,
    *   this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'prefix',
				value: function prefix(fieldOrQuery, opt_query) {
						var field = _metal.core.isDefAndNotNull(opt_query) ? fieldOrQuery : Filter.ALL;
						var query = _metal.core.isDefAndNotNull(opt_query) ? opt_query : fieldOrQuery;
						return Filter.field(field, 'prefix', query);
				}

				/**
    * Returns a {@link Filter} instance that uses the "range" operator.
    * @param {string} field The field's name.
    * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
    * @param {*=} opt_max The range's max value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'range',
				value: function range(field, rangeOrMin, opt_max) {
						var range = rangeOrMin;
						if (!(range instanceof _Range2.default)) {
								range = _Range2.default.range(rangeOrMin, opt_max);
						}
						return Filter.field(field, 'range', range);
				}

				/**
    * Returns a {@link Filter} instance that uses the "~" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'regex',
				value: function regex(field, value) {
						return new Filter(field, '~', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gs" operator.
    * @param {string} field The field's name.
    * @param {...!Object} shapes Objects representing shapes.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'shape',
				value: function shape(field) {
						for (var _len4 = arguments.length, shapes = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
								shapes[_key4 - 1] = arguments[_key4];
						}

						shapes = shapes.map(function (shape) {
								return _Embodied3.default.toBody(shape);
						});
						var value = {
								type: 'geometrycollection',
								geometries: shapes
						};
						return Filter.field(field, 'gs', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "similar" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {?string} query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'similar',
				value: function similar(fieldOrQuery, query) {
						var field = _metal.core.isString(query) ? fieldOrQuery : Filter.ALL;
						var value = {
								query: _metal.core.isString(query) ? query : fieldOrQuery
						};
						return Filter.field(field, 'similar', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "<" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'lt',
				value: function lt(field, value) {
						return new Filter(field, '<', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "<=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'lte',
				value: function lte(field, value) {
						return new Filter(field, '<=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "none" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|*)} value A variable amount of values to be used with
    * the "none" operator. Can be passed either as a single array or as
    * separate params.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'none',
				value: function none(field) {
						for (var _len5 = arguments.length, values = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
								values[_key5 - 1] = arguments[_key5];
						}

						if (values.length === 1 && Array.isArray(values[0])) {
								values = values[0];
						}
						return new Filter(field, 'none', values);
				}

				/**
    * Returns a {@link Filter} instance that uses the "!=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'notEqual',
				value: function notEqual(field, value) {
						return new Filter(field, '!=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "not" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    * the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'not',
				value: function not(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
				}

				/**
    * Returns a {@link Filter} instance.
    * @param {string} field The name of the field to filter by.
    * @param {*} operatorOrValue If a third param is given, this should be the
    * filter's operator (like ">="). Otherwise, this will be used as the
    * filter's value, and the filter's operator will be "=".
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'field',
				value: function field(_field, operatorOrValue, opt_value) {
						return new Filter(_field, operatorOrValue, opt_value);
				}
		}, {
				key: 'toFilter',
				value: function toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
						var filter = fieldOrFilter;
						if (!(filter instanceof Filter)) {
								filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
						}
						return filter;
				}
		}]);

		return Filter;
}(_Embodied3.default);

/**
 * String constant that represents all fields.
 * @type {string}
 * @static
 */


Filter.ALL = '*';

exports.default = Filter;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var globals = {};

if (typeof window !== 'undefined') {
  globals.window = window;
}

if (typeof document !== 'undefined') {
  globals.document = document;
}

exports.default = globals;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Uri = __webpack_require__(45).default;

if (typeof URL === 'undefined' && "function" !== 'undefined') {
	// If there is no "document", then this should be running in NodeJS or in ReactNative env and
	// in this case we should use the "url" NPM module as the parse function.
	// In ReactNative env "path" will be replaced with "path-browserify".

	var path = __webpack_require__(54);
	var url = __webpack_require__(61);

	Uri.setParseFn(function(urlStr) {
		var parsed = url.parse(urlStr);
		parsed.pathname = path.normalize(parsed.pathname);
		return parsed;
	});
}

module.exports = Uri;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied2 = __webpack_require__(1);

var _Embodied3 = _interopRequireDefault(_Embodied2);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _Aggregation = __webpack_require__(19);

var _Aggregation2 = _interopRequireDefault(_Aggregation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for building queries.
 * @extends {Embodied}
 */
var Query = function (_Embodied) {
		_inherits(Query, _Embodied);

		function Query() {
				_classCallCheck(this, Query);

				return _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).apply(this, arguments));
		}

		_createClass(Query, [{
				key: 'aggregate',


				/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */
				value: function aggregate(name, aggregationOrField, opt_operator) {
						var aggregation = aggregationOrField;
						if (!(aggregation instanceof _Aggregation2.default)) {
								aggregation = _Aggregation2.default.field(aggregationOrField, opt_operator);
						}

						var field = aggregation.getField();
						var value = {};
						value[field] = {
								name: name,
								operator: aggregation.getOperator()
						};
						if (_metal.core.isDefAndNotNull(aggregation.getValue())) {
								value[field].value = aggregation.getValue();
						}

						if (!this.body_.aggregation) {
								this.body_.aggregation = [];
						}
						this.body_.aggregation.push(value);
						return this;
				}

				/**
    * Sets this query's type to "count".
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'count',
				value: function count() {
						return this.type('count');
				}

				/**
    * Sets this query's type to "fetch".
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'fetch',
				value: function fetch() {
						return this.type('fetch');
				}

				/**
    * Adds a filter to this Query.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'filter',
				value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
						var filter = _Filter2.default.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
						if (!this.body_.filter) {
								this.body_.filter = [];
						}
						this.body_.filter.push(filter.body());
						return this;
				}

				/**
    * Sets the query offset.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'offset',
				value: function offset(_offset2) {
						this.body_.offset = _offset2;
						return this;
				}

				/**
    * Adds a highlight entry to this {@link Query} instance.
    * @param {string} field The field's name.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'highlight',
				value: function highlight(field) {
						if (!this.body_.highlight) {
								this.body_.highlight = [];
						}

						this.body_.highlight.push(field);
						return this;
				}

				/**
    * Sets the query limit.
    * @param {number} limit The max amount of entries that this query should
    *   return.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'limit',
				value: function limit(_limit2) {
						this.body_.limit = _limit2;
						return this;
				}

				/**
    * Adds a search to this {@link Query} instance.
    * @param {!Filter|string=} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a {@link Filter}
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created. If the value of this parameter is
    *   undefined or null, no filter will be provided to the search query.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'search',
				value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
						var filter = filterOrTextOrField;

						if (opt_value) {
								filter = _Filter2.default.field(filterOrTextOrField, opt_textOrOperator, opt_value);
						} else if (opt_textOrOperator) {
								filter = _Filter2.default.match(filterOrTextOrField, opt_textOrOperator);
						} else if (filter && !(filter instanceof _Filter2.default)) {
								filter = _Filter2.default.match(filterOrTextOrField);
						}

						this.type('search');

						if (filter) {
								this.filter(filter);
						}

						return this;
				}

				/**
    * Adds a sort entry to this query, specifying the field this query should be
    * sorted by and, optionally, the sort direction.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'sort',
				value: function sort(field, opt_direction) {
						if (!this.body_.sort) {
								this.body_.sort = [];
						}
						var sortEntry = {};
						sortEntry[field] = opt_direction || 'asc';
						this.body_.sort.push(sortEntry);
						return this;
				}

				/**
    * Sets the query type.
    * @param {string} type The query's type. For example: "count", "fetch".
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'type',
				value: function type(_type2) {
						this.body_.type = _type2;
						return this;
				}
		}], [{
				key: 'aggregate',

				/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {!Query}
    * @static
    */
				value: function aggregate(name, aggregationOrField, opt_operator) {
						return new Query().aggregate(name, aggregationOrField, opt_operator);
				}

				/**
    * Sets this query's type to "count".
    * @return {!Query}
    * @static
    */

		}, {
				key: 'count',
				value: function count() {
						return new Query().type('count');
				}

				/**
    * Sets this query's type to "fetch".
    * @return {!Query}
    * @static
    */

		}, {
				key: 'fetch',
				value: function fetch() {
						return new Query().type('fetch');
				}

				/**
    * Adds a filter to this Query.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'filter',
				value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
				}

				/**
    * Sets the query offset.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'offset',
				value: function offset(_offset) {
						return new Query().offset(_offset);
				}

				/**
    * Adds a highlight entry to this {@link Query} instance.
    * @param {string} field The field's name.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'highlight',
				value: function highlight(field) {
						return new Query().highlight(field);
				}

				/**
    * Sets the query limit.
    * @param {number} limit The max amount of entries that this query should
    *   return.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'limit',
				value: function limit(_limit) {
						return new Query().limit(_limit);
				}

				/**
    * Adds a search to this {@link Query} instance.
    * @param {!Filter|string} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a {@link Filter}
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'search',
				value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
						return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
				}

				/**
    * Adds a sort entry to this query, specifying the field this query should be
    * sorted by and, optionally, the sort direction.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'sort',
				value: function sort(field, opt_direction) {
						return new Query().sort(field, opt_direction);
				}

				/**
    * Sets the query type.
    * @param {string} type The query's type. For example: "count", "fetch".
    * @return {!Query}
    * @static
    */

		}, {
				key: 'type',
				value: function type(_type) {
						return new Query().type(_type);
				}
		}]);

		return Query;
}(_Embodied3.default);

exports.default = Query;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied2 = __webpack_require__(1);

var _Embodied3 = _interopRequireDefault(_Embodied2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for building range objects to be used by `Filter`.
 * @extends {Embodied}
 */
var Range = function (_Embodied) {
  _inherits(Range, _Embodied);

  /**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @param {*} opt_to
  * @constructor
  */
  function Range(from, opt_to) {
    _classCallCheck(this, Range);

    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this));

    if (_metal.core.isDefAndNotNull(from)) {
      _this.body_.from = from;
    }
    if (_metal.core.isDefAndNotNull(opt_to)) {
      _this.body_.to = opt_to;
    }
    return _this;
  }

  /**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @return {!Range}
  * @static
  */


  _createClass(Range, null, [{
    key: 'from',
    value: function from(_from) {
      return new Range(_from);
    }

    /**
    * Constructs a {@link Range} instance.
    * @param {*} from
    * @param {*} to
    * @return {!Range}
    * @static
    */

  }, {
    key: 'range',
    value: function range(from, to) {
      return new Range(from, to);
    }

    /**
    * Constructs a {@link Range} instance.
    * @param {*} to
    * @return {!Range}
    * @static
    */

  }, {
    key: 'to',
    value: function to(_to) {
      return new Range(null, _to);
    }
  }]);

  return Range;
}(_Embodied3.default);

exports.default = Range;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assertions = __webpack_require__(3);

var _metalStructs = __webpack_require__(2);

var _Auth = __webpack_require__(10);

var _Auth2 = _interopRequireDefault(_Auth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for encapsulating API calls.
 */
var ApiHelper = function () {
  /**
  * Constructs an {@link ApiHelper} instance.
  * @param {!WeDeploy} wedeployClient {@link WeDeploy} client reference.
  * @constructor
  */
  function ApiHelper(wedeployClient) {
    _classCallCheck(this, ApiHelper);

    (0, _assertions.assertDefAndNotNull)(wedeployClient, 'WeDeploy client reference must be specified');
    this.wedeployClient = wedeployClient;
    this.headers_ = new _metalStructs.MultiMap();
  }

  /**
  * Adds a header. If a header with the same name already exists, it will not
  * be overwritten, but the new value will be stored as well. The order is
  * preserved.
  * @param {string} name
  * @param {string} value
  * @return {!ClientMessage} Returns the {@link ClientMessage}
  *   object itself, so calls can be chained.
  * @chainable
  */


  _createClass(ApiHelper, [{
    key: 'header',
    value: function header(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.headers_.set(name, value);
      return this;
    }

    /**
    * Adds authorization information to this request.
    * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
    * an authorization token, or the email.
    * @param {string=} opt_password If a email is given as the first param,
    * this should be the password.
    * @return {ApiHelper}
    * @chainable
    */

  }, {
    key: 'auth',
    value: function auth(authOrTokenOrEmail, opt_password) {
      this.helperAuthScope = _Auth2.default.create(authOrTokenOrEmail, opt_password);
      this.helperAuthScope.wedeployClient = this.wedeployClient;
      return this;
    }
  }]);

  return ApiHelper;
}();

exports.default = ApiHelper;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metalStructs = __webpack_require__(2);

var _assertions = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for storing authorization information.
 */
var Auth = function () {
  /**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrEmail Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @constructor
  */
  function Auth(tokenOrEmail) {
    var opt_password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Auth);

    this.token = _metal.core.isString(opt_password) ? null : tokenOrEmail;
    this.email = _metal.core.isString(opt_password) ? tokenOrEmail : null;
    this.password = opt_password;

    this.createdAt = null;
    this.id = null;
    this.name = null;
    this.photoUrl = null;
    this.supportedScopes = [];
    this.wedeployClient = null;
    this.headers_ = new _metalStructs.MultiMap();
  }

  /**
  * Constructs an {@link Auth} instance.
  * @param {string} authOrTokenOrEmail Either an auth instance, the
  *   authorization token, or the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @return {!Auth}
  */


  _createClass(Auth, [{
    key: 'getCreatedAt',


    /**
    * Gets the created at date.
    * @return {string}
    */
    value: function getCreatedAt() {
      return this.createdAt;
    }

    /**
    * Gets the email.
    * @return {string}
    */

  }, {
    key: 'getEmail',
    value: function getEmail() {
      return this.email;
    }

    /**
    * Gets the id.
    * @return {string}
    */

  }, {
    key: 'getId',
    value: function getId() {
      return this.id;
    }

    /**
    * Gets the name.
    * @return {string}
    */

  }, {
    key: 'getName',
    value: function getName() {
      return this.name;
    }

    /**
    * Gets the password.
    * @return {string}
    */

  }, {
    key: 'getPassword',
    value: function getPassword() {
      return this.password;
    }

    /**
    * Gets the photo url.
    * @return {string}
    */

  }, {
    key: 'getPhotoUrl',
    value: function getPhotoUrl() {
      return this.photoUrl;
    }

    /**
    * Gets the supported scopes.
    * @return {array.<string>}
    */

  }, {
    key: 'getSupportedScopes',
    value: function getSupportedScopes() {
      return this.supportedScopes;
    }

    /**
    * Gets the token.
    * @return {string}
    */

  }, {
    key: 'getToken',
    value: function getToken() {
      return this.token;
    }

    /**
    * Checks if created at is set.
    * @return {boolean}
    */

  }, {
    key: 'hasCreatedAt',
    value: function hasCreatedAt() {
      return _metal.core.isDefAndNotNull(this.createdAt);
    }

    /**
    * Checks if the email is set.
    * @return {boolean}
    */

  }, {
    key: 'hasEmail',
    value: function hasEmail() {
      return _metal.core.isDefAndNotNull(this.email);
    }

    /**
    * Checks if the id is set.
    * @return {boolean}
    */

  }, {
    key: 'hasId',
    value: function hasId() {
      return _metal.core.isDefAndNotNull(this.id);
    }

    /**
    * Checks if the name is set.
    * @return {boolean}
    */

  }, {
    key: 'hasName',
    value: function hasName() {
      return _metal.core.isDefAndNotNull(this.name);
    }

    /**
    * Checks if the password is set.
    * @return {boolean}
    */

  }, {
    key: 'hasPassword',
    value: function hasPassword() {
      return _metal.core.isDefAndNotNull(this.password);
    }

    /**
    * Checks if the photo url is set.
    * @return {boolean}
    */

  }, {
    key: 'hasPhotoUrl',
    value: function hasPhotoUrl() {
      return _metal.core.isDefAndNotNull(this.photoUrl);
    }

    /**
    * Checks if the user has scopes.
    * @param {string|array.<string>} scopes Scope or array of scopes to check.
    * @return {boolean}
    */

  }, {
    key: 'hasSupportedScopes',
    value: function hasSupportedScopes(scopes) {
      var _this = this;

      if (Array.isArray(scopes)) {
        return scopes.every(function (val) {
          return _this.supportedScopes.indexOf(val) > -1;
        });
      } else {
        return this.supportedScopes.indexOf(scopes) > -1;
      }
    }

    /**
    * Checks if the token is set.
    * @return {boolean}
    */

  }, {
    key: 'hasToken',
    value: function hasToken() {
      return _metal.core.isDefAndNotNull(this.token);
    }

    /**
    * Sets created at.
    * @param {string} createdAt
    */

  }, {
    key: 'setCreatedAt',
    value: function setCreatedAt(createdAt) {
      this.createdAt = createdAt;
    }

    /**
    * Sets the email.
    * @param {string} email
    */

  }, {
    key: 'setEmail',
    value: function setEmail(email) {
      this.email = email;
    }

    /**
    * Sets the headers.
    * @param {!MultiMap|Object} headers The headers to be set
    */

  }, {
    key: 'setHeaders',
    value: function setHeaders(headers) {
      var _this2 = this;

      if (!(headers instanceof _metalStructs.MultiMap)) {
        headers = _metalStructs.MultiMap.fromObject(headers);
      }

      headers.names().forEach(function (name) {
        var values = headers.getAll(name);

        values.forEach(function (value) {
          _this2.headers_.set(name, value);
        });
      });
    }

    /**
    * Sets the id.
    * @param {string} id
    */

  }, {
    key: 'setId',
    value: function setId(id) {
      this.id = id;
    }

    /**
    * Sets the name.
    * @param {string} name
    */

  }, {
    key: 'setName',
    value: function setName(name) {
      this.name = name;
    }

    /**
    * Sets the password.
    * @param {string} password
    */

  }, {
    key: 'setPassword',
    value: function setPassword(password) {
      this.password = password;
    }

    /**
    * Sets the photo url.
    * @param {string} photoUrl
    */

  }, {
    key: 'setPhotoUrl',
    value: function setPhotoUrl(photoUrl) {
      this.photoUrl = photoUrl;
    }

    /**
    * Sets supported scopes.
    * @param {array.<string>} supportedScopes
    */

  }, {
    key: 'setSupportedScopes',
    value: function setSupportedScopes(supportedScopes) {
      this.supportedScopes = supportedScopes;
    }

    /**
    * Sets the token.
    * @param {string} token
    */

  }, {
    key: 'setToken',
    value: function setToken(token) {
      this.token = token;
    }

    /**
    * Sets the WeDeploy client.
    * @param {Object} wedeployClient
    */

  }, {
    key: 'setWedeployClient',
    value: function setWedeployClient(wedeployClient) {
      this.wedeployClient = wedeployClient;
    }

    /**
    * Updates the user.
    * @param {!Object} data
    * @return {CompletableFuture}
    */

  }, {
    key: 'updateUser',
    value: function updateUser(data) {
      (0, _assertions.assertObject)(data, 'User data must be specified as object');
      return this.buildUrl_().path('/users', this.getId().toString()).auth(this).patch(data).then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
    * Deletes the current user.
    * @return {CompletableFuture}
    */

  }, {
    key: 'deleteUser',
    value: function deleteUser() {
      (0, _assertions.assertDefAndNotNull)(this.getId(), 'Cannot delete user without id');
      return this.buildUrl_().path('/users', this.getId().toString()).auth(this).delete().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
    * Builds URL by joining the headers.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'buildUrl_',
    value: function buildUrl_() {
      return this.wedeployClient.url(this.wedeployClient.authUrl_).headers(this.headers_);
    }
  }], [{
    key: 'create',
    value: function create(authOrTokenOrEmail, opt_password) {
      if (authOrTokenOrEmail instanceof Auth) {
        return authOrTokenOrEmail;
      } else if ((0, _metal.isString)(authOrTokenOrEmail) && (0, _metal.isString)(opt_password)) {
        return new Auth(authOrTokenOrEmail, opt_password);
      } else if ((0, _metal.isString)(authOrTokenOrEmail) && !(0, _metal.isDef)(opt_password)) {
        return new Auth(authOrTokenOrEmail);
      } else if ((0, _metal.isDefAndNotNull)(authOrTokenOrEmail) && (0, _metal.isObject)(authOrTokenOrEmail)) {
        return Auth.createFromData(authOrTokenOrEmail);
      } else {
        return new Auth();
      }
    }

    /**
    * Makes user Auth from data object.
    * @param {Object} data
    * @return {Auth}
    * @protected
    */

  }, {
    key: 'createFromData',
    value: function createFromData(data) {
      var auth = new Auth();
      if ((0, _metal.isObject)(data)) {
        var properties = {};
        Object.keys(data).forEach(function (key) {
          properties[key] = {
            enumerable: true,
            value: data[key],
            writable: true
          };
        });
        Object.defineProperties(auth, properties);
      }
      auth.setWedeployClient(this.wedeployClient);
      return auth;
    }
  }]);

  return Auth;
}();

exports.default = Auth;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

var _metal = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for encapsulate provider information.
 */
var AuthProvider = function () {
  /**
  * Constructs an {@link AuthProvider} instance.
  * @constructor
  */
  function AuthProvider() {
    _classCallCheck(this, AuthProvider);

    this.provider = null;
    this.providerScope = null;
    this.redirectUri = null;
    this.scope = null;
  }

  /**
  * Checks if provider is defined and not null.
  * @return {boolean}
  */


  _createClass(AuthProvider, [{
    key: 'hasProvider',
    value: function hasProvider() {
      return _metal.core.isDefAndNotNull(this.provider);
    }

    /**
    * Checks if scope is defined and not null.
    * @return {boolean}
    */

  }, {
    key: 'hasProviderScope',
    value: function hasProviderScope() {
      return _metal.core.isDefAndNotNull(this.providerScope);
    }

    /**
    * Checks if redirect uri is defined and not null.
    * @return {boolean}
    */

  }, {
    key: 'hasRedirectUri',
    value: function hasRedirectUri() {
      return _metal.core.isDefAndNotNull(this.redirectUri);
    }

    /**
    * Checks if scope is defined and not null.
    * @return {boolean}
    */

  }, {
    key: 'hasScope',
    value: function hasScope() {
      return _metal.core.isDefAndNotNull(this.scope);
    }

    /**
    * Makes authorization url. An optional authorization URL might be provided.
    * @param {string} opt_authUrl Optional authorization URL.
    * @return {string} Normalized authorization URL.
    */

  }, {
    key: 'makeAuthorizationUrl',
    value: function makeAuthorizationUrl(opt_authUrl) {
      var uri = new _metalUri2.default(opt_authUrl);

      uri.setPathname('/oauth/authorize');

      if (this.hasProvider()) {
        uri.setParameterValue('provider', this.getProvider());
      }
      if (this.hasProviderScope()) {
        uri.setParameterValue('provider_scope', this.getProviderScope());
      }
      if (this.hasRedirectUri()) {
        uri.setParameterValue('redirect_uri', this.getRedirectUri());
      }
      if (this.hasScope()) {
        uri.setParameterValue('scope', this.getScope());
      }

      return uri.toString();
    }

    /**
    * Gets provider name.
    * @return {string} Provider name.
    */

  }, {
    key: 'getProvider',
    value: function getProvider() {
      return this.provider;
    }

    /**
    * Gets provider scope.
    * @return {string} String with scopes.
    */

  }, {
    key: 'getProviderScope',
    value: function getProviderScope() {
      return this.providerScope;
    }

    /**
    * Gets redirect uri.
    * @return {string}.
    */

  }, {
    key: 'getRedirectUri',
    value: function getRedirectUri() {
      return this.redirectUri;
    }

    /**
    * Gets scope.
    * @return {string} String with scopes.
    */

  }, {
    key: 'getScope',
    value: function getScope() {
      return this.scope;
    }

    /**
    * Sets provider scope.
    * @param {string=} providerScope Scope string. Separate by space for multiple
    *   scopes, e.g. "scope1 scope2".
    */

  }, {
    key: 'setProviderScope',
    value: function setProviderScope(providerScope) {
      assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
      this.providerScope = providerScope;
    }

    /**
    * Sets redirect uri.
    * @param {string} redirectUri The redirect URI to be set to the current
    *   instance.
    */

  }, {
    key: 'setRedirectUri',
    value: function setRedirectUri(redirectUri) {
      assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
      this.redirectUri = redirectUri;
    }

    /**
    * Sets scope.
    * @param {string=} scope Scope string. Separate by space for multiple
    *   scopes, e.g. "scope1 scope2".
    */

  }, {
    key: 'setScope',
    value: function setScope(scope) {
      assertStringIfDefAndNotNull(scope, 'Scope must be a string');
      this.scope = scope;
    }
  }]);

  return AuthProvider;
}();

/**
 * Throws an exception if the provided value is defined and not null, but not a
 *   string.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */


function assertStringIfDefAndNotNull(value, errorMessage) {
  if (_metal.core.isDefAndNotNull(value) && !_metal.core.isString(value)) {
    throw new Error(errorMessage);
  }
}

exports.default = AuthProvider;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StorageMechanism = function () {
	function StorageMechanism() {
		_classCallCheck(this, StorageMechanism);
	}

	_createClass(StorageMechanism, [{
		key: 'clear',

		/**
   * Clear all items from the data storage.
   */
		value: function clear() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Checks if this mechanism is supported in the current environment.
   * Subclasses should override this when necessary.
   */

	}, {
		key: 'keys',


		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */
		value: function keys() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			throw Error('Unimplemented abstract method');
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return true;
		}
	}]);

	return StorageMechanism;
}();

exports.default = StorageMechanism;

/* jshint ignore:end */

/***/ }),
/* 13 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Embodied6 = __webpack_require__(1);

var _Embodied7 = _interopRequireDefault(_Embodied6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for building different types of geometric
 * shapes.
 */
var Geo = function () {
  function Geo() {
    _classCallCheck(this, Geo);
  }

  _createClass(Geo, null, [{
    key: 'boundingBox',

    /**
    * Creates a new {@link BoundingBox} instance.
    * @param {*} upperLeft The upper left point.
    * @param {*} lowerRight The lower right point.
    * @return {!BoundingBox}
    * @static
    */
    value: function boundingBox(upperLeft, lowerRight) {
      return new Geo.BoundingBox(upperLeft, lowerRight);
    }

    /**
    * Creates a new {@link Circle} instance.
    * @param {*} center The circle's center coordinate.
    * @param {string} radius The circle's radius.
    * @return {!Circle}
    * @static
    */

  }, {
    key: 'circle',
    value: function circle(center, radius) {
      return new Geo.Circle(center, radius);
    }

    /**
    * Creates a new {@link Line} instance.
    * @param {...*} points This line's points.
    * @return {!Line}
    * @static
    */

  }, {
    key: 'line',
    value: function line() {
      for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
        points[_key] = arguments[_key];
      }

      return new (Function.prototype.bind.apply(Geo.Line, [null].concat(points)))();
    }

    /**
    * Creates a new {@link Point} instance.
    * @param {number} lat The latitude coordinate
    * @param {number} lon The longitude coordinate
    * @return {!Point}
    * @static
    */

  }, {
    key: 'point',
    value: function point(lat, lon) {
      return new Geo.Point(lat, lon);
    }

    /**
    * Creates a new {@link Polygon} instance.
    * @param {...*} points This polygon's points.
    * @return {!Polygon}
    * @static
    */

  }, {
    key: 'polygon',
    value: function polygon() {
      for (var _len2 = arguments.length, points = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        points[_key2] = arguments[_key2];
      }

      return new (Function.prototype.bind.apply(Geo.Polygon, [null].concat(points)))();
    }
  }]);

  return Geo;
}();

/**
 * Class that represents a point coordinate.
 * @extends {Embodied}
 */


var Point = function (_Embodied) {
  _inherits(Point, _Embodied);

  /**
  * Constructs a {@link Point} instance.
  * @param {number} lat The latitude coordinate
  * @param {number} lon The longitude coordinate
  * @constructor
  */
  function Point(lat, lon) {
    _classCallCheck(this, Point);

    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));

    _this.body_ = [lat, lon];
    return _this;
  }

  return Point;
}(_Embodied7.default);

Geo.Point = Point;

/**
 * Class that represents a line.
 * @extends {Embodied}
 */

var Line = function (_Embodied2) {
  _inherits(Line, _Embodied2);

  /**
  * Constructs a {@link Line} instance.
  * @param {...*} points This line's points.
  * @constructor
  */
  function Line() {
    _classCallCheck(this, Line);

    var _this2 = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

    for (var _len3 = arguments.length, points = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      points[_key3] = arguments[_key3];
    }

    _this2.body_ = {
      type: 'linestring',
      coordinates: points.map(function (point) {
        return _Embodied7.default.toBody(point);
      })
    };
    return _this2;
  }

  return Line;
}(_Embodied7.default);

Geo.Line = Line;

/**
 * Class that represents a bounding box.
 * @extends {Embodied}
 */

var BoundingBox = function (_Embodied3) {
  _inherits(BoundingBox, _Embodied3);

  /**
  * Constructs a {@link BoundingBox} instance.
  * @param {*} upperLeft The upper left point.
  * @param {*} lowerRight The lower right point.
  * @constructor
  */
  function BoundingBox(upperLeft, lowerRight) {
    _classCallCheck(this, BoundingBox);

    var _this3 = _possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this));

    _this3.body_ = {
      type: 'envelope',
      coordinates: [_Embodied7.default.toBody(upperLeft), _Embodied7.default.toBody(lowerRight)]
    };
    return _this3;
  }

  /**
  * Gets this bounding box's points.
  * @return {!Array}
  */


  _createClass(BoundingBox, [{
    key: 'getPoints',
    value: function getPoints() {
      return this.body_.coordinates;
    }
  }]);

  return BoundingBox;
}(_Embodied7.default);

Geo.BoundingBox = BoundingBox;

/**
 * Class that represents a circle.
 * @extends {Embodied}
 */

var Circle = function (_Embodied4) {
  _inherits(Circle, _Embodied4);

  /**
  * Constructs a {@link Circle} instance.
  * @param {*} center The circle's center coordinate.
  * @param {string} radius The circle's radius.
  * @constructor
  */
  function Circle(center, radius) {
    _classCallCheck(this, Circle);

    var _this4 = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));

    _this4.body_ = {
      type: 'circle',
      coordinates: _Embodied7.default.toBody(center),
      radius: radius
    };
    return _this4;
  }

  /**
  * Gets this circle's center coordinate.
  * @return {*}
  */


  _createClass(Circle, [{
    key: 'getCenter',
    value: function getCenter() {
      return this.body_.coordinates;
    }

    /**
    * Gets this circle's radius.
    * @return {string}
    */

  }, {
    key: 'getRadius',
    value: function getRadius() {
      return this.body_.radius;
    }
  }]);

  return Circle;
}(_Embodied7.default);

Geo.Circle = Circle;

/**
 * Class that represents a polygon.
 * @extends {Embodied}
 */

var Polygon = function (_Embodied5) {
  _inherits(Polygon, _Embodied5);

  /**
  * Constructs a {@link Polygon} instance.
  * @param {...*} points This polygon's points.
  * @constructor
  */
  function Polygon() {
    _classCallCheck(this, Polygon);

    var _this5 = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));

    _this5.body_ = {
      type: 'polygon',
      coordinates: []
    };
    _this5.addCoordinates_.apply(_this5, arguments);
    return _this5;
  }

  /**
  * Adds the given points as coordinates for this polygon.
  * @param {...*} points
  * @protected
  */


  _createClass(Polygon, [{
    key: 'addCoordinates_',
    value: function addCoordinates_() {
      for (var _len4 = arguments.length, points = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        points[_key4] = arguments[_key4];
      }

      this.body_.coordinates.push(points.map(function (point) {
        return _Embodied7.default.toBody(point);
      }));
    }

    /**
    * Adds the given points as a hole inside this polygon.
    * @param {...*} points
    * @return {Polygon} Returns the {@link Polygon} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'hole',
    value: function hole() {
      this.addCoordinates_.apply(this, arguments);
      return this;
    }
  }]);

  return Polygon;
}(_Embodied7.default);

Geo.Polygon = Polygon;

exports.default = Geo;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metalStructs = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents a client message (e.g. a request or a response).
 */
var ClientMessage = function () {
  /**
  * Constructs an {@link ClientMessage} instance.
  * @constructor
  */
  function ClientMessage() {
    _classCallCheck(this, ClientMessage);

    this.headers_ = new _metalStructs.MultiMap();
  }

  /**
  * Fluent getter and setter for request body.
  * @param {*=} opt_body Request body to be set. If none is given,
  *   the current value of the body will be returned.
  * @return {*} Returns request body if no body value was given. Otherwise
  *   returns the {@link ClientMessage} object itself, so calls can be chained.
  * @chainable Chainable when used as setter.
  */


  _createClass(ClientMessage, [{
    key: 'body',
    value: function body(opt_body) {
      if (_metal.core.isDef(opt_body)) {
        this.body_ = opt_body;
        return this;
      }
      return this.body_;
    }

    /**
    * Adds a header. If a header with the same name already exists, it will not
    * be overwritten, but the new value will be stored as well. The order is
    * preserved.
    * @param {string} name
    * @param {string} value
    * @return {!ClientMessage} Returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    * @chainable
    */

  }, {
    key: 'header',
    value: function header(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.headers_.set(name, value);
      return this;
    }

    /**
    * Fluent getter and setter for request headers.
    * @param {MultiMap|Object=} opt_headers Request headers list to
    *   be set. If none is given the current value of the headers will
    *   be returned.
    * @return {!MultiMap|ClientMessage} Returns map of request headers
    *   if no new value was given. Otherwise returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'headers',
    value: function headers(opt_headers) {
      if (_metal.core.isDef(opt_headers)) {
        if (opt_headers instanceof _metalStructs.MultiMap) {
          this.headers_ = opt_headers;
        } else {
          this.headers_.values = opt_headers;
        }
        return opt_headers;
      }
      return this.headers_;
    }

    /**
    * Removes the body.
    */

  }, {
    key: 'removeBody',
    value: function removeBody() {
      this.body_ = undefined;
    }
  }]);

  return ClientMessage;
}();

exports.default = ClientMessage;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(50);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _metal = __webpack_require__(0);

var _Auth = __webpack_require__(10);

var _Auth2 = _interopRequireDefault(_Auth);

var _AuthApiHelper = __webpack_require__(25);

var _AuthApiHelper2 = _interopRequireDefault(_AuthApiHelper);

var _DataApiHelper = __webpack_require__(30);

var _DataApiHelper2 = _interopRequireDefault(_DataApiHelper);

var _EmailApiHelper = __webpack_require__(31);

var _EmailApiHelper2 = _interopRequireDefault(_EmailApiHelper);

var _Base = __webpack_require__(32);

var _Base2 = _interopRequireDefault(_Base);

var _Embodied = __webpack_require__(1);

var _Embodied2 = _interopRequireDefault(_Embodied);

var _Query = __webpack_require__(7);

var _Query2 = _interopRequireDefault(_Query);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _TransportFactory = __webpack_require__(24);

var _TransportFactory2 = _interopRequireDefault(_TransportFactory);

var _ClientRequest = __webpack_require__(21);

var _ClientRequest2 = _interopRequireDefault(_ClientRequest);

var _metalStructs = __webpack_require__(2);

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

var _assertions = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var io = void 0;
var FormDataImpl = void 0;

// Optimistic initialization of `io` reference from global `globals.window.io`.
if (typeof _globals2.default.window !== 'undefined') {
  io = _globals2.default.window.io;
}

// Optimistic initialization of `FormData` reference from global
// `globals.window.FormData`.
if (typeof _globals2.default.window !== 'undefined') {
  FormDataImpl = _globals2.default.window.FormData;
}

/**
 * The main class for making api requests. Sending requests returns a promise
 * that is resolved when the response arrives. Usage example:
 * ```javascript
 * WeDeploy
 *   .url('/data/tasks')
 *   .post({desc: 'Buy milk'})
 *   .then(function(response) {
 *     // Handle response here.
 *     console.log(response.body())
 *   });
 * ```
 */

var WeDeploy = function () {
  /**
  * WeDeploy constructor function.
  * @param {string} url The base url.
  * @param {...string} paths Any amount of paths to be appended to the base
  * url.
  * @constructor
  */
  function WeDeploy(url) {
    for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      paths[_key - 1] = arguments[_key];
    }

    _classCallCheck(this, WeDeploy);

    if (arguments.length === 0) {
      throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
    }

    this.auth_ = null;
    this.data_ = null;
    this.body_ = null;
    this.url_ = _metalUri2.default.joinPaths.apply(_metalUri2.default, [url || ''].concat(paths));
    this.headers_ = new _metalStructs.MultiMap();
    this.params_ = new _metalStructs.MultiMap();
    this.withCredentials_ = true;

    this.header('Content-Type', 'application/json');
    this.header('X-Requested-With', 'XMLHttpRequest');
  }

  /**
  * Static factory for creating WeDeploy data for the given url.
  * @param {string=} opt_dataUrl The url that points to the data services.
  * @return {data} WeDeploy data instance.
  */


  _createClass(WeDeploy, [{
    key: 'auth',


    /**
    * Adds authorization information to this request.
    * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
    * an authorization token, or the email.
    * @param {string=} opt_password If a email is given as the first param,
    * this should be the password.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */
    value: function auth(authOrTokenOrEmail, opt_password) {
      this.auth_ = _Auth2.default.create(authOrTokenOrEmail, opt_password);
      this.auth_.setWedeployClient(WeDeploy);
      return this;
    }

    /**
    * Static factory for creating WeDeploy auth for the given url.
    * @param {string=} opt_authUrl The url that points to the auth service.
    * @return {!Auth} Returns an {@link Auth} instance.
    */

  }, {
    key: 'body',


    /**
    * Sets the body that will be sent with this request.
    * @param {*} body
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */
    value: function body(_body) {
      this.body_ = _body;
      return this;
    }

    /**
    * Converts the given body object to query params.
    * @param {!ClientRequest} clientRequest Client request.
    * @param {*} body
    * @protected
    */

  }, {
    key: 'convertBodyToParams_',
    value: function convertBodyToParams_(clientRequest, body) {
      if (_metal.core.isString(body)) {
        body = {
          body: body
        };
      } else if (body instanceof _Embodied2.default) {
        body = body.body();
      }
      Object.keys(body || {}).forEach(function (name) {
        return clientRequest.param(name, body[name]);
      });
    }

    /**
    * Creates client request and encode.
    * @param {string} method
    * @param {*} body
    * @return {!ClientRequest} Client request.
    * @protected
    */

  }, {
    key: 'createClientRequest_',
    value: function createClientRequest_(method, body) {
      var clientRequest = new _ClientRequest2.default();

      clientRequest.body(body || this.body_);

      if (!_metal.core.isDefAndNotNull(clientRequest.body())) {
        if (this.formData_) {
          clientRequest.body(this.formData_);
        }
      }

      clientRequest.method(method);
      clientRequest.headers(this.headers());
      clientRequest.params(this.params());
      clientRequest.url(this.url());
      clientRequest.withCredentials(this.withCredentials_);

      this.encode(clientRequest);

      return clientRequest;
    }

    /**
    * Decodes clientResponse body, parsing the body for example.
    * @param {!ClientResponse} clientResponse The response object to be
    * decoded.
    * @return {!ClientResponse} The decoded response.
    */

  }, {
    key: 'decode',
    value: function decode(clientResponse) {
      if (WeDeploy.isContentTypeJson(clientResponse)) {
        try {
          clientResponse.body(JSON.parse(clientResponse.body()));
        } catch (err) {}
      }
      return clientResponse;
    }

    /**
    * Sends message with the DELETE http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'delete',
    value: function _delete(opt_body) {
      return this.sendAsync('DELETE', opt_body);
    }

    /**
    * Encodes the given {@link ClientRequest}, converting its body to an
    * appropriate format for example.
    * @param {!ClientRequest} clientRequest The request object to encode.
    * @return {!ClientRequest} The encoded request.
    */

  }, {
    key: 'encode',
    value: function encode(clientRequest) {
      var body = clientRequest.body();

      if (_metal.core.isElement(body)) {
        body = new FormDataImpl(body);
        clientRequest.body(body);
      }

      body = this.maybeWrapWithQuery_(body);
      if (clientRequest.method() === 'GET') {
        this.convertBodyToParams_(clientRequest, body);
        clientRequest.removeBody();
        body = null;
      }

      if (typeof FormDataImpl !== 'undefined' && body instanceof FormDataImpl) {
        clientRequest.headers().remove('content-type');
      } else if (body instanceof _Embodied2.default) {
        clientRequest.body(body.toString());
      } else if (WeDeploy.isContentTypeJson(clientRequest)) {
        var _body2 = clientRequest.body();
        if (_metal.core.isDefAndNotNull(_body2)) {
          _body2 = JSON.stringify(_body2);
          clientRequest.body(_body2);
        }
      }

      this.encodeParams_(clientRequest);
      this.resolveAuthentication_(clientRequest);

      return clientRequest;
    }

    /**
    * Encodes the params for the given request, according to their types.
    * @param {!ClientRequest} clientRequest
    * @protected
    */

  }, {
    key: 'encodeParams_',
    value: function encodeParams_(clientRequest) {
      var params = clientRequest.params();
      params.names().forEach(function (name) {
        var values = params.getAll(name);
        values.forEach(function (value, index) {
          if (value instanceof _Embodied2.default) {
            value = value.toString();
          } else if (_metal.core.isObject(value) || value instanceof Array) {
            value = JSON.stringify(value);
          }
          values[index] = value;
        });
      });
    }

    /**
    * Adds a key/value pair to be sent via the body in a `multipart/form-data`
    * format.
    * If the body is set by other means (for example, through the `body` method),
    * this will be ignored.
    * @param {string} name
    * @param {*} value
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'form',
    value: function form(name, value) {
      if (typeof FormDataImpl === 'undefined') {
        throw new Error('form() is only available when FormData API is available.');
      }

      if (!this.formData_) {
        this.formData_ = new FormDataImpl();
      }
      this.formData_.append(name, value);
      return this;
    }

    /**
    * Sends message with the GET http verb.
    * @param {*=} opt_params Params to be added to the request url.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'get',
    value: function get(opt_params) {
      return this.sendAsync('GET', opt_params);
    }

    /**
    * Adds a header. If the header with the same name already exists, it will
    * not be overwritten, but new value will be stored. The order is preserved.
    * @param {string} name Header key.
    * @param {*} value Header value.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'header',
    value: function header(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.headers_.set(name, value);
      return this;
    }

    /**
    * Gets or sets the headers. If headers are passed to the function as
     * parameter, they will be set as internal headers, overwriting the existing
     * ones. Otherwise, the currently set headers will be returned.
     * @param {MultiMap|Object=} opt_headers Headers to be set
    * @return {WeDeploy|MultiMap} If headers were passed to te function,
     *   the returned result will be the {@link WeDeploy} object itself, so calls
     *   can be chained. If headers were not passed to the function, the returned
     *   result will be the current headers.
     * @chainable Chainable when used as setter.
     */

  }, {
    key: 'headers',
    value: function headers(opt_headers) {
      var _this = this;

      if (_metal.core.isDefAndNotNull(opt_headers)) {
        if (!(opt_headers instanceof _metalStructs.MultiMap)) {
          opt_headers = _metalStructs.MultiMap.fromObject(opt_headers);
        }

        opt_headers.names().forEach(function (name) {
          var values = opt_headers.getAll(name);

          values.forEach(function (value) {
            _this.headers_.set(name, value);
          });
        });

        return this;
      } else {
        return this.headers_;
      }
    }

    /**
    * Check if clientMessage content type is application/json.
    * @param {ClientMessage} clientMessage Client message.
    * @return {boolean}
    */

  }, {
    key: 'maybeWrapWithQuery_',


    /**
    * Wraps the given `Embodied` instance with a {@link Query} instance if
    * needed.
    * @param {Embodied} embodied
    * @return {Embodied}
    * @protected
    */
    value: function maybeWrapWithQuery_(embodied) {
      if (embodied instanceof _Filter2.default) {
        embodied = _Query2.default.filter(embodied);
      }
      return embodied;
    }

    /**
    * Adds a query. If the query with the same name already exists, it will not
    * be overwritten, but new value will be stored. The order is preserved.
    * @param {string} name Param key.
    * @param {*} value Param value.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'param',
    value: function param(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.params_.set(name, value);
      return this;
    }

    /**
    * Gets the query strings map.
    * @return {!MultiMap}
    */

  }, {
    key: 'params',
    value: function params() {
      return this.params_;
    }

    /**
    * Sends message with the PATCH http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'patch',
    value: function patch(opt_body) {
      return this.sendAsync('PATCH', opt_body);
    }

    /**
    * Creates a new {@link WeDeploy} instance for handling the url resulting in
    * the union of the current url with the given paths.
    * @param {...string} paths Any number of paths.
    * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given
    *   paths.
    */

  }, {
    key: 'path',
    value: function path() {
      for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        paths[_key2] = arguments[_key2];
      }

      var wedeployClient = new (Function.prototype.bind.apply(WeDeploy, [null].concat([this.url()], paths)))();

      if (_metal.core.isDefAndNotNull(this.auth_)) {
        wedeployClient.auth(this.auth_);
      }

      wedeployClient.headers(this.headers_);

      return wedeployClient.use(this.customTransport_);
    }

    /**
    * Sends message with the POST http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'post',
    value: function post(opt_body) {
      return this.sendAsync('POST', opt_body);
    }

    /**
    * Sends message with the PUT http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'put',
    value: function put(opt_body) {
      return this.sendAsync('PUT', opt_body);
    }

    /**
    * Adds the authentication information to the request.
    * @param {!ClientRequest} clientRequest
    * @protected
    */

  }, {
    key: 'resolveAuthentication_',
    value: function resolveAuthentication_(clientRequest) {
      if (!this.auth_) {
        return;
      }
      if (this.auth_.hasToken()) {
        clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
      } else if (this.auth_.hasEmail() && this.auth_.hasPassword()) {
        var credentials = this.auth_.email + ':' + this.auth_.password;
        clientRequest.header('Authorization', 'Basic ' + _Base2.default.encodeString(credentials));
      }
    }

    /**
    * Uses transport to send request with given method name and body
    * asynchronously.
    * @param {string} method The HTTP method to be used when sending data.
    * @param {string} body Content to be sent as the request's body.
    * @return {!CancellablePromise} Deferred request.
    */

  }, {
    key: 'sendAsync',
    value: function sendAsync(method, body) {
      var transport = this.customTransport_ || _TransportFactory2.default.instance().getDefault();

      var clientRequest = this.createClientRequest_(method, body);

      return transport.send(clientRequest).then(this.decode);
    }

    /**
    * Sets the socket transport
    * @param {Object} socket implementation object.
    */

  }, {
    key: 'url',


    /**
    * Returns the URL used by this client.
    * @return {!string}
    */
    value: function url() {
      return this.url_;
    }

    /**
    * Specifies {@link Transport} implementation.
    * @param {!Transport} transport The transport implementation that should be
    * used.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    */

  }, {
    key: 'use',
    value: function use(transport) {
      this.customTransport_ = transport;
      return this;
    }

    /**
    * Creates new socket.io instance. The parameters passed to socket.io
    * constructor will be provided:
    *
    * ```javascript
    * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
    * // Equals:
    * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
    * ```
    *
    * @param {Object=} opt_params Params to be sent with the Socket IO request.
    * @param {Object=} opt_options Object with Socket IO options.
    * @return {!io} Socket IO reference. Server events can be listened on it.
    */

  }, {
    key: 'watch',
    value: function watch(opt_params, opt_options) {
      if (typeof io === 'undefined') {
        throw new Error('Socket.io client not loaded');
      }

      var clientRequest = this.createClientRequest_('GET', opt_params);
      var uri = new _metalUri2.default(clientRequest.url());
      uri.addParametersFromMultiMap(clientRequest.params());

      var jsonp = typeof navigator === 'undefined' || navigator.product !== 'ReactNative';

      opt_options = opt_options || {
        forceNew: true,
        jsonp: jsonp
      };
      opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
      opt_options.path = opt_options.path || uri.getPathname();

      return io(uri.getProtocol() + '//' + uri.getHost(), opt_options);
    }

    /**
    * Assigns the passed value to the internal with credentials option.
    * @param {boolean} withCredentials
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    */

  }, {
    key: 'withCredentials',
    value: function withCredentials(_withCredentials) {
      this.withCredentials_ = !!_withCredentials;
      return this;
    }
  }], [{
    key: 'data',
    value: function data(opt_dataUrl) {
      (0, _assertions.assertUriWithNoPath)(opt_dataUrl, 'The data url should not have a path');

      if (_metal.core.isString(opt_dataUrl)) {
        WeDeploy.dataUrl_ = opt_dataUrl;
      }
      if (!WeDeploy.data_) {
        WeDeploy.data_ = new _DataApiHelper2.default(WeDeploy);
      }
      WeDeploy.data_.auth(WeDeploy.auth().currentUser);
      return WeDeploy.data_;
    }

    /**
    * Static factory for creating WeDeploy email for the given url.
    * @param {string=} opt_emailUrl The url that points to the email services.
    * @return {data} WeDeploy email instance.
    */

  }, {
    key: 'email',
    value: function email(opt_emailUrl) {
      (0, _assertions.assertUriWithNoPath)(opt_emailUrl, 'The email url should not have a path');

      if (_metal.core.isString(opt_emailUrl)) {
        WeDeploy.emailUrl_ = opt_emailUrl;
      }
      if (!WeDeploy.email_) {
        WeDeploy.email_ = new _EmailApiHelper2.default(WeDeploy);
      }
      WeDeploy.email_.auth(WeDeploy.auth().currentUser);
      return WeDeploy.email_;
    }
  }, {
    key: 'auth',
    value: function auth(opt_authUrl) {
      if (_metal.core.isString(opt_authUrl)) {
        WeDeploy.authUrl_ = opt_authUrl;
      }
      if (!WeDeploy.auth_) {
        WeDeploy.auth_ = new _AuthApiHelper2.default(WeDeploy);
      }
      return WeDeploy.auth_;
    }
  }, {
    key: 'isContentTypeJson',
    value: function isContentTypeJson(clientMessage) {
      var contentType = clientMessage.headers().get('content-type') || '';
      return contentType.indexOf('application/json') === 0;
    }
  }, {
    key: 'socket',
    value: function socket(_socket) {
      io = _socket;
    }

    /**
    * Sets the FormData
    * @param {Object} formData implementation object.
    */

  }, {
    key: 'formData',
    value: function formData(_formData) {
      FormDataImpl = _formData;
    }

    /**
    * Static factory for creating WeDeploy client for the given url.
    * @param {string} url The url that the client should use for sending
    *   requests.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    */

  }, {
    key: 'url',
    value: function url(_url) {
      return new WeDeploy(_url).use(this.customTransport_);
    }
  }]);

  return WeDeploy;
}();

WeDeploy.auth_ = null;
WeDeploy.data_ = null;
WeDeploy.email_ = null;
WeDeploy.authUrl_ = '';
WeDeploy.dataUrl_ = '';
WeDeploy.emailUrl_ = '';

exports.default = WeDeploy;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Embodied = __webpack_require__(1);

var _Embodied2 = _interopRequireDefault(_Embodied);

var _Range = __webpack_require__(8);

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class that represents a search aggregation.
 */
var Aggregation = function () {
		/**
  * Constructs an {@link Aggregation} instance.
  * @param {string} field The aggregation field.
  * @param {string} operator The aggregation operator.
  * @param {*=} opt_value The aggregation value.
  * @constructor
  */
		function Aggregation(field, operator, opt_value) {
				_classCallCheck(this, Aggregation);

				this.field_ = field;
				this.operator_ = operator;
				this.value_ = opt_value;
		}

		/**
  * Creates an {@link Aggregation} instance with the "avg" operator.
  * @param {string} field The aggregation field.
  * @return {!Aggregation}
  * @static
  */


		_createClass(Aggregation, [{
				key: 'getField',


				/**
    * Gets this aggregation's field.
    * @return {string}
    */
				value: function getField() {
						return this.field_;
				}

				/**
    * Gets this aggregation's operator.
    * @return {string}
    */

		}, {
				key: 'getOperator',
				value: function getOperator() {
						return this.operator_;
				}

				/**
    * Gets this aggregation's value.
    * @return {*}
    */

		}, {
				key: 'getValue',
				value: function getValue() {
						return this.value_;
				}

				/**
    * Creates an {@link Aggregation} instance with the "histogram" operator.
    * @param {string} field The aggregation field.
    * @param {number} interval The histogram's interval.
    * @return {!Aggregation}
    * @static
    */

		}], [{
				key: 'avg',
				value: function avg(field) {
						return Aggregation.field(field, 'avg');
				}

				/**
    * Creates an {@link Aggregation} instance with the "count" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'count',
				value: function count(field) {
						return Aggregation.field(field, 'count');
				}

				/**
    * Creates an {@link DistanceAggregation} instance with the "geoDistance"
    * operator.
    * @param {string} field The aggregation field.
    * @param {*} location The aggregation location.
    * @param {...!Range} ranges The aggregation ranges.
    * @return {!DistanceAggregation}
    * @static
    */

		}, {
				key: 'distance',
				value: function distance(field, location) {
						for (var _len = arguments.length, ranges = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
								ranges[_key - 2] = arguments[_key];
						}

						return new (Function.prototype.bind.apply(Aggregation.DistanceAggregation, [null].concat([field, location], ranges)))();
				}

				/**
    * Creates an {@link Aggregation} instance with the "extendedStats" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'extendedStats',
				value: function extendedStats(field) {
						return Aggregation.field(field, 'extendedStats');
				}
		}, {
				key: 'histogram',
				value: function histogram(field, interval) {
						return new Aggregation(field, 'histogram', interval);
				}

				/**
    * Creates an {@link Aggregation} instance with the "max" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'max',
				value: function max(field) {
						return Aggregation.field(field, 'max');
				}

				/**
    * Creates an {@link Aggregation} instance with the "min" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'min',
				value: function min(field) {
						return Aggregation.field(field, 'min');
				}

				/**
    * Creates an {@link Aggregation} instance with the "missing" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'missing',
				value: function missing(field) {
						return Aggregation.field(field, 'missing');
				}

				/**
    * Creates a new {@link Aggregation} instance.
    * @param {string} field The aggregation field.
    * @param {string} operator The aggregation operator.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'field',
				value: function field(_field, operator) {
						return new Aggregation(_field, operator);
				}

				/**
    * Creates an {@link RangeAggregation} instance with the "range" operator.
    * @param {string} field The aggregation field.
    * @param {...!Range} ranges The aggregation ranges.
    * @return {!RangeAggregation}
    * @static
    */

		}, {
				key: 'range',
				value: function range(field) {
						for (var _len2 = arguments.length, ranges = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								ranges[_key2 - 1] = arguments[_key2];
						}

						return new (Function.prototype.bind.apply(Aggregation.RangeAggregation, [null].concat([field], ranges)))();
				}

				/**
    * Creates an {@link Aggregation} instance with the "stats" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'stats',
				value: function stats(field) {
						return Aggregation.field(field, 'stats');
				}

				/**
    * Creates an {@link Aggregation} instance with the "sum" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'sum',
				value: function sum(field) {
						return Aggregation.field(field, 'sum');
				}

				/**
    * Creates an {@link Aggregation} instance with the "terms" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'terms',
				value: function terms(field) {
						return Aggregation.field(field, 'terms');
				}
		}]);

		return Aggregation;
}();

/**
 * Class that represents a distance aggregation.
 * @extends {Aggregation}
 */


var DistanceAggregation = function (_Aggregation) {
		_inherits(DistanceAggregation, _Aggregation);

		/**
  * Constructs an {@link DistanceAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {*} location The aggregation location.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
		function DistanceAggregation(field, location) {
				_classCallCheck(this, DistanceAggregation);

				var _this = _possibleConstructorReturn(this, (DistanceAggregation.__proto__ || Object.getPrototypeOf(DistanceAggregation)).call(this, field, 'geoDistance', {}));

				_this.value_.location = _Embodied2.default.toBody(location);

				for (var _len3 = arguments.length, ranges = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
						ranges[_key3 - 2] = arguments[_key3];
				}

				_this.value_.ranges = ranges.map(function (range) {
						return range.body();
				});
				return _this;
		}

		/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @return {Aggregation} Returns the {@link Aggregation} object itself, so
  *   calls can be chained.
  * @chainable
  */


		_createClass(DistanceAggregation, [{
				key: 'range',
				value: function range(rangeOrFrom, opt_to) {
						var range = rangeOrFrom;
						if (!(range instanceof _Range2.default)) {
								range = _Range2.default.range(rangeOrFrom, opt_to);
						}
						this.value_.ranges.push(range.body());
						return this;
				}

				/**
    * Sets this aggregation's unit.
    * @param {string} unit
    * @return {Aggregation} Returns the {@link Aggregation} object itself, so
    *   calls can be chained.
    * @chainable
    */

		}, {
				key: 'unit',
				value: function unit(_unit) {
						this.value_.unit = _unit;
						return this;
				}
		}]);

		return DistanceAggregation;
}(Aggregation);

Aggregation.DistanceAggregation = DistanceAggregation;

/**
 * Class that represents a range aggregation.
 * @extends {Aggregation}
 */

var RangeAggregation = function (_Aggregation2) {
		_inherits(RangeAggregation, _Aggregation2);

		/**
  * Constructs an {@link RangeAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
		function RangeAggregation(field) {
				_classCallCheck(this, RangeAggregation);

				var _this2 = _possibleConstructorReturn(this, (RangeAggregation.__proto__ || Object.getPrototypeOf(RangeAggregation)).call(this, field, 'range'));

				for (var _len4 = arguments.length, ranges = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
						ranges[_key4 - 1] = arguments[_key4];
				}

				_this2.value_ = ranges.map(function (range) {
						return range.body();
				});
				return _this2;
		}

		/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @return {Aggregation} Returns the {@link Aggregation} object itself, so
  *   calls can be chained.
  * @chainable
  */


		_createClass(RangeAggregation, [{
				key: 'range',
				value: function range(rangeOrFrom, opt_to) {
						var range = rangeOrFrom;
						if (!(range instanceof _Range2.default)) {
								range = _Range2.default.range(rangeOrFrom, opt_to);
						}
						this.value_.push(range.body());
						return this;
				}
		}]);

		return RangeAggregation;
}(Aggregation);

Aggregation.RangeAggregation = RangeAggregation;

exports.default = Aggregation;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied = __webpack_require__(1);

var _Embodied2 = _interopRequireDefault(_Embodied);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for storing and handling the body contents
 * of a Filter instance.
 */
var FilterBody = function () {
  /**
  * Constructs a {@link FilterBody} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
  function FilterBody(field, operatorOrValue, opt_value) {
    _classCallCheck(this, FilterBody);

    var obj = {
      operator: _metal.core.isDef(opt_value) ? operatorOrValue : '='
    };

    var value = _metal.core.isDef(opt_value) ? opt_value : operatorOrValue;

    if (_metal.core.isDefAndNotNull(value)) {
      if (value instanceof _Embodied2.default) {
        value = value.body();
      }
      obj.value = value;
    }

    if (_metal.core.isDefAndNotNull(field)) {
      this.createBody_(field, obj);
    } else {
      this.createBody_('and', []);
    }
  }

  /**
  * Composes the current filter with the given operator.
  * @param {string} operator
  * @param {Filter=} opt_filter Another filter to compose this filter with,
  *   if the operator is not unary.
  */


  _createClass(FilterBody, [{
    key: 'add',
    value: function add(operator, opt_filter) {
      if (opt_filter) {
        this.addArrayOperator_(operator, opt_filter);
      } else {
        this.createBody_(operator, this.body_);
      }
    }

    /**
    * Composes the current filter with an operator that stores its values in an
    * array.
    * @param {string} operator
    * @param {!Filter} filter
    * @protected
    */

  }, {
    key: 'addArrayOperator_',
    value: function addArrayOperator_(operator, filter) {
      if (!(this.body_[operator] instanceof Array)) {
        this.createBody_(operator, [this.body_]);
      }
      this.body_[operator].push(filter.body());
    }

    /**
    * Adds filters to be composed with this filter body using the given operator.
    * @param {string} operator
    * @param {...*} filters A variable amount of filters to be composed.
    */

  }, {
    key: 'addMany',
    value: function addMany(operator) {
      for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        filters[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < filters.length; i++) {
        this.add(operator, filters[i]);
      }
    }

    /**
    * Creates a new body object, setting the requested key to the given value.
    * @param {string} key The key to set in the new body object
    * @param {*} value The value the requested key should have in the new body
    *   object.
    * @protected
    */

  }, {
    key: 'createBody_',
    value: function createBody_(key, value) {
      this.body_ = {};
      this.body_[key] = value;
    }

    /**
    * Gets the json object that represents this filter's body.
    * @return {!Object}
    */

  }, {
    key: 'getObject',
    value: function getObject() {
      return this.body_;
    }
  }]);

  return FilterBody;
}();

exports.default = FilterBody;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _ClientMessage2 = __webpack_require__(16);

var _ClientMessage3 = _interopRequireDefault(_ClientMessage2);

var _metalStructs = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a client request object.
 * @extends {ClientMessage}
 */
var ClientRequest = function (_ClientMessage) {
  _inherits(ClientRequest, _ClientMessage);

  /**
  * Constructs an {@link ClientRequest} instance.
  * @constructor
  */
  function ClientRequest() {
    _classCallCheck(this, ClientRequest);

    var _this = _possibleConstructorReturn(this, (ClientRequest.__proto__ || Object.getPrototypeOf(ClientRequest)).call(this));

    _this.params_ = new _metalStructs.MultiMap();
    _this.withCredentials_ = true;
    return _this;
  }

  /**
  * Fluent getter and setter for with credentials option.
  * @param {boolean=} opt_withCredentials
  * @return {!ClientRequest|boolean} Returns the {@link ClientMessage} object
  *   itself when used as setter, otherwise returns the current value of with
  *   credentials option.
  * @chainable Chainable when used as setter.
  */


  _createClass(ClientRequest, [{
    key: 'withCredentials',
    value: function withCredentials(opt_withCredentials) {
      if (_metal.core.isDef(opt_withCredentials)) {
        this.withCredentials_ = !!opt_withCredentials;
        return this;
      }
      return this.withCredentials_;
    }

    /**
    * Fluent getter and setter for request method.
    * @param {string=} opt_method Request method to be set. If none is given,
    *   the current method value will be returned.
    * @return {!ClientMessage|string} Returns request method if no new value was
    *   given. Otherwise returns the {@link ClientMessage} object itself, so
    *   calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'method',
    value: function method(opt_method) {
      if (_metal.core.isDef(opt_method)) {
        this.method_ = opt_method;
        return this;
      }
      return this.method_ || ClientRequest.DEFAULT_METHOD;
    }

    /**
    * Adds a query. If a query with the same name already exists, it will not
    * be overwritten, but new value will be stored as well. The order is
    * preserved.
    * @param {string} name
    * @param {string} value
    * @return {!ClientMessage} Returns the {@link ClientMessage} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'param',
    value: function param(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.params_.set(name, value);
      return this;
    }

    /**
    * Fluent getter and setter for request querystring.
    * @param {MultiMap|Object=} opt_params Request querystring map to be set.
    *   If none is given the current value of the params will be returned.
    * @return {!MultiMap|ClientMessage} Returns map of request querystring if
    *   no new value was given. Otherwise returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    */

  }, {
    key: 'params',
    value: function params(opt_params) {
      if (_metal.core.isDef(opt_params)) {
        if (opt_params instanceof _metalStructs.MultiMap) {
          this.params_ = opt_params;
        } else {
          this.params_.values = opt_params;
        }
        return opt_params;
      }
      return this.params_;
    }

    /**
    * Fluent getter and setter for request url.
    * @param {string=} opt_url Request url to be set. If none is given,
    *   the current value of the url will be returned.
    * @return {!ClientMessage|string} Returns request url if no new value was
    *  given.
    *  Otherwise returns the {@link ClientMessage} object itself, so calls can be
    *  chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'url',
    value: function url(opt_url) {
      if (_metal.core.isDef(opt_url)) {
        this.url_ = opt_url;
        return this;
      }
      return this.url_;
    }
  }]);

  return ClientRequest;
}(_ClientMessage3.default);

ClientRequest.DEFAULT_METHOD = 'GET';

exports.default = ClientRequest;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _ClientMessage2 = __webpack_require__(16);

var _ClientMessage3 = _interopRequireDefault(_ClientMessage2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a client response object.
 * @extends {ClientMessage}
 */
var ClientResponse = function (_ClientMessage) {
  _inherits(ClientResponse, _ClientMessage);

  /**
  * Constructs an {@link ClientResponse} instance.
  * @param {!ClientRequest} clientRequest Instance of {@link ClientRequest}
  *   object.
  * @constructor
  */
  function ClientResponse(clientRequest) {
    _classCallCheck(this, ClientResponse);

    var _this = _possibleConstructorReturn(this, (ClientResponse.__proto__ || Object.getPrototypeOf(ClientResponse)).call(this));

    if (!clientRequest) {
      throw new Error('Can\'t create response without request');
    }
    _this.clientRequest_ = clientRequest;
    return _this;
  }

  /**
  * Returns request that created this response.
  * @return {!ClientRequest}
  */


  _createClass(ClientResponse, [{
    key: 'request',
    value: function request() {
      return this.clientRequest_;
    }

    /**
    * Fluent getter and setter for response status code.
    * @param {number=} opt_statusCode Request status code to be set. If none is
    *  given, the current status code value will be returned.
    * @return {!ClientMessage|number} Returns response status code if no new
    *   value was given. Otherwise returns the {@link ClientMessage} object
    *   itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'statusCode',
    value: function statusCode(opt_statusCode) {
      if (_metal.core.isDef(opt_statusCode)) {
        this.statusCode_ = opt_statusCode;
        return this;
      }
      return this.statusCode_;
    }

    /**
    * Fluent getter and setter for response status text.
    * @param {string=} opt_statusText Request status text to be set. If none is
    *   given, the current status text value will be returned.
    * @return {!ClientMessage|number} Returns response status text if no new
    *   value was given. Otherwise returns the {@link ClientMessage} object
    *   itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'statusText',
    value: function statusText(opt_statusText) {
      if (_metal.core.isDef(opt_statusText)) {
        this.statusText_ = opt_statusText;
        return this;
      }
      return this.statusText_;
    }

    /**
    * Checks if response succeeded. Any status code 2xx or 3xx is considered
    * valid.
    * @return {boolean}
    */

  }, {
    key: 'succeeded',
    value: function succeeded() {
      return this.statusCode() >= 200 && this.statusCode() <= 399;
    }
  }]);

  return ClientResponse;
}(_ClientMessage3.default);

exports.default = ClientResponse;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Provides a convenient interface for data transport.
 * @interface
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Transport = function Transport() {
	_classCallCheck(this, Transport);
};

exports.default = Transport;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AjaxTransport = __webpack_require__(29);

var _AjaxTransport2 = _interopRequireDefault(_AjaxTransport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides a factory for data transport.
 */
var TransportFactory = function () {
  /**
  * Constructs an {@link TransportFactory} instance.
  * @constructor
  */
  function TransportFactory() {
    _classCallCheck(this, TransportFactory);

    this.transports = {};
    this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
  }

  /**
  * Returns {@link TransportFactory} instance.
  * @return {!TransportFactory} Instance of TransportFactory
  */


  _createClass(TransportFactory, [{
    key: 'get',


    /**
    * Gets an instance of the transport implementation with the given name.
    * @param {string} implementationName
    * @return {!Transport}
    */
    value: function get(implementationName) {
      var TransportClass = this.transports[implementationName];

      if (!TransportClass) {
        throw new Error('Invalid transport name: ' + implementationName);
      }

      try {
        return new TransportClass();
      } catch (err) {
        throw new Error('Can\'t create transport', err);
      }
    }

    /**
    * Returns the default transport implementation.
    * @return {!Transport}
    */

  }, {
    key: 'getDefault',
    value: function getDefault() {
      return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
    }
  }], [{
    key: 'instance',
    value: function instance() {
      if (!TransportFactory.instance_) {
        TransportFactory.instance_ = new TransportFactory();
      }
      return TransportFactory.instance_;
    }
  }]);

  return TransportFactory;
}();

TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = _AjaxTransport2.default;

exports.default = TransportFactory;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Auth = __webpack_require__(10);

var _Auth2 = _interopRequireDefault(_Auth);

var _ApiHelper2 = __webpack_require__(9);

var _ApiHelper3 = _interopRequireDefault(_ApiHelper2);

var _FacebookAuthProvider = __webpack_require__(26);

var _FacebookAuthProvider2 = _interopRequireDefault(_FacebookAuthProvider);

var _GithubAuthProvider = __webpack_require__(27);

var _GithubAuthProvider2 = _interopRequireDefault(_GithubAuthProvider);

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _GoogleAuthProvider = __webpack_require__(28);

var _GoogleAuthProvider2 = _interopRequireDefault(_GoogleAuthProvider);

var _metalStorage = __webpack_require__(41);

var _assertions = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for encapsulating auth API calls.
 */
var AuthApiHelper = function (_ApiHelper) {
  _inherits(AuthApiHelper, _ApiHelper);

  /**
  * Constructs an {@link AuthApiHelper} instance.
  * @param {!string} wedeployClient
  * @constructor
  */
  function AuthApiHelper(wedeployClient) {
    _classCallCheck(this, AuthApiHelper);

    var _this = _possibleConstructorReturn(this, (AuthApiHelper.__proto__ || Object.getPrototypeOf(AuthApiHelper)).call(this, wedeployClient));

    _this.currentUser = null;
    _this.onSignInCallback = null;
    _this.onSignOutCallback = null;

    if (_metalStorage.LocalStorageMechanism.isSupported()) {
      _this.storage = new _metalStorage.Storage(new _metalStorage.LocalStorageMechanism());
    }

    _this.processSignIn_();

    _this.provider = {
      Facebook: _FacebookAuthProvider2.default,
      Google: _GoogleAuthProvider2.default,
      Github: _GithubAuthProvider2.default
    };
    return _this;
  }

  /**
  * Creates access token cookie.
  * @param {string} accessToken
  */


  _createClass(AuthApiHelper, [{
    key: 'createAccessTokenCookie',
    value: function createAccessTokenCookie(accessToken) {
      if (_globals2.default.document && _globals2.default.window) {
        _globals2.default.document.cookie = 'access_token=' + accessToken + '; Domain=' + _globals2.default.window.location.hostname + ';';
      }
    }

    /**
     * @param {Object} data
     * @return {Auth}
     */

  }, {
    key: 'createAuthFromData',
    value: function createAuthFromData(data) {
      var auth = _Auth2.default.createFromData(data);
      auth.setWedeployClient(this.wedeployClient);
      return auth;
    }

    /**
    * Creates user.
    * @param {!Object} data The data to be used to create the user.
    * @return {CancellablePromise}
    */

  }, {
    key: 'createUser',
    value: function createUser(data) {
      var _this2 = this;

      (0, _assertions.assertObject)(data, 'User data must be specified as object');

      var request = this.buildUrl_().path('/users');

      var authScope = this.resolveAuthScope();
      if (authScope) {
        request.auth(authScope.token);
      }

      return request.post(data).then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return _this2.createAuthFromData(response.body());
      });
    }

    /**
    * Deletes access token cookie.
    */

  }, {
    key: 'deleteAccessTokenCookie',
    value: function deleteAccessTokenCookie() {
      if (_globals2.default.document && _globals2.default.window) {
        _globals2.default.document.cookie = 'access_token=;expires=Thu, 01 Jan 1970 00:00:01 GMT;Domain=' + _globals2.default.window.location.hostname + ';';
      }
    }

    /**
    * Gets the current browser url without the fragment part.
    * @return {!string}
    * @protected
    */

  }, {
    key: 'getHrefWithoutFragment_',
    value: function getHrefWithoutFragment_() {
      var location = _globals2.default.window.location;
      return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
    }

    /**
    * Gets the access token from the url fragment and removes it.
    * @return {?string}
    * @protected
    */

  }, {
    key: 'getRedirectAccessToken_',
    value: function getRedirectAccessToken_() {
      if (_globals2.default.window && _globals2.default.window.location) {
        var fragment = _globals2.default.window.location.hash;
        if (fragment.indexOf('#access_token=') === 0) {
          return fragment.substring(14);
        }
      }
      return null;
    }

    /**
    * Gets user by id.
    * @param {!string} userId
    * @return {CancellablePromise}
    */

  }, {
    key: 'getUser',
    value: function getUser(userId) {
      var _this3 = this;

      (0, _assertions.assertDefAndNotNull)(userId, 'User userId must be specified');
      (0, _assertions.assertUserSignedIn)(this.currentUser);
      return this.buildUrl_().path('/users', userId).auth(this.resolveAuthScope().token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return _this3.createAuthFromData(response.body());
      });
    }

    /**
    * Loads current user. Requires a user token as argument.
    * @param {!string} token
    * @return {CancellablePromise}
    */

  }, {
    key: 'loadCurrentUser',
    value: function loadCurrentUser(token) {
      var _this4 = this;

      return this.verifyUser(token).then(function (currentUser) {
        _this4.currentUser = currentUser;
        if (_this4.storage) {
          _this4.storage.set('currentUser', currentUser);
        }
        if (_this4.currentUser.hasToken()) {
          _this4.createAccessTokenCookie(_this4.currentUser.getToken());
        }
        return _this4.currentUser;
      });
    }

    /**
    * Calls the on sign in callback if set.
    * @protected
    */

  }, {
    key: 'maybeCallOnSignInCallback_',
    value: function maybeCallOnSignInCallback_() {
      if (this.onSignInCallback) {
        this.onSignInCallback.call(this, this.currentUser);
      }
    }

    /**
    * Calls the on sign out callback if set.
    * @protected
    */

  }, {
    key: 'maybeCallOnSignOutCallback_',
    value: function maybeCallOnSignOutCallback_() {
      if (this.onSignOutCallback) {
        this.onSignOutCallback.call(this, this.currentUser);
      }
    }

    /**
    * Fires passed callback when a user sign-in. Note that it keeps only the
    * last callback passed.
    * @param {!Function} callback
    */

  }, {
    key: 'onSignIn',
    value: function onSignIn(callback) {
      (0, _assertions.assertFunction)(callback, 'Sign-in callback must be a function');
      this.onSignInCallback = callback;
    }

    /**
    * Fires passed callback when a user sign-out. Note that it keeps only the
    * last callback passed.
    * @param {!Function} callback
    */

  }, {
    key: 'onSignOut',
    value: function onSignOut(callback) {
      (0, _assertions.assertFunction)(callback, 'Sign-out callback must be a function');
      this.onSignOutCallback = callback;
    }

    /**
    * Processes sign-in by detecting a presence of a fragment
    * <code>#access_token=</code> in the url or, alternatively, by local
    * storage current user.
    */

  }, {
    key: 'processSignIn_',
    value: function processSignIn_() {
      var _this5 = this;

      var redirectAccessToken = this.getRedirectAccessToken_();
      if (redirectAccessToken) {
        this.removeUrlFragmentCompletely_();
        this.loadCurrentUser(redirectAccessToken).then(function () {
          return _this5.maybeCallOnSignInCallback_();
        });
        return;
      }
      var currentUser = this.storage && this.storage.get('currentUser');
      if (currentUser) {
        this.currentUser = this.createAuthFromData(currentUser);
      }
    }

    /**
    * Removes fragment from url by performing a push state to the current path.
    * @protected
    */

  }, {
    key: 'removeUrlFragmentCompletely_',
    value: function removeUrlFragmentCompletely_() {
      _globals2.default.window.history.pushState({}, '', window.location.pathname + window.location.search);
    }

    /**
    * Resolves auth scope from last login or api helper.
    * @return {Auth}
    */

  }, {
    key: 'resolveAuthScope',
    value: function resolveAuthScope() {
      if (this.helperAuthScope) {
        return this.helperAuthScope;
      }
      return this.currentUser;
    }

    /**
    * Sends password reset email to the specified email if found in database.
    * For security reasons call do not fail if email not found.
    * @param {!string} email
    * @return {CancellablePromise}
    */

  }, {
    key: 'sendPasswordResetEmail',
    value: function sendPasswordResetEmail(email) {
      (0, _assertions.assertDefAndNotNull)(email, 'Send password reset email must be specified');
      return this.buildUrl_().path('/user/recover').param('email', email).post().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
    * Signs in using email and password.
    * @param {!string} email
    * @param {!string} password
    * @return {CancellablePromise}
    */

  }, {
    key: 'signInWithEmailAndPassword',
    value: function signInWithEmailAndPassword(email, password) {
      var _this6 = this;

      (0, _assertions.assertDefAndNotNull)(email, 'Sign-in email must be specified');
      (0, _assertions.assertDefAndNotNull)(password, 'Sign-in password must be specified');

      return this.buildUrl_().path('/oauth/token').param('grant_type', 'password').param('username', email).param('password', password).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return _this6.loadCurrentUser(response.body().access_token);
      }).then(function (user) {
        _this6.maybeCallOnSignInCallback_();
        return user;
      });
    }

    /**
    * Signs in with redirect. Some providers and environment may not support
    * this flow.
    * @param {AuthProvider} provider
    */

  }, {
    key: 'signInWithRedirect',
    value: function signInWithRedirect(provider) {
      (0, _assertions.assertBrowserEnvironment)();
      (0, _assertions.assertDefAndNotNull)(provider, 'Sign-in provider must be defined');
      assertSupportedProvider(provider);

      if (!provider.hasRedirectUri()) {
        provider.setRedirectUri(this.getHrefWithoutFragment_());
      }
      _globals2.default.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
    }

    /**
    * Signs out <code>currentUser</code> and removes from
    *   <code>localStorage</code>.
    * @return {CancellablePromise}
    */

  }, {
    key: 'signOut',
    value: function signOut() {
      var _this7 = this;

      (0, _assertions.assertUserSignedIn)(this.currentUser);
      return this.buildUrl_().path('/oauth/revoke').param('token', this.currentUser.token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        _this7.maybeCallOnSignOutCallback_();
        _this7.unloadCurrentUser_();
        return response;
      });
    }

    /**
     * Builds URL by joining the headers.
     * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
     *   be chained.
     * @chainable
     */

  }, {
    key: 'buildUrl_',
    value: function buildUrl_() {
      return this.wedeployClient.url(this.wedeployClient.authUrl_).headers(this.headers_);
    }

    /**
    * Unloads all information for <code>currentUser</code> and removes from
    * <code>localStorage</code> if present.
    */

  }, {
    key: 'unloadCurrentUser_',
    value: function unloadCurrentUser_() {
      this.currentUser = null;
      if (this.storage) {
        this.storage.remove('currentUser');
      }
      this.deleteAccessTokenCookie();
    }

    /**
    * Method for verifying tokens. If the provided token has the correct
    * format, is not expired, and is properly signed, the method returns the
    * decoded token.
    * @param {!string} token
    * @return {CancellablePromise}
    */

  }, {
    key: 'verifyToken',
    value: function verifyToken(token) {
      (0, _assertions.assertDefAndNotNull)(token, 'Token must be specified');
      return this.buildUrl_().path('/oauth/tokeninfo').param('token', token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body();
      });
    }

    /**
    * Method for verifying user by token. If the provided token has the correct
    * format, is not expired, and is properly signed, the method returns the
    * user payload.
    * @param {!string} tokenOrEmail Either an authorization token,
    * or the email.
    * @param {string=} opt_password If a email is given as the first param,
    * this should be the password.
    * @return {CancellablePromise}
    */

  }, {
    key: 'verifyUser',
    value: function verifyUser(tokenOrEmail, opt_password) {
      var _this8 = this;

      (0, _assertions.assertDefAndNotNull)(tokenOrEmail, 'Token or email must be specified');
      return this.buildUrl_().path('/user').auth(tokenOrEmail, opt_password).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        var data = response.body();
        if (opt_password) {
          data.token = null;
          data.email = tokenOrEmail;
          data.password = opt_password;
        } else {
          data.token = tokenOrEmail;
        }
        return _this8.createAuthFromData(data);
      });
    }
  }]);

  return AuthApiHelper;
}(_ApiHelper3.default);

/**
 * Asserts a passed sign-in provider is supported.
 * Throws an exception if the passed provider is not one of:
 * - FacebookAuthProvider.PROVIDER
 * - GithubAuthProvider.PROVIDER
 * - GoogleAuthProvider.PROVIDER
 * @param {!string} provider
 */


function assertSupportedProvider(provider) {
  switch (provider.constructor.PROVIDER) {
    case _FacebookAuthProvider2.default.PROVIDER:
    case _GithubAuthProvider2.default.PROVIDER:
    case _GoogleAuthProvider2.default.PROVIDER:
      break;
    default:
      throw new Error('Sign-in provider not supported');
  }
}

exports.default = AuthApiHelper;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AuthProvider2 = __webpack_require__(11);

var _AuthProvider3 = _interopRequireDefault(_AuthProvider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Facebook auth provider implementation.
 */
var FacebookAuthProvider = function (_AuthProvider) {
  _inherits(FacebookAuthProvider, _AuthProvider);

  /**
  * Constructs an {@link FacebookAuthProvider} instance.
  * @constructor
  */
  function FacebookAuthProvider() {
    _classCallCheck(this, FacebookAuthProvider);

    var _this = _possibleConstructorReturn(this, (FacebookAuthProvider.__proto__ || Object.getPrototypeOf(FacebookAuthProvider)).call(this));

    _this.provider = FacebookAuthProvider.PROVIDER;
    return _this;
  }

  return FacebookAuthProvider;
}(_AuthProvider3.default);

FacebookAuthProvider.PROVIDER = 'facebook';

exports.default = FacebookAuthProvider;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AuthProvider2 = __webpack_require__(11);

var _AuthProvider3 = _interopRequireDefault(_AuthProvider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Github auth provider implementation.
 */
var GithubAuthProvider = function (_AuthProvider) {
  _inherits(GithubAuthProvider, _AuthProvider);

  /**
  * Constructs an {@link GithubAuthProvider} instance.
  * @constructor
  */
  function GithubAuthProvider() {
    _classCallCheck(this, GithubAuthProvider);

    var _this = _possibleConstructorReturn(this, (GithubAuthProvider.__proto__ || Object.getPrototypeOf(GithubAuthProvider)).call(this));

    _this.provider = GithubAuthProvider.PROVIDER;
    return _this;
  }

  return GithubAuthProvider;
}(_AuthProvider3.default);

GithubAuthProvider.PROVIDER = 'github';

exports.default = GithubAuthProvider;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AuthProvider2 = __webpack_require__(11);

var _AuthProvider3 = _interopRequireDefault(_AuthProvider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Google auth provider implementation.
 */
var GoogleAuthProvider = function (_AuthProvider) {
  _inherits(GoogleAuthProvider, _AuthProvider);

  /**
  * Constructs an {@link GoogleAuthProvider} instance.
  * @constructor
  */
  function GoogleAuthProvider() {
    _classCallCheck(this, GoogleAuthProvider);

    var _this = _possibleConstructorReturn(this, (GoogleAuthProvider.__proto__ || Object.getPrototypeOf(GoogleAuthProvider)).call(this));

    _this.provider = GoogleAuthProvider.PROVIDER;
    return _this;
  }

  return GoogleAuthProvider;
}(_AuthProvider3.default);

GoogleAuthProvider.PROVIDER = 'google';

exports.default = GoogleAuthProvider;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metalAjax = __webpack_require__(38);

var _metalAjax2 = _interopRequireDefault(_metalAjax);

var _Transport2 = __webpack_require__(23);

var _Transport3 = _interopRequireDefault(_Transport2);

var _ClientResponse = __webpack_require__(22);

var _ClientResponse2 = _interopRequireDefault(_ClientResponse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The implementation of an ajax transport to be used with {@link WeDeploy}.
 * @extends {Transport}
 */
var AjaxTransport = function (_Transport) {
  _inherits(AjaxTransport, _Transport);

  function AjaxTransport() {
    _classCallCheck(this, AjaxTransport);

    return _possibleConstructorReturn(this, (AjaxTransport.__proto__ || Object.getPrototypeOf(AjaxTransport)).apply(this, arguments));
  }

  _createClass(AjaxTransport, [{
    key: 'send',

    /**
    * @inheritDoc
    */
    value: function send(clientRequest) {
      var deferred = _metalAjax2.default.request(clientRequest.url(), clientRequest.method(), clientRequest.body(), clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

      return deferred.then(function (response) {
        var clientResponse = new _ClientResponse2.default(clientRequest);
        clientResponse.body(response.responseText);
        clientResponse.statusCode(response.status);
        clientResponse.statusText(response.statusText);
        _metalAjax2.default.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function (header) {
          clientResponse.header(header.name, header.value);
        });
        return clientResponse;
      });
    }
  }]);

  return AjaxTransport;
}(_Transport3.default);

exports.default = AjaxTransport;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ApiHelper2 = __webpack_require__(9);

var _ApiHelper3 = _interopRequireDefault(_ApiHelper2);

var _Query = __webpack_require__(7);

var _Query2 = _interopRequireDefault(_Query);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _assertions = __webpack_require__(3);

var _metal = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for encapsulate data api calls.
 */
var DataApiHelper = function (_ApiHelper) {
		_inherits(DataApiHelper, _ApiHelper);

		/**
  * Constructs an {@link DataApiHelper} instance.
  * @param {!WeDeploy} wedeployClient {@link WeDeploy} client reference.
  * @constructor
  */
		function DataApiHelper(wedeployClient) {
				_classCallCheck(this, DataApiHelper);

				var _this = _possibleConstructorReturn(this, (DataApiHelper.__proto__ || Object.getPrototypeOf(DataApiHelper)).call(this, wedeployClient));

				_this.isSearch_ = false;
				return _this;
		}

		/**
  * Adds a filter to this request's {@link Query}.
  * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
  *   calls can be chained.
  * @chainable
  */


		_createClass(DataApiHelper, [{
				key: 'where',
				value: function where(fieldOrFilter, opt_operatorOrValue, opt_value) {
						this.getOrCreateFilter_().and(fieldOrFilter, opt_operatorOrValue, opt_value);
						return this;
				}

				/**
    * Adds a filter to be composed with this filter using the "or" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    *   the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'or',
				value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
						if (this.getOrCreateFilter_().body().and.length === 0) {
								throw Error('It\'s required to have a condition before using an \'or()\' ' + 'for the first time.');
						}
						this.getOrCreateFilter_().or(fieldOrFilter, opt_operatorOrValue, opt_value);
						return this;
				}

				/**
    * Adds a filter to be compose with this filter using "none" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|*)} args A variable amount of values to be used with
    * the "none" operator. Can be passed either as a single array or as
    * separate params.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'none',
				value: function none(field) {
						for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
								args[_key - 1] = arguments[_key];
						}

						return this.where(_Filter2.default.none(field, args));
				}

				/**
    * Adds a filter to be compose with this filter using "match" operator.
    * @param {string} field If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'match',
				value: function match(field, opt_query) {
						return this.where(_Filter2.default.match(field, opt_query));
				}

				/**
    * Adds a filter to be compose with this filter using "prefix" operator.
    * @param {string} field The name of the field to filter by.
    * @param {string=} opt_query The query string.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'prefix',
				value: function prefix(field, opt_query) {
						return this.where(_Filter2.default.prefix(field, opt_query));
				}

				/**
    * Adds a filter to be compose with this filter using "similar" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    * should be the query string, in which case all fields will be matched.
    * Otherwise, this should be the name of the field to match.
    * @param {?string} query The query string.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'similar',
				value: function similar(fieldOrQuery, query) {
						return this.where(_Filter2.default.similar(fieldOrQuery, query));
				}

				/**
    * Returns a {@link Filter} instance that uses the "<" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'lt',
				value: function lt(field, value) {
						return this.where(_Filter2.default.lt(field, value));
				}

				/**
    * Returns a {@link Filter} instance that uses the "<=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'lte',
				value: function lte(field, value) {
						return this.where(_Filter2.default.lte(field, value));
				}

				/**
    * Adds a filter to be compose with this filter using "any" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|*)} args A variable amount of values to be used with
    * the "none" operator. Can be passed either as a single array or as
    * separate params.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'any',
				value: function any(field) {
						for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								args[_key2 - 1] = arguments[_key2];
						}

						return this.where(_Filter2.default.any(field, args));
				}

				/**
    * Adds a filter to be compose with this filter using "gp" operator. This is a
    * special use case of `Filter.polygon` for bounding boxes.
    * @param {string} field The field's name.
    * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or a
    * bounding box's upper left coordinate.
    * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'boundingBox',
				value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
						return this.where(_Filter2.default.boundingBox(field, boxOrUpperLeft, opt_lowerRight));
				}

				/**
    * Adds a filter to be compose with this filter using "gd" operator.
    * @param {string} field The field's name.
    * @param {*} locationOrCircle Either a `Geo.Circle` instance or a
    * coordinate.
    * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
    * the distance value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'distance',
				value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
						return this.where(_Filter2.default.distance(field, locationOrCircle, opt_rangeOrDistance));
				}

				/**
    * Adds a filter to be compose with this filter using "range" operator.
    * @param {string} field The field's name.
    * @param {*} rangeOrMin Either a `Range` instance or a the range's min
    * value.
    * @param {*=} opt_max The range's max value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'range',
				value: function range(field, rangeOrMin, opt_max) {
						return this.where(_Filter2.default.range(field, rangeOrMin, opt_max));
				}

				/**
    * Sets the limit for this request's {@link Query}.
    * @param {number} limit The max amount of entries that this request should
    *   return.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'limit',
				value: function limit(_limit) {
						this.getOrCreateQuery_().limit(_limit);
						return this;
				}

				/**
    * Sets the offset for this request's {@link Query}.
    * @param {number} offset The index of the first entry that should be
    * returned by this query.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'offset',
				value: function offset(_offset) {
						this.getOrCreateQuery_().offset(_offset);
						return this;
				}

				/**
    * Adds a highlight entry to this request's {@link Query} instance.
    * @param {string} field The field's name.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'highlight',
				value: function highlight(field) {
						this.getOrCreateQuery_().highlight(field);
						return this;
				}

				/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an {@link
    * Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'aggregate',
				value: function aggregate(name, aggregationOrField, opt_operator) {
						this.getOrCreateQuery_().aggregate(name, aggregationOrField, opt_operator);
						return this;
				}

				/**
    * Sets this request's query type to 'count'.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'count',
				value: function count() {
						this.getOrCreateQuery_().type('count');
						return this;
				}

				/**
    * Adds a sort query to this request's body.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should
    * use. If none is given, 'asc' is used by default.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'orderBy',
				value: function orderBy(field, opt_direction) {
						this.getOrCreateQuery_().sort(field, opt_direction);
						return this;
				}

				/**
    * Creates an object (or multiple objects) and saves it to WeDeploy data. If
    * there's a validation registered in the collection and the request is
    * successful, the resulting object (or array of objects) is returned. The
    * data parameter can be either an Object or an Array of Objects.
    * These Objects describe the attributes on the objects that are to be
    *   created.
    * ```javascript
    * var data = WeDeploy.data('http://demodata.wedeploy.io');
    *
    * data.create(
    *   'movies', {'title'=> 'Star Wars: Episode I  The Phantom Menace'})
    * 	 .then(function(movie){
    *     console.log(movie)
    *   });
    *
    * data.create(
    *   'movies', [{'title'=> 'Star Wars: Episode II  Attack of the Clones'},
    * 						  {'title'=> 'Star Wars: Episode III  Revenge of the Sith'})
    * 		 .then(function(movies){
    * 			 console.log(movies)
    *     });
    * ```
    * @param {string} collection Collection (key) used to create the new data.
    * @param {Object} data Attributes on the object that is to be created.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'create',
				value: function create(collection, data) {
						(0, _assertions.assertDefAndNotNull)(collection, 'Collection key must be specified.');
						(0, _assertions.assertObject)(data, 'Data can\'t be empty.');

						return this.buildUrl_().path(collection).post(data).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Replaces the attributes of a document form the passed-in object and saves
    * the record. If the object is invalid, the saving will fail and an error
    * object will be returned.
    *
    * ```javascript
    * var data = WeDeploy.data('http://demodata.wedeploy.io');
    *
    * data.replace('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
    * 		 .then(function(movie){
    * 			 console.log(movie)
    *     });
    * ```
    * @param {string} doc Key used to update the document.
    * @param {Object} data Attributes on the object that is to be updated.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'replace',
				value: function replace(doc, data) {
						(0, _assertions.assertDefAndNotNull)(doc, 'Document key must be specified.');
						(0, _assertions.assertObject)(data, 'Data must be specified.');

						return this.buildUrl_().path(doc).put(data).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Update the attributes of a document form the passed-in object and saves
    * the record. If the object is invalid, the saving will fail and an error
    * object will be returned.
    *
    * ```javascript
    * var data = WeDeploy.data('http://demodata.wedeploy.io');
    *
    * data.update('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
    * 		 .then(function(movie){
    * 			 console.log(movie)
    *     });
    * ```
    * @param {string} doc Key used to update the document.
    * @param {Object} data Attributes on the object that is to be updated.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'update',
				value: function update(doc, data) {
						(0, _assertions.assertDefAndNotNull)(doc, 'Document key must be specified.');
						(0, _assertions.assertObject)(data, 'Data must be specified.');

						return this.buildUrl_().path(doc).patch(data).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Deletes a [document/field/collection].
    * @param {string} key Key used to delete the
    * document/field/collection.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'delete',
				value: function _delete(key) {
						(0, _assertions.assertDefAndNotNull)(key, 'Document/Field/Collection key must be specified');

						return this.buildUrl_().path(key).delete().then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function () {
								return undefined;
						});
				}

				/**
    * Retrieve data from a [document/field/collection].
    * @param {string} key Key used to delete the document/field/collection.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'get',
				value: function get(key) {
						(0, _assertions.assertDefAndNotNull)(key, 'Document/Field/Collection key must be specified');

						return this.buildUrl_().path(key).get(this.processAndResetQueryState()).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Retrieve data from a [document/field/collection] and put it in a search
    * format.
    * @param {string} key Key used to delete the document/field/collection.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'search',
				value: function search(key) {
						(0, _assertions.assertDefAndNotNull)(key, 'Document/Field/Collection key must be specified');

						this.isSearch_ = true;

						return this.buildUrl_().path(key).get(this.processAndResetQueryState()).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Creates new socket.io instance. Monitor the arrival of new broadcasted
    * data.
    * @param  {string} collection key/collection used to find organized data.
    * @param  {Object=} opt_options Object with Socket IO options.
    * @return {!io} Socket IO reference. Server events can be listened on it.
    */

		}, {
				key: 'watch',
				value: function watch(collection, opt_options) {
						(0, _assertions.assertDefAndNotNull)(collection, 'Collection key must be specified');

						return this.buildUrl_().path(collection).watch(this.processAndResetQueryState(), opt_options);
				}

				/**
    * Builds URL by joining the headers and auth.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

		}, {
				key: 'buildUrl_',
				value: function buildUrl_() {
						return this.wedeployClient.url(this.wedeployClient.dataUrl_).headers(this.headers_).auth(this.helperAuthScope);
				}

				/**
    * Gets the currently used main {@link Filter} object. If none exists yet, a
    * new one is created.
    * @return {!Query}
    * @protected
    */

		}, {
				key: 'getOrCreateFilter_',
				value: function getOrCreateFilter_() {
						if (!this.filter_) {
								this.filter_ = new _Filter2.default();
						}
						return this.filter_;
				}

				/**
    * Gets the currently used {@link Query} object. If none exists yet,
    * a new one is created.
    * @return {!Query}
    * @protected
    */

		}, {
				key: 'getOrCreateQuery_',
				value: function getOrCreateQuery_() {
						if (!this.query_) {
								this.query_ = new _Query2.default();
						}
						return this.query_;
				}

				/**
    * Aggregate filters into query and return its latest value. Query and
    * filters are cleaned after aggregation.
    * @return {Query}
    * @protected
    */

		}, {
				key: 'processAndResetQueryState',
				value: function processAndResetQueryState() {
						var filter = void 0;

						if (_metal.core.isDefAndNotNull(this.filter_)) {
								filter = this.getOrCreateFilter_();
						}

						if (this.isSearch_) {
								this.getOrCreateQuery_().search(filter);
						} else if (filter) {
								this.getOrCreateQuery_().filter(filter);
						}

						var query = this.query_;
						this.headers_.clear();
						this.filter_ = null;
						this.isSearch_ = false;
						this.query_ = null;
						return query;
				}
		}]);

		return DataApiHelper;
}(_ApiHelper3.default);

exports.default = DataApiHelper;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assertions = __webpack_require__(3);

var _metalStructs = __webpack_require__(2);

var _ApiHelper2 = __webpack_require__(9);

var _ApiHelper3 = _interopRequireDefault(_ApiHelper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for encapsulate email api calls.
 */
var EmailApiHelper = function (_ApiHelper) {
  _inherits(EmailApiHelper, _ApiHelper);

  /**
  * Constructs an {@link EmailApiHelper} instance.
  * @param {!WeDeploy} wedeployClient {@link WeDeploy} client reference.
  * @constructor
  */
  function EmailApiHelper(wedeployClient) {
    _classCallCheck(this, EmailApiHelper);

    var _this = _possibleConstructorReturn(this, (EmailApiHelper.__proto__ || Object.getPrototypeOf(EmailApiHelper)).call(this, wedeployClient));

    _this.params = new _metalStructs.MultiMap();
    return _this;
  }

  /**
  * Set from attribute on params to be send on email request.
  * @param  {string} from
  * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
  *   so calls can be chained.
  * @chainable
  */


  _createClass(EmailApiHelper, [{
    key: 'from',
    value: function from(_from) {
      (0, _assertions.assertDefAndNotNull)(_from, 'Parameter "from" must be specified');

      this.params.set('from', _from);

      return this;
    }

    /**
    * Set bcc attribute on params to be send on email request.
    * @param  {string} bcc
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'bcc',
    value: function bcc(_bcc) {
      (0, _assertions.assertDefAndNotNull)(_bcc, 'Parameter "bcc" must be specified');

      this.params.add('bcc', _bcc);

      return this;
    }

    /**
    * Set cc attribute on params to be send on email request.
    * @param  {string} cc
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'cc',
    value: function cc(_cc) {
      (0, _assertions.assertDefAndNotNull)(_cc, 'Parameter "cc" must be specified');

      this.params.add('cc', _cc);

      return this;
    }

    /**
    * Set message attribute on params to be send on email request.
    * @param  {string} message
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'message',
    value: function message(_message) {
      (0, _assertions.assertDefAndNotNull)(_message, 'Parameter "message" must be specified');

      this.params.set('message', _message);

      return this;
    }

    /**
    * Set priority attribute on params to be send on email request.
    * @param  {string} priority
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'priority',
    value: function priority(_priority) {
      (0, _assertions.assertDefAndNotNull)(_priority, 'Parameter "priority" must be specified');

      this.params.set('priority', _priority);

      return this;
    }

    /**
    * Set replyTo attribute on params to be send on email request.
    * @param  {string} replyTo
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'replyTo',
    value: function replyTo(_replyTo) {
      (0, _assertions.assertDefAndNotNull)(_replyTo, 'Parameter "replyTo" must be specified');

      this.params.set('replyTo', _replyTo);

      return this;
    }

    /**
    * Set to attribute on params to be send on email request.
    * @param  {string} to
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'to',
    value: function to(_to) {
      (0, _assertions.assertDefAndNotNull)(_to, 'Parameter "to" must be specified');

      this.params.add('to', _to);

      return this;
    }

    /**
    * Set subject attribute on params to be send on email request.
    * @param  {string} subject
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'subject',
    value: function subject(_subject) {
      (0, _assertions.assertDefAndNotNull)(_subject, 'Parameter "subject" must be specified');

      this.params.set('subject', _subject);

      return this;
    }

    /**
    * Sends an email based on given params.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'send',
    value: function send() {
      var _this2 = this;

      var client = this.buildUrl_().path('emails');

      this.params.names().forEach(function (name) {
        var values = _this2.params.getAll(name);

        values.forEach(function (value) {
          client.form(name, value);
        });
      });

      this.params.clear();
      this.headers_.clear();

      return client.post().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body();
      });
    }

    /**
    * Checks the status of an email.
    * @param  {string} emailId
    * @return {!CancellablePromise}
    */

  }, {
    key: 'status',
    value: function status(emailId) {
      (0, _assertions.assertDefAndNotNull)(emailId, 'Parameter "emailId" param must be specified');

      return this.buildUrl_().path('emails', emailId, 'status').get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body();
      });
    }

    /**
     * Builds URL by joining the headers and auth.
     * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
     *   be chained.
     * @chainable
     */

  }, {
    key: 'buildUrl_',
    value: function buildUrl_() {
      return this.wedeployClient.url(this.wedeployClient.emailUrl_).headers(this.headers_).auth(this.helperAuthScope);
    }
  }]);

  return EmailApiHelper;
}(_ApiHelper3.default);

exports.default = EmailApiHelper;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Base64 = function () {
  function Base64() {
    _classCallCheck(this, Base64);
  }

  _createClass(Base64, null, [{
    key: 'encodeString',

    /**
    * Creates a base-64 encoded ASCII string from a "string" of binary data.
    * @param {string} string to be encoded.
    * @return {string}
    * @static
    */
    value: function encodeString(string) {
      if (typeof btoa === 'function') {
        return btoa(string);
      }

      return new Buffer(string.toString(), 'binary').toString('base64');
    }
  }]);

  return Base64;
}();

exports.default = Base64;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35).Buffer))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WeDeploy = exports.Range = exports.Query = exports.Geo = exports.Filter = undefined;

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _Geo = __webpack_require__(15);

var _Geo2 = _interopRequireDefault(_Geo);

var _WeDeploy = __webpack_require__(18);

var _WeDeploy2 = _interopRequireDefault(_WeDeploy);

var _Query = __webpack_require__(7);

var _Query2 = _interopRequireDefault(_Query);

var _Range = __webpack_require__(8);

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_globals2.default.window.Filter = _Filter2.default;
_globals2.default.window.Geo = _Geo2.default;
_globals2.default.window.Query = _Query2.default;
_globals2.default.window.Range = _Range2.default;
_globals2.default.window.WeDeploy = _WeDeploy2.default;

exports.Filter = _Filter2.default;
exports.Geo = _Geo2.default;
exports.Query = _Query2.default;
exports.Range = _Range2.default;
exports.WeDeploy = _WeDeploy2.default;
exports.default = _WeDeploy2.default;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(34)
var ieee754 = __webpack_require__(36)
var isArray = __webpack_require__(37)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 36 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 37 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

var _metalPromise = __webpack_require__(39);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Ajax = function () {
	function Ajax() {
		_classCallCheck(this, Ajax);
	}

	_createClass(Ajax, null, [{
		key: 'parseResponseHeaders',


		/**
   * XmlHttpRequest's getAllResponseHeaders() method returns a string of
   * response headers according to the format described on the spec:
   * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
   * This method parses that string into a user-friendly name/value pair
   * object.
   * @param {string} allHeaders All headers as string.
   * @return {!Array.<Object<string, string>>}
   */
		value: function parseResponseHeaders(allHeaders) {
			var headers = [];
			if (!allHeaders) {
				return headers;
			}
			var pairs = allHeaders.split('\r\n');
			for (var i = 0; i < pairs.length; i++) {
				var index = pairs[i].indexOf(': ');
				if (index > 0) {
					var name = pairs[i].substring(0, index);
					var value = pairs[i].substring(index + 2);
					headers.push({
						name: name,
						value: value
					});
				}
			}
			return headers;
		}

		/**
   * Requests the url using XMLHttpRequest.
   * @param {!string} url
   * @param {!string} method
   * @param {?string} body
   * @param {MultiMap=} opt_headers
   * @param {MultiMap=} opt_params
   * @param {number=} opt_timeout
   * @param {boolean=} opt_sync
   * @param {boolean=} opt_withCredentials
   * @return {Promise} Deferred ajax request.
   * @protected
   */

	}, {
		key: 'request',
		value: function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
			url = url || '';
			method = method || 'GET';

			var request = new XMLHttpRequest();

			var promise = new _metalPromise.CancellablePromise(function (resolve, reject) {
				request.onload = function () {
					if (request.aborted) {
						request.onerror();
						return;
					}
					resolve(request);
				};
				request.onerror = function () {
					var error = new Error('Request error');
					error.request = request;
					reject(error);
				};
			}).thenCatch(function (reason) {
				request.abort();
				throw reason;
			}).thenAlways(function () {
				clearTimeout(timeout);
			});

			url = new _metalUri2.default(url);

			if (opt_params) {
				url.addParametersFromMultiMap(opt_params).toString();
			}

			url = url.toString();

			request.open(method, url, !opt_sync);

			if (opt_withCredentials) {
				request.withCredentials = true;
			}

			if (opt_headers) {
				opt_headers.names().forEach(function (name) {
					request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
				});
			}

			request.send((0, _metal.isDef)(body) ? body : null);

			if ((0, _metal.isDefAndNotNull)(opt_timeout)) {
				var timeout = setTimeout(function () {
					promise.cancel('Request timeout');
				}, opt_timeout);
			}

			return promise;
		}
	}]);

	return Ajax;
}();

exports.default = Ajax;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore metal-promise is temporarily using Google's promises as polyfill.
 * It supports cancellable promises and has clean and fast implementation.
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CancellablePromise = undefined;

var _metal = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function Thenable() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function () {};

/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function (ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function (object) {
  if (!object) {
    return false;
  }
  try {
    return !!object.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function partial(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function CancellablePromise(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(opt_context, function (value) {
      self.resolve_(CancellablePromise.State_.FULFILLED, value);
    }, function (reason) {
      self.resolve_(CancellablePromise.State_.REJECTED, reason);
    });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};

/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;

/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function (opt_value) {
  return new CancellablePromise(function (resolve) {
    resolve(opt_value);
  });
};

/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function (opt_reason) {
  return new CancellablePromise(function (resolve, reject) {
    reject(opt_reason);
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function onFulfill(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill === 0) {
        resolve(values);
      }
    };

    var onReject = function onReject(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(partial(onFulfill, i), onReject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function onFulfill(value) {
      resolve(value);
    };

    var onReject = function onReject(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject === 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, partial(onReject, i));
    }
  });
};

/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_((0, _metal.isFunction)(opt_onFulfilled) ? opt_onFulfilled : null, (0, _metal.isFunction)(opt_onRejected) ? opt_onRejected : null, opt_context);
};
Thenable.addImplementation(CancellablePromise);

/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
  var callback = function callback() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};

/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function (opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    _metal.async.run(function () {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};

/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function (err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};

/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function (resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function (value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function (reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!(0, _metal.isDef)(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
  /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
  return callbackEntry.child;
};

/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};

/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function (reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};

/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function (state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');
  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */x;
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;
  } else if ((0, _metal.isObject)(x)) {
    try {
      var then = x.then;
      if ((0, _metal.isFunction)(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};

/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function (thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function resolve(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function reject(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};

/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function () {
  if (!this.executing_) {
    this.executing_ = true;
    _metal.async.run(this.executeCallbacks_, this);
  }
};

/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function () {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};

/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};

/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function () {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};

/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function () {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    _metal.async.run(function () {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};

/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = _metal.async.throwException;

/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function (handler) {
  CancellablePromise.handleRejection_ = handler;
};

/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = function (_Error) {
  _inherits(_class, _Error);

  function _class(opt_message) {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, _Error.call(this, opt_message));

    if (opt_message) {
      _this.message = opt_message;
    }
    return _this;
  }

  return _class;
}(Error);

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

exports.CancellablePromise = CancellablePromise;
exports.default = CancellablePromise;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metal2 = _interopRequireDefault(_metal);

var _StorageMechanism = __webpack_require__(12);

var _StorageMechanism2 = _interopRequireDefault(_StorageMechanism);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Storage = function () {

	/**
  * Provides a convenient API for data persistence using a selected data
  * storage mechanism.
  * @param {!StorageMechanism} mechanism The underlying storage mechanism.
  * @constructor
  */
	function Storage(mechanism) {
		_classCallCheck(this, Storage);

		assertMechanismDefAndNotNull(mechanism);
		assertMechanismInstanceOf(mechanism);

		/**
   * The mechanism used to persist key-value pairs.
   * @type {StorageMechanism}
   * @protected
   */
		this.mechanism = mechanism;
	}

	/**
  * Clear all items from the data storage.
  */


	_createClass(Storage, [{
		key: 'clear',
		value: function clear() {
			this.mechanism.clear();
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			if (!_metal2.default.isDef(value)) {
				this.mechanism.remove(key);
				return;
			}
			this.mechanism.set(key, JSON.stringify(value));
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			var json;
			try {
				json = this.mechanism.get(key);
			} catch (e) {
				return undefined;
			}
			if (_metal2.default.isNull(json)) {
				return undefined;
			}
			try {
				return JSON.parse(json);
			} catch (e) {
				throw Storage.ErrorCode.INVALID_VALUE;
			}
		}

		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */

	}, {
		key: 'keys',
		value: function keys() {
			return this.mechanism.keys();
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			this.mechanism.remove(key);
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.mechanism.size();
		}

		/**
   * Returns the list of values stored in the Storage object.
   * @param {!Array<string>} values
   */

	}, {
		key: 'values',
		value: function values() {
			var _this = this;

			return this.keys().map(function (key) {
				return _this.get(key);
			});
		}
	}]);

	return Storage;
}();

/**
 * Errors thrown by the storage.
 * @enum {string}
 */


Storage.ErrorCode = {
	INVALID_VALUE: 'Storage: Invalid value was encountered'
};

function assertMechanismDefAndNotNull(mechanism) {
	if (!_metal2.default.isDefAndNotNull(mechanism)) {
		throw Error('Storage mechanism is required');
	}
}

function assertMechanismInstanceOf(mechanism) {
	if (!(mechanism instanceof _StorageMechanism2.default)) {
		throw Error('Storage mechanism must me an implementation of StorageMechanism');
	}
}

exports.default = Storage;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorageMechanism = exports.StorageMechanism = exports.Storage = undefined;

var _Storage = __webpack_require__(40);

var _Storage2 = _interopRequireDefault(_Storage);

var _StorageMechanism = __webpack_require__(12);

var _StorageMechanism2 = _interopRequireDefault(_StorageMechanism);

var _LocalStorageMechanism = __webpack_require__(42);

var _LocalStorageMechanism2 = _interopRequireDefault(_LocalStorageMechanism);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Storage = _Storage2.default;
exports.StorageMechanism = _StorageMechanism2.default;
exports.LocalStorageMechanism = _LocalStorageMechanism2.default;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _StorageMechanism2 = __webpack_require__(12);

var _StorageMechanism3 = _interopRequireDefault(_StorageMechanism2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */
var LocalStorageMechanism = function (_StorageMechanism) {
	_inherits(LocalStorageMechanism, _StorageMechanism);

	function LocalStorageMechanism() {
		_classCallCheck(this, LocalStorageMechanism);

		return _possibleConstructorReturn(this, (LocalStorageMechanism.__proto__ || Object.getPrototypeOf(LocalStorageMechanism)).apply(this, arguments));
	}

	_createClass(LocalStorageMechanism, [{
		key: 'storage',

		/**
   * Returns reference for global local storage. by default
   */
		value: function storage() {
			return LocalStorageMechanism.globals.localStorage;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.storage().clear();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'keys',
		value: function keys() {
			return Object.keys(this.storage());
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'get',
		value: function get(key) {
			return this.storage().getItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'remove',


		/**
   * @inheritDoc
   */
		value: function remove(key) {
			this.storage().removeItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			this.storage().setItem(key, value);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'size',
		value: function size() {
			return this.storage().length;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
		}
	}]);

	return LocalStorageMechanism;
}(_StorageMechanism3.default);

if (LocalStorageMechanism.isSupported()) {
	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};
}

exports.default = LocalStorageMechanism;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */

var MultiMap = function (_Disposable) {
	_inherits(MultiMap, _Disposable);

	function MultiMap() {
		_classCallCheck(this, MultiMap);

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.keys = create(null);
		_this.values = create(null);
		return _this;
	}

	/**
  * Adds value to a key name.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	MultiMap.prototype.add = function add(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
		this.values[name.toLowerCase()].push(value);
		return this;
	};

	/**
  * Clears map names and values.
  * @chainable
  */


	MultiMap.prototype.clear = function clear() {
		this.keys = create(null);
		this.values = create(null);
		return this;
	};

	/**
  * Checks if map contains a value to the key name.
  * @param {string} name
  * @return {boolean}
  * @chainable
  */


	MultiMap.prototype.contains = function contains(name) {
		return name.toLowerCase() in this.values;
	};

	/**
  * @inheritDoc
  */


	MultiMap.prototype.disposeInternal = function disposeInternal() {
		this.values = null;
	};

	/**
  * Creates a `MultiMap` instance from the given object.
  * @param {!Object} obj
  * @return {!MultiMap}
  */


	MultiMap.fromObject = function fromObject(obj) {
		var map = new MultiMap();
		var keys = Object.keys(obj);
		for (var i = 0; i < keys.length; i++) {
			map.set(keys[i], obj[keys[i]]);
		}
		return map;
	};

	/**
  * Gets the first added value from a key name.
  * @param {string} name
  * @return {*}
  * @chainable
  */


	MultiMap.prototype.get = function get(name) {
		var values = this.values[name.toLowerCase()];
		if (values) {
			return values[0];
		}
	};

	/**
  * Gets all values from a key name.
  * @param {string} name
  * @return {Array.<*>}
  */


	MultiMap.prototype.getAll = function getAll(name) {
		return this.values[name.toLowerCase()];
	};

	/**
  * Returns true if the map is empty, false otherwise.
  * @return {boolean}
  */


	MultiMap.prototype.isEmpty = function isEmpty() {
		return this.size() === 0;
	};

	/**
  * Gets array of key names.
  * @return {Array.<string>}
  */


	MultiMap.prototype.names = function names() {
		var _this2 = this;

		return Object.keys(this.values).map(function (key) {
			return _this2.keys[key];
		});
	};

	/**
  * Removes all values from a key name.
  * @param {string} name
  * @chainable
  */


	MultiMap.prototype.remove = function remove(name) {
		delete this.keys[name.toLowerCase()];
		delete this.values[name.toLowerCase()];
		return this;
	};

	/**
  * Sets the value of a key name. Relevant to replace the current values with
  * a new one.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	MultiMap.prototype.set = function set(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = [value];
		return this;
	};

	/**
  * Gets the size of the map key names.
  * @return {number}
  */


	MultiMap.prototype.size = function size() {
		return this.names().length;
	};

	/**
  * Returns the parsed values as a string.
  * @return {string}
  */


	MultiMap.prototype.toString = function toString() {
		return JSON.stringify(this.values);
	};

	return MultiMap;
}(_metal.Disposable);

exports.default = MultiMap;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic tree node data structure with arbitrary number of child nodes.
 * @param {V} value Value.
 * @constructor
 */
var TreeNode = function () {
	function TreeNode(value) {
		_classCallCheck(this, TreeNode);

		/**
   * The value.
   * @private {V}
   */
		this.value_ = value;

		/**
   * Reference to the parent node or null if it has no parent.
   * @private {TreeNode}
   */
		this.parent_ = null;

		/**
   * Child nodes or null in case of leaf node.
   * @private {Array<!TreeNode>}
   */
		this.children_ = null;
	}

	/**
  * Appends a child node to this node.
  * @param {!TreeNode} child Orphan child node.
  */


	TreeNode.prototype.addChild = function addChild(child) {
		assertChildHasNoParent(child);
		child.setParent(this);
		this.children_ = this.children_ || [];
		this.children_.push(child);
	};

	/**
  * Tells whether this node is the ancestor of the given node.
  * @param {!TreeNode} node A node.
  * @return {boolean} Whether this node is the ancestor of {@code node}.
  */


	TreeNode.prototype.contains = function contains(node) {
		var current = node.getParent();
		while (current) {
			if (current === this) {
				return true;
			}
			current = current.getParent();
		}
		return false;
	};

	/**
  * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.
  */


	TreeNode.prototype.getAncestors = function getAncestors() {
		var ancestors = [];
		var node = this.getParent();
		while (node) {
			ancestors.push(node);
			node = node.getParent();
		}
		return ancestors;
	};

	/**
  * Gets the child node of this node at the given index.
  * @param {number} index Child index.
  * @return {?TreeNode} The node at the given index
  * or null if not found.
  */


	TreeNode.prototype.getChildAt = function getChildAt(index) {
		return this.getChildren()[index] || null;
	};

	/**
  * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.
  */


	TreeNode.prototype.getChildren = function getChildren() {
		return this.children_ || TreeNode.EMPTY_ARRAY;
	};

	/**
  * @return {number} The number of children.
  */


	TreeNode.prototype.getChildCount = function getChildCount() {
		return this.getChildren().length;
	};

	/**
  * @return {number} The number of ancestors of the node.
  */


	TreeNode.prototype.getDepth = function getDepth() {
		var depth = 0;
		var node = this;
		while (node.getParent()) {
			depth++;
			node = node.getParent();
		}
		return depth;
	};

	/**
  * @return {?TreeNode} Parent node or null if it has no parent.
  */


	TreeNode.prototype.getParent = function getParent() {
		return this.parent_;
	};

	/**
  * @return {!TreeNode} The root of the tree structure, i.e. the farthest
  * ancestor of the node or the node itself if it has no parents.
  */


	TreeNode.prototype.getRoot = function getRoot() {
		var root = this;
		while (root.getParent()) {
			root = root.getParent();
		}
		return root;
	};

	/**
  * Gets the value.
  * @return {V} The value.
  */


	TreeNode.prototype.getValue = function getValue() {
		return this.value_;
	};

	/**
  * @return {boolean} Whether the node is a leaf node.
  */


	TreeNode.prototype.isLeaf = function isLeaf() {
		return !this.getChildCount();
	};

	/**
  * Removes the given child node of this node.
  * @param {TreeNode} child The node to remove.
  * @return {TreeNode} The removed node if any, null otherwise.
  */


	TreeNode.prototype.removeChild = function removeChild(child) {
		if (_metal.array.remove(this.getChildren(), child)) {
			return child;
		}
		return null;
	};

	/**
  * Sets the parent node of this node. The callers must ensure that the
  * parent node and only that has this node among its children.
  * @param {TreeNode} parent The parent to set. If null, the node will be
  * detached from the tree.
  * @protected
  */


	TreeNode.prototype.setParent = function setParent(parent) {
		this.parent_ = parent;
	};

	/**
  * Traverses the subtree. The first callback starts with this node,
  * and visits the descendant nodes depth-first, in preorder.
  * The second callback, starts with deepest child then visits
  * the ancestor nodes depth-first, in postorder. E.g.
  *
  *  	 A
  *    / \
  *   B   C
  *  /   / \
  * D   E   F
  *
  * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']
  * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']
  *
  * @param {function=} opt_preorderFn The callback to execute when visiting a node.
  * @param {function=} opt_postorderFn The callback to execute before leaving a node.
  */


	TreeNode.prototype.traverse = function traverse(opt_preorderFn, opt_postorderFn) {
		if (opt_preorderFn) {
			opt_preorderFn(this);
		}
		this.getChildren().forEach(function (child) {
			return child.traverse(opt_preorderFn, opt_postorderFn);
		});
		if (opt_postorderFn) {
			opt_postorderFn(this);
		}
	};

	return TreeNode;
}();

/**
 * Constant for empty array to avoid unnecessary allocations.
 * @private
 */


TreeNode.EMPTY_ARRAY = [];

/**
 * Asserts that child has no parent.
 * @param {TreeNode} child A child.
 * @private
 */
var assertChildHasNoParent = function assertChildHasNoParent(child) {
	if (child.getParent()) {
		throw new Error('Cannot add child with parent.');
	}
};

exports.default = TreeNode;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _parse = __webpack_require__(46);

var _parse2 = _interopRequireDefault(_parse);

var _metalStructs = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parseFn_ = _parse2.default;

var Uri = function () {

	/**
  * This class contains setters and getters for the parts of the URI.
  * The following figure displays an example URIs and their component parts.
  *
  *                                  path
  *	                             
  *	  abc://example.com:123/path/data?key=value#fragid1
  *	                  
  * protocol  hostname  port            search    hash
  *          
  *                host
  *
  * @param {*=} opt_uri Optional string URI to parse
  * @constructor
  */
	function Uri() {
		var opt_uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

		_classCallCheck(this, Uri);

		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
  * Adds parameters to uri from a <code>MultiMap</code> as source.
  * @param {MultiMap} multimap The <code>MultiMap</code> containing the
  *   parameters.
  * @protected
  * @chainable
  */


	_createClass(Uri, [{
		key: 'addParametersFromMultiMap',
		value: function addParametersFromMultiMap(multimap) {
			var _this = this;

			multimap.names().forEach(function (name) {
				multimap.getAll(name).forEach(function (value) {
					_this.addParameterValue(name, value);
				});
			});
			return this;
		}

		/**
   * Adds the value of the named query parameters.
   * @param {string} key The parameter to set.
   * @param {*} value The new value. Will be explicitly casted to String.
   * @chainable
   */

	}, {
		key: 'addParameterValue',
		value: function addParameterValue(name, value) {
			this.ensureQueryInitialized_();
			if ((0, _metal.isDef)(value)) {
				value = String(value);
			}
			this.query.add(name, value);
			return this;
		}

		/**
   * Adds the values of the named query parameter.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'addParameterValues',
		value: function addParameterValues(name, values) {
			var _this2 = this;

			values.forEach(function (value) {
				return _this2.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Ensures query internal map is initialized and synced with initial value
   * extracted from URI search part.
   * @protected
   */

	}, {
		key: 'ensureQueryInitialized_',
		value: function ensureQueryInitialized_() {
			var _this3 = this;

			if (this.query) {
				return;
			}
			this.query = new _metalStructs.MultiMap();
			var search = this.url.search;
			if (search) {
				search.substring(1).split('&').forEach(function (param) {
					var _param$split = param.split('='),
					    _param$split2 = _slicedToArray(_param$split, 2),
					    key = _param$split2[0],
					    value = _param$split2[1];

					if ((0, _metal.isDef)(value)) {
						value = Uri.urlDecode(value);
					}
					_this3.addParameterValue(key, value);
				});
			}
		}

		/**
   * Gets the hash part of uri.
   * @return {string}
   */

	}, {
		key: 'getHash',
		value: function getHash() {
			return this.url.hash || '';
		}

		/**
   * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getHost',
		value: function getHost() {
			var host = this.getHostname();
			if (host) {
				var port = this.getPort();
				if (port && port !== '80') {
					host += ':' + port;
				}
			}
			return host;
		}

		/**
   * Gets the hostname part of uri without protocol and port.
   * @return {string}
   */

	}, {
		key: 'getHostname',
		value: function getHostname() {
			var hostname = this.url.hostname;
			if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
				return '';
			}
			return hostname;
		}

		/**
   * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getOrigin',
		value: function getOrigin() {
			var host = this.getHost();
			if (host) {
				return this.getProtocol() + '//' + host;
			}
			return '';
		}

		/**
   * Returns the first value for a given parameter or undefined if the given
   * parameter name does not appear in the query string.
   * @param {string} paramName Unescaped parameter name.
   * @return {string|undefined} The first value for a given parameter or
   *   undefined if the given parameter name does not appear in the query
   *   string.
   */

	}, {
		key: 'getParameterValue',
		value: function getParameterValue(name) {
			this.ensureQueryInitialized_();
			return this.query.get(name);
		}

		/**
   * Returns the value<b>s</b> for a given parameter as a list of decoded
   * query parameter values.
   * @param {string} name The parameter to get values for.
   * @return {!Array<?>} The values for a given parameter as a list of decoded
   *   query parameter values.
   */

	}, {
		key: 'getParameterValues',
		value: function getParameterValues(name) {
			this.ensureQueryInitialized_();
			return this.query.getAll(name);
		}

		/**
   * Returns the name<b>s</b> of the parameters.
   * @return {!Array<string>} The names for the parameters as a list of
   *   strings.
   */

	}, {
		key: 'getParameterNames',
		value: function getParameterNames() {
			this.ensureQueryInitialized_();
			return this.query.names();
		}

		/**
   * Gets the function currently being used to parse URIs.
   * @return {!function()}
   */

	}, {
		key: 'getPathname',


		/**
   * Gets the pathname part of uri.
   * @return {string}
   */
		value: function getPathname() {
			return this.url.pathname;
		}

		/**
   * Gets the port number part of uri as string.
   * @return {string}
   */

	}, {
		key: 'getPort',
		value: function getPort() {
			return this.url.port;
		}

		/**
   * Gets the protocol part of uri. E.g. <code>http:</code>.
   * @return {string}
   */

	}, {
		key: 'getProtocol',
		value: function getProtocol() {
			return this.url.protocol;
		}

		/**
   * Gets the search part of uri. Search value is retrieved from query
   * parameters.
   * @return {string}
   */

	}, {
		key: 'getSearch',
		value: function getSearch() {
			var _this4 = this;

			var search = '';
			var querystring = '';
			this.getParameterNames().forEach(function (name) {
				_this4.getParameterValues(name).forEach(function (value) {
					querystring += name;
					if ((0, _metal.isDef)(value)) {
						querystring += '=' + encodeURIComponent(value);
					}
					querystring += '&';
				});
			});
			querystring = querystring.slice(0, -1);
			if (querystring) {
				search += '?' + querystring;
			}
			return search;
		}

		/**
   * Checks if uri contains the parameter.
   * @param {string} name
   * @return {boolean}
   */

	}, {
		key: 'hasParameter',
		value: function hasParameter(name) {
			this.ensureQueryInitialized_();
			return this.query.contains(name);
		}

		/**
   * Makes this URL unique by adding a random param to it. Useful for avoiding
   * cache.
   */

	}, {
		key: 'makeUnique',
		value: function makeUnique() {
			this.setParameterValue(Uri.RANDOM_PARAM, _metal.string.getRandomString());
			return this;
		}

		/**
   * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
   * Relevent for compatibility with <code>URL</code> native object.
   * @param {string=} opt_uri
   * @return {string} URI with protocol and hostname placeholder.
   */

	}, {
		key: 'maybeAddProtocolAndHostname_',
		value: function maybeAddProtocolAndHostname_(opt_uri) {
			var url = opt_uri;
			if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
				// jshint ignore:line

				url = Uri.DEFAULT_PROTOCOL;
				if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
					url += '//';
				}

				switch (opt_uri.charAt(0)) {
					case '.':
					case '?':
					case '#':
						url += Uri.HOSTNAME_PLACEHOLDER;
						url += '/';
						url += opt_uri;
						break;
					case '':
					case '/':
						if (opt_uri[1] !== '/') {
							url += Uri.HOSTNAME_PLACEHOLDER;
						}
						url += opt_uri;
						break;
					default:
						url += opt_uri;
				}
			}
			return url;
		}

		/**
   * Parses the given uri string into an object.
   * @param {*=} opt_uri Optional string URI to parse
   */

	}, {
		key: 'removeParameter',


		/**
   * Removes the named query parameter.
   * @param {string} name The parameter to remove.
   * @chainable
   */
		value: function removeParameter(name) {
			this.ensureQueryInitialized_();
			this.query.remove(name);
			return this;
		}

		/**
   * Removes uniqueness parameter of the uri.
   * @chainable
   */

	}, {
		key: 'removeUnique',
		value: function removeUnique() {
			this.removeParameter(Uri.RANDOM_PARAM);
			return this;
		}

		/**
   * Sets the hash.
   * @param {string} hash
   * @chainable
   */

	}, {
		key: 'setHash',
		value: function setHash(hash) {
			this.url.hash = hash;
			return this;
		}

		/**
   * Sets the hostname.
   * @param {string} hostname
   * @chainable
   */

	}, {
		key: 'setHostname',
		value: function setHostname(hostname) {
			this.url.hostname = hostname;
			return this;
		}

		/**
   * Sets the value of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValue',
		value: function setParameterValue(name, value) {
			this.removeParameter(name);
			this.addParameterValue(name, value);
			return this;
		}

		/**
   * Sets the values of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValues',
		value: function setParameterValues(name, values) {
			var _this5 = this;

			this.removeParameter(name);
			values.forEach(function (value) {
				return _this5.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Sets the pathname.
   * @param {string} pathname
   * @chainable
   */

	}, {
		key: 'setPathname',
		value: function setPathname(pathname) {
			this.url.pathname = pathname;
			return this;
		}

		/**
   * Sets the port number.
   * @param {*} port Port number.
   * @chainable
   */

	}, {
		key: 'setPort',
		value: function setPort(port) {
			this.url.port = port;
			return this;
		}

		/**
   * Sets the function that will be used for parsing the original string uri
   * into an object.
   * @param {!function()} parseFn
   */

	}, {
		key: 'setProtocol',


		/**
   * Sets the protocol. If missing <code>http:</code> is used as default.
   * @param {string} protocol
   * @chainable
   */
		value: function setProtocol(protocol) {
			this.url.protocol = protocol;
			if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
				this.url.protocol += ':';
			}
			return this;
		}

		/**
   * @return {string} The string form of the url.
   * @override
   */

	}, {
		key: 'toString',
		value: function toString() {
			var href = '';
			var host = this.getHost();
			if (host) {
				href += this.getProtocol() + '//';
			}
			href += host + this.getPathname() + this.getSearch() + this.getHash();
			return href;
		}

		/**
   * Joins the given paths.
   * @param {string} basePath
   * @param {...string} ...paths Any number of paths to be joined with the base url.
   * @static
   */

	}], [{
		key: 'getParseFn',
		value: function getParseFn() {
			return parseFn_;
		}
	}, {
		key: 'parse',
		value: function parse(opt_uri) {
			return parseFn_(opt_uri);
		}
	}, {
		key: 'setParseFn',
		value: function setParseFn(parseFn) {
			parseFn_ = parseFn;
		}
	}, {
		key: 'joinPaths',
		value: function joinPaths(basePath) {
			for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				paths[_key - 1] = arguments[_key];
			}

			if (basePath.charAt(basePath.length - 1) === '/') {
				basePath = basePath.substring(0, basePath.length - 1);
			}
			paths = paths.map(function (path) {
				return path.charAt(0) === '/' ? path.substring(1) : path;
			});
			return [basePath].concat(paths).join('/').replace(/\/$/, '');
		}

		/**
   * URL-decodes the string. We need to specially handle '+'s because
   * the javascript library doesn't convert them to spaces.
   * @param {string} str The string to url decode.
   * @return {string} The decoded {@code str}.
   */

	}, {
		key: 'urlDecode',
		value: function urlDecode(str) {
			return decodeURIComponent(str.replace(/\+/g, ' '));
		}
	}]);

	return Uri;
}();

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */


var isSecure = function isSecure() {
	return typeof window !== 'undefined' && window.location && window.location.protocol && window.location.protocol.indexOf('https') === 0;
};

Uri.DEFAULT_PROTOCOL = isSecure() ? 'https:' : 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

exports.default = Uri;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(0);

var _parseFromAnchor = __webpack_require__(47);

var _parseFromAnchor2 = _interopRequireDefault(_parseFromAnchor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if ((0, _metal.isFunction)(URL) && URL.length) {
		var url = new URL(opt_uri);

		// Safari Browsers will cap port to the max 16-bit unsigned integer (65535) instead
		// of throwing a TypeError as per spec. It will still keep the port number in the
		// href attribute, so we can use this mismatch to raise the expected exception.
		if (url.port && url.href.indexOf(url.port) === -1) {
			throw new TypeError(opt_uri + ' is not a valid URL');
		}

		return url;
	} else {
		return (0, _parseFromAnchor2.default)(opt_uri);
	}
}

exports.default = parse;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;

	if (link.protocol === ':' || !/:/.test(link.href)) {
		throw new TypeError(opt_uri + ' is not a valid URL');
	}

	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

exports.default = parseFromAnchor;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60).setImmediate))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && process.env.NODE_ENV !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module), __webpack_require__(14)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(56);
exports.encode = exports.stringify = __webpack_require__(57);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), __webpack_require__(13)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(59);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(55);
var util = __webpack_require__(62);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(58);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })
/******/ ]);
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy9zb2NrZXQuaW8uc2xpbS5qcyIsIndlYnBhY2s6L3dlYnBhY2svYm9vdHN0cmFwIDZlZmMzM2Y0NTY2OTFmNDU4YTkwIiwid2VicGFjazovLy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2xpYi91cmwuanMiLCJ3ZWJwYWNrOi8vL34vcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3N1cHBvcnQvbm9vcC5qcyIsIndlYnBhY2s6Ly8vfi9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy9+L2hhcy1iaW5hcnkyL2luZGV4LmpzIiwid2VicGFjazovLy9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vL34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vL2xpYi9tYW5hZ2VyLmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vL34vaGFzLWNvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIndlYnBhY2s6Ly8vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi91dGY4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL34vYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJ3ZWJwYWNrOi8vL34vYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9wYXJzZXFzL2luZGV4LmpzIiwid2VicGFjazovLy9+L2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwid2VicGFjazovLy9+L3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIndlYnBhY2s6Ly8vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vfi9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy9+L3BhcnNlanNvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vfi90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbGliL29uLmpzIiwid2VicGFjazovLy9+L2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy9+L2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6L3dlYnBhY2svYm9vdHN0cmFwIDYyMDMzYmIwZTU2Mjk2NmRiZTViIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9tZXRhbC5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS1xdWVyeS9FbWJvZGllZC5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9hbGwvc3RydWN0cy5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hc3NlcnRpb25zLmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dsb2JhbHMvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC11cmkvbm9kZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS1xdWVyeS9RdWVyeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS1xdWVyeS9SYW5nZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9BcGlIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvYXV0aC9BdXRoLmpzIiwid2VicGFjazovLy9zcmMvYXBpL2F1dGgvQXV0aFByb3ZpZGVyLmpzIiwid2VicGFjazovLy9+L21ldGFsLXN0b3JhZ2UvbGliL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtLmpzIiwid2VicGFjazovLy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0dlby5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9DbGllbnRNZXNzYWdlLmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy9zcmMvYXBpL1dlRGVwbG95LmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0FnZ3JlZ2F0aW9uLmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0ZpbHRlckJvZHkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvQ2xpZW50UmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9DbGllbnRSZXNwb25zZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9UcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvVHJhbnNwb3J0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hdXRoL0F1dGhBcGlIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvYXV0aC9GYWNlYm9va0F1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hdXRoL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9icm93c2VyL0FqYXhUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvZGF0YS9EYXRhQXBpSGVscGVyLmpzIiwid2VicGFjazovLy9zcmMvYXBpL2VtYWlsL0VtYWlsQXBpSGVscGVyLmpzIiwid2VicGFjazovLy9zcmMvY3J5cHQvQmFzZTY0LmpzIiwid2VicGFjazovLy9zcmMvZW52L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL34vYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy9+L21ldGFsLWFqYXgvbGliL0FqYXguanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwtcHJvbWlzZS9saWIvcHJvbWlzZS9Qcm9taXNlLmpzIiwid2VicGFjazovLy9+L21ldGFsLXN0b3JhZ2UvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwtc3RvcmFnZS9saWIvYWxsL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwtc3RvcmFnZS9saWIvbWVjaGFuaXNtL0xvY2FsU3RvcmFnZU1lY2hhbmlzbS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9NdWx0aU1hcC5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9UcmVlTm9kZS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC11cmkvbGliL1VyaS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC11cmkvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy9+L21ldGFsLXVyaS9saWIvcGFyc2VGcm9tQW5jaG9yLmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9hcnJheS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwvbGliL2NvcmVOYW1lZC5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzIiwid2VicGFjazovLy9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vfi9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vL34vcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vfi91cmwvdXJsLmpzIiwid2VicGFjazovLy9+L3VybC91dGlsLmpzIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInRoaXMiLCJtb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaW5zdGFsbGVkTW9kdWxlcyIsImlkIiwibG9hZGVkIiwiY2FsbCIsIm0iLCJjIiwicCIsImxvb2t1cCIsInVyaSIsIm9wdHMiLCJfdHlwZW9mIiwidW5kZWZpbmVkIiwiaW8iLCJwYXJzZWQiLCJ1cmwiLCJzb3VyY2UiLCJwYXRoIiwic2FtZU5hbWVzcGFjZSIsImNhY2hlIiwibnNwcyIsIm5ld0Nvbm5lY3Rpb24iLCJmb3JjZU5ldyIsIm11bHRpcGxleCIsIk1hbmFnZXIiLCJxdWVyeSIsInNvY2tldCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJwYXJzZXIiLCJtYW5hZ2VycyIsInByb3RvY29sIiwiY29ubmVjdCIsIlNvY2tldCIsImdsb2JhbCIsImxvYyIsImxvY2F0aW9uIiwiaG9zdCIsImNoYXJBdCIsInRlc3QiLCJwYXJzZXVyaSIsInBvcnQiLCJpcHY2IiwiaW5kZXhPZiIsImhyZWYiLCJyZSIsInBhcnRzIiwic3RyIiwic3JjIiwiYiIsImUiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwibGVuZ3RoIiwiZXhlYyIsImkiLCJhdXRob3JpdHkiLCJpcHY2dXJpIiwiRW5jb2RlciIsImVuY29kZUFzU3RyaW5nIiwidHlwZSIsIkJJTkFSWV9FVkVOVCIsIkJJTkFSWV9BQ0siLCJhdHRhY2htZW50cyIsIm5zcCIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZW5jb2RlQXNCaW5hcnkiLCJjYWxsYmFjayIsIndyaXRlRW5jb2RpbmciLCJibG9ibGVzc0RhdGEiLCJkZWNvbnN0cnVjdGlvbiIsImJpbmFyeSIsImRlY29uc3RydWN0UGFja2V0IiwicGFjayIsInBhY2tldCIsImJ1ZmZlcnMiLCJ1bnNoaWZ0IiwicmVtb3ZlQmxvYnMiLCJEZWNvZGVyIiwicmVjb25zdHJ1Y3RvciIsImRlY29kZVN0cmluZyIsIk51bWJlciIsInR5cGVzIiwiZXJyb3IiLCJidWYiLCJFcnJvciIsIm5leHQiLCJ0cnlQYXJzZSIsInN1YnN0ciIsInBhcnNlIiwiQmluYXJ5UmVjb25zdHJ1Y3RvciIsInJlY29uUGFjayIsIkVSUk9SIiwiRW1pdHRlciIsImhhc0JpbiIsImlzQnVmIiwiQ09OTkVDVCIsIkRJU0NPTk5FQ1QiLCJFVkVOVCIsIkFDSyIsImVuY29kZSIsImVuY29kaW5nIiwiYWRkIiwiZW1pdCIsImJhc2U2NCIsInRha2VCaW5hcnlEYXRhIiwiZGVzdHJveSIsImZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24iLCJiaW5EYXRhIiwicHVzaCIsInJlY29uc3RydWN0UGFja2V0IiwibWl4aW4iLCJrZXkiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImZuIiwiX2NhbGxiYWNrcyIsIm9uY2UiLCJvZmYiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrcyIsImNiIiwic3BsaWNlIiwiYXJncyIsInNsaWNlIiwibGVuIiwibGlzdGVuZXJzIiwiaGFzTGlzdGVuZXJzIiwiaGFzQmluYXJ5IiwiaXNBcnJheSIsImwiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwid2l0aE5hdGl2ZUJsb2IiLCJCbG9iIiwid2l0aE5hdGl2ZUZpbGUiLCJGaWxlIiwidG9KU09OIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJ0b1N0cmluZyIsIkFycmF5IiwiYXJyIiwiX2RlY29uc3RydWN0UGFja2V0IiwicGxhY2Vob2xkZXIiLCJfcGxhY2Vob2xkZXIiLCJudW0iLCJuZXdEYXRhIiwiRGF0ZSIsIl9yZWNvbnN0cnVjdFBhY2tldCIsInBhY2tldERhdGEiLCJfcmVtb3ZlQmxvYnMiLCJjdXJLZXkiLCJjb250YWluaW5nT2JqZWN0IiwicGVuZGluZ0Jsb2JzIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInN1YnMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIkluZmluaXR5IiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJhbmRvbWl6YXRpb25GYWN0b3IiLCJiYWNrb2ZmIiwiQmFja29mZiIsIm1pbiIsIm1heCIsImppdHRlciIsInRpbWVvdXQiLCJyZWFkeVN0YXRlIiwiY29ubmVjdGluZyIsImxhc3RQaW5nIiwicGFja2V0QnVmZmVyIiwiX3BhcnNlciIsImVuY29kZXIiLCJkZWNvZGVyIiwiYXV0b0Nvbm5lY3QiLCJvcGVuIiwiZWlvIiwiYmluZCIsImhhcyIsImVtaXRBbGwiLCJ1cGRhdGVTb2NrZXRJZHMiLCJnZW5lcmF0ZUlkIiwiZW5naW5lIiwidiIsIl9yZWNvbm5lY3Rpb24iLCJfcmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJfcmVjb25uZWN0aW9uRGVsYXkiLCJzZXRNaW4iLCJfcmFuZG9taXphdGlvbkZhY3RvciIsInNldEppdHRlciIsIl9yZWNvbm5lY3Rpb25EZWxheU1heCIsInNldE1heCIsIl90aW1lb3V0IiwibWF5YmVSZWNvbm5lY3RPbk9wZW4iLCJyZWNvbm5lY3RpbmciLCJhdHRlbXB0cyIsInJlY29ubmVjdCIsInNlbGYiLCJza2lwUmVjb25uZWN0Iiwib3BlblN1YiIsIm9ub3BlbiIsImVycm9yU3ViIiwiY2xlYW51cCIsImVyciIsInRpbWVyIiwic2V0VGltZW91dCIsImNsb3NlIiwiY2xlYXJUaW1lb3V0Iiwib25waW5nIiwib25wb25nIiwib25kYXRhIiwib25kZWNvZGVkIiwib25lcnJvciIsIm9uQ29ubmVjdGluZyIsImluZGV4IiwiZW5jb2RlZFBhY2tldHMiLCJ3cml0ZSIsIm9wdGlvbnMiLCJwcm9jZXNzUGFja2V0UXVldWUiLCJzaGlmdCIsInN1YnNMZW5ndGgiLCJzdWIiLCJkaXNjb25uZWN0IiwicmVzZXQiLCJvbmNsb3NlIiwicmVhc29uIiwiZGVsYXkiLCJkdXJhdGlvbiIsIm9ucmVjb25uZWN0IiwiYXR0ZW1wdCIsImhvc3RuYW1lIiwic2VjdXJlIiwiYWdlbnQiLCJwYXJzZXFzIiwiZGVjb2RlIiwidXBncmFkZSIsImZvcmNlSlNPTlAiLCJqc29ucCIsImZvcmNlQmFzZTY0IiwiZW5hYmxlc1hEUiIsInRpbWVzdGFtcFBhcmFtIiwidGltZXN0YW1wUmVxdWVzdHMiLCJ0cmFuc3BvcnRzIiwidHJhbnNwb3J0T3B0aW9ucyIsIndyaXRlQnVmZmVyIiwicHJldkJ1ZmZlckxlbiIsInBvbGljeVBvcnQiLCJyZW1lbWJlclVwZ3JhZGUiLCJiaW5hcnlUeXBlIiwib25seUJpbmFyeVVwZ3JhZGVzIiwicGVyTWVzc2FnZURlZmxhdGUiLCJ0aHJlc2hvbGQiLCJwZngiLCJwYXNzcGhyYXNlIiwiY2VydCIsImNhIiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsImZvcmNlTm9kZSIsImZyZWVHbG9iYWwiLCJleHRyYUhlYWRlcnMiLCJrZXlzIiwibG9jYWxBZGRyZXNzIiwidXBncmFkZXMiLCJwaW5nSW50ZXJ2YWwiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbFRpbWVyIiwicGluZ1RpbWVvdXRUaW1lciIsImNsb25lIiwibyIsInBhcnNlanNvbiIsInByaW9yV2Vic29ja2V0U3VjY2VzcyIsIlRyYW5zcG9ydCIsImNyZWF0ZVRyYW5zcG9ydCIsIm5hbWUiLCJFSU8iLCJ0cmFuc3BvcnQiLCJzaWQiLCJyZXF1ZXN0VGltZW91dCIsInByb3RvY29scyIsInNldFRyYW5zcG9ydCIsIm9uRHJhaW4iLCJvblBhY2tldCIsIm9uRXJyb3IiLCJvbkNsb3NlIiwicHJvYmUiLCJvblRyYW5zcG9ydE9wZW4iLCJ1cGdyYWRlTG9zZXNCaW5hcnkiLCJzdXBwb3J0c0JpbmFyeSIsImZhaWxlZCIsInNlbmQiLCJtc2ciLCJ1cGdyYWRpbmciLCJwYXVzZSIsImZsdXNoIiwiZnJlZXplVHJhbnNwb3J0Iiwib25UcmFuc3BvcnRDbG9zZSIsIm9udXBncmFkZSIsInRvIiwib25PcGVuIiwib25IYW5kc2hha2UiLCJzZXRQaW5nIiwiY29kZSIsImZpbHRlclVwZ3JhZGVzIiwib25IZWFydGJlYXQiLCJwaW5nIiwic2VuZFBhY2tldCIsIndyaXRhYmxlIiwiY29tcHJlc3MiLCJjbGVhbnVwQW5kQ2xvc2UiLCJ3YWl0Rm9yVXBncmFkZSIsImRlc2MiLCJmaWx0ZXJlZFVwZ3JhZGVzIiwiaiIsInBvbGxpbmciLCJ4aHIiLCJ4ZCIsInhzIiwiaXNTU0wiLCJ4ZG9tYWluIiwieHNjaGVtZSIsIlhNTEh0dHBSZXF1ZXN0IiwiWEhSIiwiSlNPTlAiLCJ3ZWJzb2NrZXQiLCJoYXNDT1JTIiwiWERvbWFpblJlcXVlc3QiLCJjb25jYXQiLCJqb2luIiwiZW1wdHkiLCJQb2xsaW5nIiwiUmVxdWVzdCIsIm1ldGhvZCIsImFzeW5jIiwiaXNCaW5hcnkiLCJjcmVhdGUiLCJ1bmxvYWRIYW5kbGVyIiwicmVxdWVzdHMiLCJhYm9ydCIsImluaGVyaXQiLCJyZXF1ZXN0IiwiZG9Xcml0ZSIsInJlcSIsInNlbmRYaHIiLCJkb1BvbGwiLCJvbkRhdGEiLCJwb2xsWGhyIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhhc1hEUiIsIm9uTG9hZCIsInJlc3BvbnNlVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJyZXNwb25zZVR5cGUiLCJzdGF0dXMiLCJkb2N1bWVudCIsInJlcXVlc3RzQ291bnQiLCJvblN1Y2Nlc3MiLCJmcm9tRXJyb3IiLCJyZXNwb25zZSIsImF0dGFjaEV2ZW50IiwiaGFzWEhSMiIsInllYXN0IiwiZG9PcGVuIiwicG9sbCIsIm9uUGF1c2UiLCJ0b3RhbCIsImRlY29kZVBheWxvYWQiLCJkb0Nsb3NlIiwicGFja2V0cyIsImNhbGxiYWNrZm4iLCJlbmNvZGVQYXlsb2FkIiwic2NoZW1hIiwiYjY0IiwiZGVzY3JpcHRpb24iLCJkZWNvZGVQYWNrZXQiLCJlbmNvZGVCYXNlNjRPYmplY3QiLCJtZXNzYWdlIiwiZW5jb2RlQXJyYXlCdWZmZXIiLCJlbmNvZGVCYXNlNjRQYWNrZXQiLCJjb250ZW50QXJyYXkiLCJVaW50OEFycmF5IiwicmVzdWx0QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsImVuY29kZUJsb2JBc0FycmF5QnVmZmVyIiwiZnIiLCJlbmNvZGVQYWNrZXQiLCJlbmNvZGVCbG9iIiwiZG9udFNlbmRCbG9icyIsImJsb2IiLCJ0cnlEZWNvZGUiLCJ1dGY4Iiwic3RyaWN0IiwibWFwIiwiYXJ5IiwiZWFjaCIsImRvbmUiLCJhZnRlciIsImVhY2hXaXRoSW5kZXgiLCJlbCIsImJhc2U2NGVuY29kZXIiLCJzbGljZUJ1ZmZlciIsImlzQW5kcm9pZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzUGhhbnRvbUpTIiwicG9uZyIsIm5vb3AiLCJwYWNrZXRzbGlzdCIsInV0ZjhlbmNvZGUiLCJlbmNvZGVkIiwiU3RyaW5nIiwic3BsaXQiLCJyZWFkQXNEYXRhVVJMIiwiYjY0ZGF0YSIsImZyb21DaGFyQ29kZSIsInR5cGVkIiwiYmFzaWMiLCJidG9hIiwidXRmOGRlY29kZSIsImRlY29kZUJhc2U2NFBhY2tldCIsImFzQXJyYXkiLCJyZXN0Iiwic2V0TGVuZ3RoSGVhZGVyIiwiZW5jb2RlT25lIiwiZG9uZUNhbGxiYWNrIiwiZW5jb2RlUGF5bG9hZEFzQmxvYiIsImVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyIiwicmVzdWx0cyIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsIm4iLCJjaHIiLCJyZXQiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsImFjYyIsInJlc3VsdEFycmF5IiwiYnVmZmVySW5kZXgiLCJmb3JFYWNoIiwiaXNTdHJpbmciLCJhYiIsInZpZXciLCJjaGFyQ29kZUF0IiwibGVuU3RyIiwicGFyc2VJbnQiLCJiaW5hcnlJZGVudGlmaWVyIiwic2l6ZSIsImxlbmd0aEFyeSIsImJ1ZmZlclRhaWwiLCJ0YWlsQXJyYXkiLCJtc2dMZW5ndGgiLCJhcnJheWJ1ZmZlciIsInN0YXJ0IiwiZW5kIiwiYnl0ZXMiLCJhYnYiLCJpaSIsImNvdW50IiwiZXJyX2NiIiwicHJveHkiLCJiYWlsIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18iLCJ1Y3MyZGVjb2RlIiwic3RyaW5nIiwidmFsdWUiLCJleHRyYSIsIm91dHB1dCIsImNvdW50ZXIiLCJ1Y3MyZW5jb2RlIiwiYXJyYXkiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJjaGVja1NjYWxhclZhbHVlIiwiY29kZVBvaW50IiwidG9VcHBlckNhc2UiLCJjcmVhdGVCeXRlIiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwiY29kZVBvaW50cyIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJieXRlQXJyYXkiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInRtcCIsImZyZWVFeHBvcnRzIiwid2luZG93IiwidmVyc2lvbiIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJjaGFycyIsImVuY29kZWQxIiwiZW5jb2RlZDIiLCJlbmNvZGVkMyIsImVuY29kZWQ0IiwiYnVmZmVyTGVuZ3RoIiwibWFwQXJyYXlCdWZmZXJWaWV3cyIsImNodW5rIiwiY29weSIsInNldCIsImJ5dGVPZmZzZXQiLCJCbG9iQnVpbGRlckNvbnN0cnVjdG9yIiwiYmIiLCJCbG9iQnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJCbG9iQ29uc3RydWN0b3IiLCJXZWJLaXRCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsImJsb2JTdXBwb3J0ZWQiLCJhIiwiYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3IiwiYmxvYkJ1aWxkZXJTdXBwb3J0ZWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxcyIsInFyeSIsInBhaXJzIiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsImFscGhhYmV0IiwiTWF0aCIsImZsb29yIiwiZGVjb2RlZCIsIm5vdyIsInByZXYiLCJzZWVkIiwiSlNPTlBQb2xsaW5nIiwiX19fZWlvIiwic2NyaXB0Iiwick5ld2xpbmUiLCJyRXNjYXBlZE5ld2xpbmUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmb3JtIiwiaWZyYW1lIiwiY3JlYXRlRWxlbWVudCIsImluc2VydEF0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJoZWFkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiaXNVQWdlY2tvIiwiY29tcGxldGUiLCJpbml0SWZyYW1lIiwiaHRtbCIsImlmcmFtZUlkIiwiYXJlYSIsImNsYXNzTmFtZSIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwidGFyZ2V0Iiwic2V0QXR0cmlidXRlIiwiYWN0aW9uIiwic3VibWl0IiwiV1MiLCJ1c2luZ0Jyb3dzZXJXZWJTb2NrZXQiLCJCcm93c2VyV2ViU29ja2V0IiwiV2ViU29ja2V0IiwiTm9kZVdlYlNvY2tldCIsIk1veldlYlNvY2tldCIsImNoZWNrIiwiaGVhZGVycyIsIndzIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ubWVzc2FnZSIsImV2IiwicnZhbGlkY2hhcnMiLCJydmFsaWRlc2NhcGUiLCJydmFsaWR0b2tlbnMiLCJydmFsaWRicmFjZXMiLCJydHJpbUxlZnQiLCJydHJpbVJpZ2h0IiwiRnVuY3Rpb24iLCJqc29uIiwiaWRzIiwiYWNrcyIsInJlY2VpdmVCdWZmZXIiLCJzZW5kQnVmZmVyIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGVkIiwidG9BcnJheSIsImV2ZW50cyIsImNvbm5lY3RfZXJyb3IiLCJjb25uZWN0X3RpbWVvdXQiLCJyZWNvbm5lY3RfYXR0ZW1wdCIsInJlY29ubmVjdF9mYWlsZWQiLCJyZWNvbm5lY3RfZXJyb3IiLCJzdWJFdmVudHMiLCJmbGFncyIsInBvcCIsIm9ucGFja2V0Iiwib25jb25uZWN0Iiwib25ldmVudCIsIm9uYWNrIiwib25kaXNjb25uZWN0IiwiYWNrIiwic2VudCIsImVtaXRCdWZmZXJlZCIsImxpc3QiLCJtcyIsImZhY3RvciIsInBvdyIsInJhbmQiLCJyYW5kb20iLCJkZXZpYXRpb24iLCJFbWJvZGllZCIsImJvZHlfIiwiYXNzZXJ0QnJvd3NlckVudmlyb25tZW50IiwiYXNzZXJ0RGVmQW5kTm90TnVsbCIsImVycm9yTWVzc2FnZSIsImlzRGVmQW5kTm90TnVsbCIsImFzc2VydE5vdE51bGwiLCJpc051bGwiLCJhc3NlcnRGdW5jdGlvbiIsImlzRnVuY3Rpb24iLCJhc3NlcnRPYmplY3QiLCJpc09iamVjdCIsImFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIiwic3VjY2VlZGVkIiwiYXNzZXJ0VXNlclNpZ25lZEluIiwidXNlciIsImFzc2VydFVyaVdpdGhOb1BhdGgiLCJnZXRQYXRobmFtZSIsIkZpbHRlciIsImZpZWxkIiwib3BlcmF0b3JPclZhbHVlIiwib3B0X3ZhbHVlIiwib3BlcmF0b3IiLCJmaWVsZE9yRmlsdGVyIiwib3B0X29wZXJhdG9yT3JWYWx1ZSIsImZpbHRlciIsInRvRmlsdGVyIiwiZmlsdGVycyIsImFkZE1hbnkiLCJnZXRPYmplY3QiLCJ2YWx1ZXMiLCJib3hPclVwcGVyTGVmdCIsIm9wdF9sb3dlclJpZ2h0IiwiQm91bmRpbmdCb3giLCJwb2x5Z29uIiwiZ2V0UG9pbnRzIiwibG9jYXRpb25PckNpcmNsZSIsIm9wdF9yYW5nZU9yRGlzdGFuY2UiLCJyYW5nZSIsIkNpcmNsZSIsImdldENlbnRlciIsImdldFJhZGl1cyIsImRpc3RhbmNlSW50ZXJuYWxfIiwidG9Cb2R5IiwiZnJvbSIsImZpZWxkT3JRdWVyeSIsIm9wdF9xdWVyeU9yRnV6emluZXNzIiwib3B0X2Z1enppbmVzcyIsImZ1enp5SW50ZXJuYWxfIiwiYXJnMklzU3RyaW5nIiwiZnV6emluZXNzIiwiQUxMIiwib3B0X3F1ZXJ5IiwicG9pbnRzIiwicG9pbnQiLCJyYW5nZU9yTWluIiwib3B0X21heCIsInNoYXBlcyIsInNoYXBlIiwiZ2VvbWV0cmllcyIsImdsb2JhbHMiLCJRdWVyeSIsImFnZ3JlZ2F0aW9uT3JGaWVsZCIsIm9wdF9vcGVyYXRvciIsImFnZ3JlZ2F0aW9uIiwiZ2V0RmllbGQiLCJnZXRPcGVyYXRvciIsImdldFZhbHVlIiwib2Zmc2V0IiwiaGlnaGxpZ2h0IiwibGltaXQiLCJmaWx0ZXJPclRleHRPckZpZWxkIiwib3B0X3RleHRPck9wZXJhdG9yIiwibWF0Y2giLCJvcHRfZGlyZWN0aW9uIiwic29ydCIsInNvcnRFbnRyeSIsImFnZ3JlZ2F0ZSIsInNlYXJjaCIsIlJhbmdlIiwib3B0X3RvIiwiQXBpSGVscGVyIiwid2VkZXBsb3lDbGllbnQiLCJoZWFkZXJzXyIsImF1dGhPclRva2VuT3JFbWFpbCIsIm9wdF9wYXNzd29yZCIsImhlbHBlckF1dGhTY29wZSIsIkF1dGgiLCJ0b2tlbk9yRW1haWwiLCJ0b2tlbiIsImVtYWlsIiwicGFzc3dvcmQiLCJjcmVhdGVkQXQiLCJwaG90b1VybCIsInN1cHBvcnRlZFNjb3BlcyIsInNjb3BlcyIsImV2ZXJ5IiwidmFsIiwiZnJvbU9iamVjdCIsIm5hbWVzIiwiZ2V0QWxsIiwiYnVpbGRVcmxfIiwiZ2V0SWQiLCJhdXRoIiwicGF0Y2giLCJ0aGVuIiwiZGVsZXRlIiwiYXV0aFVybF8iLCJjcmVhdGVGcm9tRGF0YSIsInByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInNldFdlZGVwbG95Q2xpZW50IiwiQXV0aFByb3ZpZGVyIiwicHJvdmlkZXIiLCJwcm92aWRlclNjb3BlIiwicmVkaXJlY3RVcmkiLCJzY29wZSIsIm9wdF9hdXRoVXJsIiwic2V0UGF0aG5hbWUiLCJoYXNQcm92aWRlciIsInNldFBhcmFtZXRlclZhbHVlIiwiZ2V0UHJvdmlkZXIiLCJoYXNQcm92aWRlclNjb3BlIiwiZ2V0UHJvdmlkZXJTY29wZSIsImhhc1JlZGlyZWN0VXJpIiwiZ2V0UmVkaXJlY3RVcmkiLCJoYXNTY29wZSIsImdldFNjb3BlIiwiYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsIiwiR2VvIiwidXBwZXJMZWZ0IiwibG93ZXJSaWdodCIsImNlbnRlciIsInJhZGl1cyIsIkxpbmUiLCJsYXQiLCJsb24iLCJQb2ludCIsIlBvbHlnb24iLCJjb29yZGluYXRlcyIsImFkZENvb3JkaW5hdGVzXyIsIkNsaWVudE1lc3NhZ2UiLCJvcHRfYm9keSIsImlzRGVmIiwib3B0X2hlYWRlcnMiLCJGb3JtRGF0YUltcGwiLCJGb3JtRGF0YSIsIldlRGVwbG95IiwiYXV0aF8iLCJkYXRhXyIsInVybF8iLCJqb2luUGF0aHMiLCJwYXJhbXNfIiwid2l0aENyZWRlbnRpYWxzXyIsImhlYWRlciIsImNsaWVudFJlcXVlc3QiLCJwYXJhbSIsImZvcm1EYXRhXyIsInBhcmFtcyIsImNsaWVudFJlc3BvbnNlIiwiaXNDb250ZW50VHlwZUpzb24iLCJzZW5kQXN5bmMiLCJpc0VsZW1lbnQiLCJtYXliZVdyYXBXaXRoUXVlcnlfIiwiY29udmVydEJvZHlUb1BhcmFtc18iLCJyZW1vdmVCb2R5IiwicmVtb3ZlIiwiZW5jb2RlUGFyYW1zXyIsInJlc29sdmVBdXRoZW50aWNhdGlvbl8iLCJvcHRfcGFyYW1zIiwiZW1ib2RpZWQiLCJ1c2UiLCJjdXN0b21UcmFuc3BvcnRfIiwiaGFzVG9rZW4iLCJoYXNFbWFpbCIsImhhc1Bhc3N3b3JkIiwiY3JlZGVudGlhbHMiLCJlbmNvZGVTdHJpbmciLCJpbnN0YW5jZSIsImdldERlZmF1bHQiLCJjcmVhdGVDbGllbnRSZXF1ZXN0XyIsIm9wdF9vcHRpb25zIiwiYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcCIsInByb2R1Y3QiLCJnZXRTZWFyY2giLCJnZXRQcm90b2NvbCIsImdldEhvc3QiLCJvcHRfZGF0YVVybCIsImRhdGFVcmxfIiwiY3VycmVudFVzZXIiLCJvcHRfZW1haWxVcmwiLCJlbWFpbFVybF8iLCJlbWFpbF8iLCJjbGllbnRNZXNzYWdlIiwiZ2V0IiwiZm9ybURhdGEiLCJBZ2dyZWdhdGlvbiIsImZpZWxkXyIsIm9wZXJhdG9yXyIsInZhbHVlXyIsInJhbmdlcyIsIkRpc3RhbmNlQWdncmVnYXRpb24iLCJpbnRlcnZhbCIsIlJhbmdlQWdncmVnYXRpb24iLCJyYW5nZU9yRnJvbSIsInVuaXQiLCJGaWx0ZXJCb2R5IiwiY3JlYXRlQm9keV8iLCJvcHRfZmlsdGVyIiwiYWRkQXJyYXlPcGVyYXRvcl8iLCJDbGllbnRSZXF1ZXN0Iiwib3B0X3dpdGhDcmVkZW50aWFscyIsIm9wdF9tZXRob2QiLCJtZXRob2RfIiwiREVGQVVMVF9NRVRIT0QiLCJvcHRfdXJsIiwiQ2xpZW50UmVzcG9uc2UiLCJjbGllbnRSZXF1ZXN0XyIsIm9wdF9zdGF0dXNDb2RlIiwic3RhdHVzQ29kZV8iLCJvcHRfc3RhdHVzVGV4dCIsInN0YXR1c1RleHRfIiwic3RhdHVzQ29kZSIsIlRyYW5zcG9ydEZhY3RvcnkiLCJERUZBVUxUX1RSQU5TUE9SVF9OQU1FIiwiaW1wbGVtZW50YXRpb25OYW1lIiwiVHJhbnNwb3J0Q2xhc3MiLCJpbnN0YW5jZV8iLCJBdXRoQXBpSGVscGVyIiwib25TaWduSW5DYWxsYmFjayIsIm9uU2lnbk91dENhbGxiYWNrIiwiaXNTdXBwb3J0ZWQiLCJzdG9yYWdlIiwicHJvY2Vzc1NpZ25Jbl8iLCJGYWNlYm9vayIsIkdvb2dsZSIsIkdpdGh1YiIsImFjY2Vzc1Rva2VuIiwiY29va2llIiwiYXV0aFNjb3BlIiwicmVzb2x2ZUF1dGhTY29wZSIsInBvc3QiLCJjcmVhdGVBdXRoRnJvbURhdGEiLCJwYXRobmFtZSIsImZyYWdtZW50IiwiaGFzaCIsInVzZXJJZCIsInZlcmlmeVVzZXIiLCJjcmVhdGVBY2Nlc3NUb2tlbkNvb2tpZSIsImdldFRva2VuIiwicmVkaXJlY3RBY2Nlc3NUb2tlbiIsImdldFJlZGlyZWN0QWNjZXNzVG9rZW5fIiwicmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XyIsImxvYWRDdXJyZW50VXNlciIsIm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsImFjY2Vzc190b2tlbiIsImFzc2VydFN1cHBvcnRlZFByb3ZpZGVyIiwic2V0UmVkaXJlY3RVcmkiLCJnZXRIcmVmV2l0aG91dEZyYWdtZW50XyIsIm1ha2VBdXRob3JpemF0aW9uVXJsIiwibWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfIiwidW5sb2FkQ3VycmVudFVzZXJfIiwiZGVsZXRlQWNjZXNzVG9rZW5Db29raWUiLCJQUk9WSURFUiIsIkZhY2Vib29rQXV0aFByb3ZpZGVyIiwiR2l0aHViQXV0aFByb3ZpZGVyIiwiR29vZ2xlQXV0aFByb3ZpZGVyIiwiQWpheFRyYW5zcG9ydCIsImRlZmVycmVkIiwic3RhdHVzVGV4dCIsInBhcnNlUmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiRGF0YUFwaUhlbHBlciIsImlzU2VhcmNoXyIsImdldE9yQ3JlYXRlRmlsdGVyXyIsImFuZCIsIm9yIiwid2hlcmUiLCJub25lIiwicHJlZml4Iiwic2ltaWxhciIsImx0IiwibHRlIiwiYW55IiwiYm91bmRpbmdCb3giLCJkaXN0YW5jZSIsImdldE9yQ3JlYXRlUXVlcnlfIiwiY29sbGVjdGlvbiIsImRvYyIsInB1dCIsInByb2Nlc3NBbmRSZXNldFF1ZXJ5U3RhdGUiLCJ3YXRjaCIsImZpbHRlcl8iLCJxdWVyeV8iLCJjbGVhciIsIkVtYWlsQXBpSGVscGVyIiwiYmNjIiwiY2MiLCJwcmlvcml0eSIsInJlcGx5VG8iLCJzdWJqZWN0IiwiY2xpZW50IiwiZW1haWxJZCIsIkJhc2U2NCJdLCJtYXBwaW5ncyI6IkNBQUEsU0FBQUEsRUFBQUMsR0FDQSxnQkFBQUMsVUFBQSxnQkFBQUMsUUFDQUEsT0FBQUQsUUFBQUQsSUFDQSxrQkFBQUcsZ0JBQUFDLElBQ0FELFVBQUFILEdBQ0EsZ0JBQUFDLFNBQ0FBLFFBQUEsR0FBQUQsSUFFQUQsRUFBQSxHQUFBQyxLQUNDSyxLQUFBLFdBQ0QsTUNBZ0IsVUFBVUMsR0NOMUIsUUFBQUMsR0FBQUMsR0FHQSxHQUFBQyxFQUFBRCxHQUNBLE1BQUFDLEdBQUFELEdBQUFQLE9BR0EsSUFBQUMsR0FBQU8sRUFBQUQsSUFDQVAsV0FDQVMsR0FBQUYsRUFDQUcsUUFBQSxFQVVBLE9BTkFMLEdBQUFFLEdBQUFJLEtBQUFWLEVBQUFELFFBQUFDLElBQUFELFFBQUFN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QSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7O0FDdkx0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FB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QUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzV2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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MENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3pMRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hELDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM3RCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0E3RWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcGkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImlvXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImlvXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXHRcblx0LyoqXG5cdCAqIE1hbmFnZXJzIGNhY2hlLlxuXHQgKi9cblx0XG5cdHZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblx0XG5cdC8qKlxuXHQgKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cblx0ICogSWYgdGhlIHVzZXIgc3VtbW9uczpcblx0ICpcblx0ICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2Bcblx0ICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2Bcblx0ICpcblx0ICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcblx0ICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuXHQgIGlmICgodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICBvcHRzID0gdXJpO1xuXHQgICAgdXJpID0gdW5kZWZpbmVkO1xuXHQgIH1cblx0XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdFxuXHQgIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcblx0ICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcblx0ICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG5cdCAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcblx0ICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuXHQgIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8IGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXHRcblx0ICB2YXIgaW87XG5cdFxuXHQgIGlmIChuZXdDb25uZWN0aW9uKSB7XG5cdFxuXHQgICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICghY2FjaGVbaWRdKSB7XG5cdFxuXHQgICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG5cdCAgICB9XG5cdCAgICBpbyA9IGNhY2hlW2lkXTtcblx0ICB9XG5cdCAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuXHQgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcblx0ICB9XG5cdCAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cdFxuXHQvKipcblx0ICogYGNvbm5lY3RgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJpXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5NYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdGV4cG9ydHMuU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cdFxuXHR2YXIgcGFyc2V1cmkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gdXJsO1xuXHRcblx0LyoqXG5cdCAqIFVSTCBwYXJzZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0ICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gdXJsKHVyaSwgbG9jKSB7XG5cdCAgdmFyIG9iaiA9IHVyaTtcblx0XG5cdCAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cblx0ICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuXHQgIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXHRcblx0ICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcblx0ICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcblx0ICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcblx0ICAgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgxKSkge1xuXHQgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG5cdFxuXHQgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcblx0ICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyBwYXJzZVxuXHRcblx0ICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG5cdCAgfVxuXHRcblx0ICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcblx0ICBpZiAoIW9iai5wb3J0KSB7XG5cdCAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0ICAgICAgb2JqLnBvcnQgPSAnODAnO1xuXHQgICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0ICAgICAgb2JqLnBvcnQgPSAnNDQzJztcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXHRcblx0ICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblx0XG5cdCAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuXHQgIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuXHQgIC8vIGRlZmluZSBocmVmXG5cdCAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogJzonICsgb2JqLnBvcnQpO1xuXHRcblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXHJcblx0ICogUGFyc2VzIGFuIFVSSVxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdHZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cdFxyXG5cdHZhciBwYXJ0cyA9IFtcclxuXHQgICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcblx0XTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG5cdCAgICB2YXIgc3JjID0gc3RyLFxyXG5cdCAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXHJcblx0ICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHRcclxuXHQgICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG5cdCAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuXHQgICAgICAgIHVyaSA9IHt9LFxyXG5cdCAgICAgICAgaSA9IDE0O1xyXG5cdFxyXG5cdCAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcblx0ICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG5cdCAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xyXG5cdCAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuXHQgICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdXJpO1xyXG5cdH07XHJcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1wYXJzZXInKTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgaGFzQmluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGJpbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdHZhciBpc0J1ZiA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdFxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRleHBvcnRzLnByb3RvY29sID0gNDtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy50eXBlcyA9IFtcblx0ICAnQ09OTkVDVCcsXG5cdCAgJ0RJU0NPTk5FQ1QnLFxuXHQgICdFVkVOVCcsXG5cdCAgJ0FDSycsXG5cdCAgJ0VSUk9SJyxcblx0ICAnQklOQVJZX0VWRU5UJyxcblx0ICAnQklOQVJZX0FDSydcblx0XTtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5DT05ORUNUID0gMDtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuRVZFTlQgPSAyO1xuXHRcblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBhY2tgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuQUNLID0gMztcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuRVJST1IgPSA0O1xuXHRcblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXHRcblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cdFxuXHQvKipcblx0ICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRleHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXHRcblx0LyoqXG5cdCAqIERlY29kZXIgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5EZWNvZGVyID0gRGVjb2Rlcjtcblx0XG5cdC8qKlxuXHQgKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cdFxuXHQvKipcblx0ICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG5cdCAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG5cdCAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3Ncblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcblx0ICBpZiAoKG9iai50eXBlID09PSBleHBvcnRzLkVWRU5UIHx8IG9iai50eXBlID09PSBleHBvcnRzLkFDSykgJiYgaGFzQmluKG9iai5kYXRhKSkge1xuXHQgICAgb2JqLnR5cGUgPSBvYmoudHlwZSA9PT0gZXhwb3J0cy5FVkVOVCA/IGV4cG9ydHMuQklOQVJZX0VWRU5UIDogZXhwb3J0cy5CSU5BUllfQUNLO1xuXHQgIH1cblx0XG5cdFxuXHRcblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcblx0ICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG5cdCAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXHRcblx0ICAvLyBmaXJzdCBpcyB0eXBlXG5cdCAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cdFxuXHQgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuXHQgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuXHQgICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcblx0ICB9XG5cdFxuXHQgIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2Bcblx0ICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcblx0ICBpZiAob2JqLm5zcCAmJiAnLycgIT09IG9iai5uc3ApIHtcblx0ICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuXHQgIH1cblx0XG5cdCAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG5cdCAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG5cdCAgICBzdHIgKz0gb2JqLmlkO1xuXHQgIH1cblx0XG5cdCAgLy8ganNvbiBkYXRhXG5cdCAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcblx0ICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmouZGF0YSk7XG5cdCAgfVxuXHRcblx0XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuXHQgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG5cdCAqIGEgbGlzdCBvZiBidWZmZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cdFxuXHQgIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG5cdCAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcblx0ICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcblx0ICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblx0XG5cdCAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG5cdCAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG5cdCAgfVxuXHRcblx0ICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2Vcblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gRGVjb2RlcigpIHtcblx0ICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHREZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcblx0ICB2YXIgcGFja2V0O1xuXHQgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHQgICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG5cdCAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cblx0ICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblx0XG5cdCAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG5cdCAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuXHQgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG5cdCAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG5cdCAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG5cdCAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuXHQgIHZhciBpID0gMDtcblx0ICAvLyBsb29rIHVwIHR5cGVcblx0ICB2YXIgcCA9IHtcblx0ICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKVxuXHQgIH07XG5cdFxuXHQgIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cdFxuXHQgIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuXHQgICAgdmFyIGJ1ZiA9ICcnO1xuXHQgICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG5cdCAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0ICAgIH1cblx0ICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuXHQgICAgfVxuXHQgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuXHQgIH1cblx0XG5cdCAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcblx0ICBpZiAoJy8nID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuXHQgICAgcC5uc3AgPSAnJztcblx0ICAgIHdoaWxlICgrK2kpIHtcblx0ICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoJywnID09PSBjKSBicmVhaztcblx0ICAgICAgcC5uc3AgKz0gYztcblx0ICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBwLm5zcCA9ICcvJztcblx0ICB9XG5cdFxuXHQgIC8vIGxvb2sgdXAgaWRcblx0ICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuXHQgIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuXHQgICAgcC5pZCA9ICcnO1xuXHQgICAgd2hpbGUgKCsraSkge1xuXHQgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdCAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcblx0ICAgICAgICAtLWk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuXHQgIH1cblx0XG5cdCAgLy8gbG9vayB1cCBqc29uIGRhdGFcblx0ICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG5cdCAgICBwID0gdHJ5UGFyc2UocCwgc3RyLnN1YnN0cihpKSk7XG5cdCAgfVxuXHRcblx0XG5cdCAgcmV0dXJuIHA7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuXHQgIHRyeSB7XG5cdCAgICBwLmRhdGEgPSBKU09OLnBhcnNlKHN0cik7XG5cdCAgfSBjYXRjaChlKXtcblx0ICAgIHJldHVybiBlcnJvcigpO1xuXHQgIH1cblx0ICByZXR1cm4gcDsgXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdERlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdCAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG5cdCAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG5cdCAqIGRlY29kZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuXHQgIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuXHQgIHRoaXMuYnVmZmVycyA9IFtdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuXHQgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG5cdCAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG5cdCAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcblx0ICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcblx0ICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG5cdCAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuXHQgICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG5cdCAgICByZXR1cm4gcGFja2V0O1xuXHQgIH1cblx0ICByZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdEJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG5cdCAgdGhpcy5idWZmZXJzID0gW107XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBlcnJvcigpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgdHlwZTogZXhwb3J0cy5FUlJPUixcblx0ICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG5cdCAgfTtcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcblx0ICovXHJcblx0XHJcblx0aWYgKHRydWUpIHtcclxuXHQgIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcblx0ICpcclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cdFxyXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcblx0ICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xyXG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcblx0ICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBvYmo7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcblx0ICogQGFwaSBwdWJsaWNcclxuXHQgKi9cclxuXHRcclxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblx0ICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcblx0ICAgIC5wdXNoKGZuKTtcclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcblx0ICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cdFxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG5cdCAgZnVuY3Rpb24gb24oKSB7XHJcblx0ICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcblx0ICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBvbi5mbiA9IGZuO1xyXG5cdCAgdGhpcy5vbihldmVudCwgb24pO1xyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblx0XHJcblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHRcclxuXHQgIC8vIGFsbFxyXG5cdCAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuXHQgICAgcmV0dXJuIHRoaXM7XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyBzcGVjaWZpYyBldmVudFxyXG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblx0XHJcblx0ICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcblx0ICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0ICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH1cclxuXHRcclxuXHQgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcblx0ICB2YXIgY2I7XHJcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuXHQgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuXHQgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgIGJyZWFrO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0ICByZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKi9cclxuXHRcclxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cdCAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuXHQgICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cdFxyXG5cdCAgaWYgKGNhbGxiYWNrcykge1xyXG5cdCAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblx0XHJcblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cdCAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblx0XHJcblx0RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcblx0fTtcclxuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cdFxuXHQvKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblx0XG5cdHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBnbG9iYWwuQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5CbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG5cdHZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBnbG9iYWwuRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5GaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cdFxuXHQvKipcblx0ICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cblx0ICpcblx0ICogU3VwcG9ydHMgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQmxvYiBhbmQgRmlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gaGFzQmluYXJ5IChvYmopIHtcblx0ICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgaWYgKGlzQXJyYXkob2JqKSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHRcblx0ICBpZiAoKHR5cGVvZiBnbG9iYWwuQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHQgICAgICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuXHQgICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHQgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuXHQgICAgKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdFxuXHQgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcblx0ICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG5cdCAgfVxuXHRcblx0ICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cdFxuXHQvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50c1xuXHQgKi9cblx0XG5cdHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIGlzQnVmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGdsb2JhbC5CbG9iID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcblx0dmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblx0XG5cdC8qKlxuXHQgKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuXHQgKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG5cdCAqIGhlcmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuXHQgIHZhciBidWZmZXJzID0gW107XG5cdCAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblx0ICB2YXIgcGFjayA9IHBhY2tldDtcblx0ICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG5cdCAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcblx0ICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuXHQgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cdFxuXHQgIGlmIChpc0J1ZihkYXRhKSkge1xuXHQgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcblx0ICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcblx0ICAgIHJldHVybiBwbGFjZWhvbGRlcjtcblx0ICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcblx0ICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld0RhdGE7XG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcblx0ICAgIHZhciBuZXdEYXRhID0ge307XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHQgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXdEYXRhO1xuXHQgIH1cblx0ICByZXR1cm4gZGF0YTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcblx0ICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcblx0ICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcblx0ICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG5cdCAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG5cdCAgcmV0dXJuIHBhY2tldDtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG5cdCAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblx0XG5cdCAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcblx0ICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG5cdCAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcblx0ICAgIH1cblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZGF0YTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuXHQgKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuXHQgKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHQgIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuXHQgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cdFxuXHQgICAgLy8gY29udmVydCBhbnkgYmxvYlxuXHQgICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHQgICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuXHQgICAgICBwZW5kaW5nQmxvYnMrKztcblx0XG5cdCAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcblx0ICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHQgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuXHQgICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG5cdCAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuXHQgICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG5cdCAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3Rcblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcblx0ICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcblx0ICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcblx0ICBpZiAoIXBlbmRpbmdCbG9icykge1xuXHQgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1Zjtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBpc0J1ZihvYmopIHtcblx0ICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHQgICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcblx0fVxuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIGVpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcblx0dmFyIGluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblx0dmFyIEJhY2tvZmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0XG5cdC8qKlxuXHQgKiBJRTYrIGhhc093blByb3BlcnR5XG5cdCAqL1xuXHRcblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHNcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cdFxuXHQvKipcblx0ICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcblx0ICBpZiAodXJpICYmICdvYmplY3QnID09PSAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcblx0ICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuXHQgIHRoaXMubnNwcyA9IHt9O1xuXHQgIHRoaXMuc3VicyA9IFtdO1xuXHQgIHRoaXMub3B0cyA9IG9wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG5cdCAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuXHQgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcblx0ICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuXHQgICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG5cdCAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG5cdCAgfSk7XG5cdCAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMudXJpID0gdXJpO1xuXHQgIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXHQgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuXHQgIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuXHQgIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcblx0ICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG5cdCAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuXHQgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcblx0ICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcblx0ICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdCAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG5cdCAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogbnNwICsgJyMnKSArIHRoaXMuZW5naW5lLmlkO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG5cdCAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcblx0ICB0aGlzLl90aW1lb3V0ID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3Rcblx0ICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3Rpbmdcblx0ICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcblx0ICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3Bcblx0ICAgIHRoaXMucmVjb25uZWN0KCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLm9wZW4gPSBNYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG5cdFxuXHQgIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXHRcblx0ICAvLyBlbWl0IGBvcGVuYFxuXHQgIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25vcGVuKCk7XG5cdCAgICBmbiAmJiBmbigpO1xuXHQgIH0pO1xuXHRcblx0ICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuXHQgIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGRhdGEpIHtcblx0XG5cdCAgICBzZWxmLmNsZWFudXAoKTtcblx0ICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG5cdCAgICBpZiAoZm4pIHtcblx0ICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuXHQgICAgICBlcnIuZGF0YSA9IGRhdGE7XG5cdCAgICAgIGZuKGVycik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuXHQgICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcblx0ICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcblx0ICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblx0XG5cdCAgICAvLyBzZXQgdGltZXJcblx0ICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcblx0ICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG5cdCAgICAgIHNvY2tldC5jbG9zZSgpO1xuXHQgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuXHQgICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuXHQgICAgfSwgdGltZW91dCk7XG5cdFxuXHQgICAgdGhpcy5zdWJzLnB1c2goe1xuXHQgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG5cdCAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXHRcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICAvLyBjbGVhciBvbGQgc3Vic1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHRcblx0ICAvLyBtYXJrIGFzIG9wZW5cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdFxuXHQgIC8vIGFkZCBuZXcgc3Vic1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG5cdCAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XG5cdCAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcblx0ICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG5cdCAgaWYgKCFzb2NrZXQpIHtcblx0ICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcblx0ICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcblx0ICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuXHQgICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG5cdCAgICAgIG9uQ29ubmVjdGluZygpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuXHQgICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcblx0ICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIHJldHVybiBzb2NrZXQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuXHQgIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuXHQgIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cdFxuXHQgIHRoaXMuY2xvc2UoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHRcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cdFxuXHQgIGlmICghc2VsZi5lbmNvZGluZykge1xuXHQgICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuXHQgICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG5cdCAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuXHQgICAgICB9XG5cdCAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuXHQgICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuXHQgKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcblx0ICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcblx0ICAgIHRoaXMucGFja2V0KHBhY2spO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgdmFyIHN1YnNMZW5ndGggPSB0aGlzLnN1YnMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG5cdCAgICBzdWIuZGVzdHJveSgpO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cdFxuXHQgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IE1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2Vcblx0ICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcblx0ICAgIHRoaXMuY2xlYW51cCgpO1xuXHQgIH1cblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcblx0ICB0aGlzLmNsZWFudXAoKTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblx0XG5cdCAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG5cdCAgICB0aGlzLnJlY29ubmVjdCgpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0XG5cdCAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuXHRcblx0ICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG5cdCAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcblx0XG5cdCAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG5cdCAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXHRcblx0ICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cdCAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblx0XG5cdCAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuXHQgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cdFxuXHQgICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgIGlmIChlcnIpIHtcblx0XG5cdCAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcblx0ICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LCBkZWxheSk7XG5cdFxuXHQgICAgdGhpcy5zdWJzLnB1c2goe1xuXHQgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuXHQgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdFxuXHQvKipcblx0ICogRXhwb3J0cyBwYXJzZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICpcblx0ICovXG5cdG1vZHVsZS5leHBvcnRzLnBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIHRyYW5zcG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xuXHR2YXIgaW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHR2YXIgcGFyc2V1cmkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgcGFyc2Vqc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cdHZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cdFxuXHQvKipcblx0ICogU29ja2V0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblx0XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdFxuXHQgIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgaWYgKHVyaSkge1xuXHQgICAgdXJpID0gcGFyc2V1cmkodXJpKTtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcblx0ICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG5cdCAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcblx0ICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG5cdCAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG5cdCAgfVxuXHRcblx0ICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuXHQgICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cdFxuXHQgIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcblx0ICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcblx0ICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcblx0ICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcblx0ICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0XG5cdCAgICAgID8gbG9jYXRpb24ucG9ydFxuXHQgICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG5cdCAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG5cdCAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuXHQgIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG5cdCAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG5cdCAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG5cdCAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXHQgIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG5cdCAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuXHQgIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuXHQgIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG5cdCAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuXHQgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcblx0ICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXHQgIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG5cdCAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcblx0ICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuXHQgIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG5cdCAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cdFxuXHQgIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG5cdCAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuXHQgIH1cblx0XG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cdFxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdCAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG5cdCAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcblx0ICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICAgIH1cblx0XG5cdCAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcblx0ICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8vIHNldCBvbiBoYW5kc2hha2Vcblx0ICB0aGlzLmlkID0gbnVsbDtcblx0ICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcblx0ICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG5cdCAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cdFxuXHQgIC8vIHNldCBvbiBoZWFydGJlYXRcblx0ICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcblx0ICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXHRcblx0ICB0aGlzLm9wZW4oKTtcblx0fVxuXHRcblx0U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXHRcblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblx0XG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblx0XG5cdC8qKlxuXHQgKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcblx0ICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG5cdCAqL1xuXHRcblx0U29ja2V0LlNvY2tldCA9IFNvY2tldDtcblx0U29ja2V0LlRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHRTb2NrZXQudHJhbnNwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRTb2NrZXQucGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuXHQgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XG5cdCAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cdFxuXHQgIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuXHQgIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblx0XG5cdCAgLy8gdHJhbnNwb3J0IG5hbWVcblx0ICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXHRcblx0ICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcblx0ICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSB8fCB7fTtcblx0XG5cdCAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG5cdCAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cdFxuXHQgIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG5cdCAgICBxdWVyeTogcXVlcnksXG5cdCAgICBzb2NrZXQ6IHRoaXMsXG5cdCAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuXHQgICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcblx0ICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG5cdCAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuXHQgICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcblx0ICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG5cdCAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuXHQgICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcblx0ICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG5cdCAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuXHQgICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcblx0ICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG5cdCAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuXHQgICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcblx0ICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG5cdCAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuXHQgICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcblx0ICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG5cdCAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcblx0ICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG5cdCAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuXHQgICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcblx0ICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG5cdCAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApXG5cdCAgfSk7XG5cdFxuXHQgIHJldHVybiB0cmFuc3BvcnQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjbG9uZSAob2JqKSB7XG5cdCAgdmFyIG8gPSB7fTtcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xuXHQgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICBvW2ldID0gb2JqW2ldO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbztcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHRyYW5zcG9ydDtcblx0ICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG5cdCAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0Jztcblx0ICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0ICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG5cdCAgfVxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblx0XG5cdCAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuXHQgIHRyeSB7XG5cdCAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuXHQgICAgdGhpcy5vcGVuKCk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICB0cmFuc3BvcnQub3BlbigpO1xuXHQgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuXHRcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuXHRcblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHQgIH1cblx0XG5cdCAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuXHQgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXHRcblx0ICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuXHQgIHRyYW5zcG9ydFxuXHQgIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLm9uRHJhaW4oKTtcblx0ICB9KVxuXHQgIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH0pXG5cdCAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoZSk7XG5cdCAgfSlcblx0ICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuXHQgICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XG5cdCAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG5cdCAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0XG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXHRcblx0ICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuXHQgICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG5cdCAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcblx0ICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcblx0ICAgIH1cblx0ICAgIGlmIChmYWlsZWQpIHJldHVybjtcblx0XG5cdFxuXHQgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcblx0ICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG5cdCAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcblx0ICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcblx0XG5cdCAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcblx0ICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuXHQgICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cdFxuXHRcblx0ICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cdCAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHRcblx0XG5cdCAgICAgICAgICBjbGVhbnVwKCk7XG5cdFxuXHQgICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0ICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG5cdCAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuXHQgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcblx0ICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG5cdCAgICAgICAgICBzZWxmLmZsdXNoKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG5cdCAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuXHQgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXHRcblx0ICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuXHQgICAgZmFpbGVkID0gdHJ1ZTtcblx0XG5cdCAgICBjbGVhbnVwKCk7XG5cdFxuXHQgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG5cdCAgICB0cmFuc3BvcnQgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuXHQgIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuXHQgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG5cdCAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblx0XG5cdCAgICBmcmVlemVUcmFuc3BvcnQoKTtcblx0XG5cdFxuXHRcblx0ICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG5cdCAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG5cdCAgfVxuXHRcblx0ICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcblx0ICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcblx0ICB9XG5cdFxuXHQgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuXHQgICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuXHRcblx0ICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG5cdCAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG5cdCAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdCAgfVxuXHRcblx0ICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cdFxuXHQgIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblx0ICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdFxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcblx0ICB0aGlzLmVtaXQoJ29wZW4nKTtcblx0ICB0aGlzLmZsdXNoKCk7XG5cdFxuXHQgIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcblx0ICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogSGFuZGxlcyBhIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcblx0ICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0XG5cdFxuXHQgICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHRcblx0ICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcblx0ICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cdFxuXHQgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuXHQgICAgICBjYXNlICdvcGVuJzpcblx0ICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuXHQgICAgICAgIGJyZWFrO1xuXHRcblx0ICAgICAgY2FzZSAncG9uZyc6XG5cdCAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG5cdCAgICAgICAgYnJlYWs7XG5cdFxuXHQgICAgICBjYXNlICdlcnJvcic6XG5cdCAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG5cdCAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcblx0ICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcblx0ICAgICAgICBicmVhaztcblx0XG5cdCAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuXHQgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuXHQgIHRoaXMuaWQgPSBkYXRhLnNpZDtcblx0ICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcblx0ICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcblx0ICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuXHQgIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuXHQgIHRoaXMub25PcGVuKCk7XG5cdCAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuXHQgIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgdGhpcy5zZXRQaW5nKCk7XG5cdFxuXHQgIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuXHQgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHQgIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuXHQgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuXHQgIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG5cdCAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuXHQgIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICBzZWxmLnBpbmcoKTtcblx0ICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG5cdCAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCogU2VuZHMgYSBwaW5nIHBhY2tldC5cblx0KlxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblx0XG5cdCAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuXHQgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuXHQgIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG5cdCAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblx0XG5cdCAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuZmx1c2goKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogRmx1c2ggd3JpdGUgYnVmZmVycy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuXHQgICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdFxuXHQgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcblx0ICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcblx0ICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuXHQgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG5cdCAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5cdFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG5cdCAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2VuZHMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG5cdCAgICBmbiA9IGRhdGE7XG5cdCAgICBkYXRhID0gdW5kZWZpbmVkO1xuXHQgIH1cblx0XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG5cdCAgICBmbiA9IG9wdGlvbnM7XG5cdCAgICBvcHRpb25zID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIGlmICgnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cdFxuXHQgIHZhciBwYWNrZXQgPSB7XG5cdCAgICB0eXBlOiB0eXBlLFxuXHQgICAgZGF0YTogZGF0YSxcblx0ICAgIG9wdGlvbnM6IG9wdGlvbnNcblx0ICB9O1xuXHQgIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcblx0ICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG5cdCAgdGhpcy5mbHVzaCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblx0XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdCAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjbG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdCAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjbG9zZSgpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY2xvc2UgKCkge1xuXHQgICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcblx0XG5cdCAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlICgpIHtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIGNsb3NlKCk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSAoKSB7XG5cdCAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuXHQgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdFxuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFxuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0ICAgIC8vIGNsZWFyIHRpbWVyc1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cdFxuXHQgICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG5cdCAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cdFxuXHQgICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cblx0ICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cdFxuXHQgICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHRcblx0ICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuXHQgICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdFxuXHQgICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuXHQgICAgdGhpcy5pZCA9IG51bGw7XG5cdFxuXHQgICAgLy8gZW1pdCBjbG9zZSBldmVudFxuXHQgICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cdFxuXHQgICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG5cdCAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcblx0ICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcblx0ICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuXHQgIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0ICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG5cdCAgfVxuXHQgIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xuXHR9O1xuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG5cdCAqL1xuXHRcblx0dmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdHZhciBYSFIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0dmFyIEpTT05QID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdHZhciB3ZWJzb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblx0XG5cdC8qKlxuXHQgKiBFeHBvcnQgdHJhbnNwb3J0cy5cblx0ICovXG5cdFxuXHRleHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuXHRleHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblx0XG5cdC8qKlxuXHQgKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cblx0ICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcblx0ICB2YXIgeGhyO1xuXHQgIHZhciB4ZCA9IGZhbHNlO1xuXHQgIHZhciB4cyA9IGZhbHNlO1xuXHQgIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXHRcblx0ICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG5cdCAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cdFxuXHQgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXHQgICAgaWYgKCFwb3J0KSB7XG5cdCAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuXHQgICAgfVxuXHRcblx0ICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuXHQgICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG5cdCAgfVxuXHRcblx0ICBvcHRzLnhkb21haW4gPSB4ZDtcblx0ICBvcHRzLnhzY2hlbWUgPSB4cztcblx0ICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cdFxuXHQgIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcblx0ICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG5cdCAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuXHQgIH1cblx0fVxuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cdFxuXHR2YXIgaGFzQ09SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHQgIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXHRcblx0ICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3Rcblx0ICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cdCAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cdFxuXHQgIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG5cdCAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cdFxuXHQgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuXHQgIHRyeSB7XG5cdCAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXHRcblx0ICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcblx0ICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuXHQgIHRyeSB7XG5cdCAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG5cdCAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7IH1cblx0XG5cdCAgaWYgKCF4ZG9tYWluKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gbmV3IGdsb2JhbFtbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHsgfVxuXHQgIH1cblx0fTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqXG5cdCAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuXHQgKlxuXHQgKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcblx0ICovXG5cdFxuXHR0cnkge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHQgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcblx0ICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXHR9XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cdFxuXHR2YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0dmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgaW5oZXJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5cdG1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXHRcblx0LyoqXG5cdCAqIEVtcHR5IGZ1bmN0aW9uXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gZW1wdHkgKCkge31cblx0XG5cdC8qKlxuXHQgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBYSFIgKG9wdHMpIHtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cdCAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0XG5cdCAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuXHQgICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuXHQgICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXHRcblx0ICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcblx0ICAgIGlmICghcG9ydCkge1xuXHQgICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcblx0ICAgIH1cblx0XG5cdCAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG5cdCAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcblx0ICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG5cdCAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuXHQgKi9cblx0XG5cdGluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblx0XG5cdC8qKlxuXHQgKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG5cdCAqL1xuXHRcblx0WEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJlcXVlc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2Rcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0WEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblx0ICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG5cdCAgb3B0cy54ZCA9IHRoaXMueGQ7XG5cdCAgb3B0cy54cyA9IHRoaXMueHM7XG5cdCAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXHRcblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblx0XG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXHRcblx0ICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2VuZHMgZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuXHQgIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignc3VjY2VzcycsIGZuKTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHQgICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5zZW5kWGhyID0gcmVxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBzZWxmLm9uRGF0YShkYXRhKTtcblx0ICB9KTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHQgICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5wb2xsWGhyID0gcmVxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlcXVlc3QgY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG5cdCAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcblx0ICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuXHQgIHRoaXMueGQgPSAhIW9wdHMueGQ7XG5cdCAgdGhpcy54cyA9ICEhb3B0cy54cztcblx0ICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG5cdCAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuXHQgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuXHQgIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuXHQgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblx0ICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblx0XG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cdFxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0XG5cdCAgdGhpcy5jcmVhdGUoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXHRcblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0XG5cdCAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0XG5cdCAgdHJ5IHtcblx0XG5cdCAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG5cdCAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHRcblx0ICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgfVxuXHRcblx0ICAgIHRyeSB7XG5cdCAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHRcblx0ICAgIC8vIGllNiBjaGVja1xuXHQgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuXHQgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuXHQgICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0ICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBzZWxmLm9uTG9hZCgpO1xuXHQgICAgICB9O1xuXHQgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuXHQgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZSkge31cblx0ICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcblx0ICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuXHQgICAgICAgICAgc2VsZi5vbkxvYWQoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG5cdCAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG5cdCAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuXHQgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0XG5cdCAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3Jcblx0ICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuXHQgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgc2VsZi5vbkVycm9yKGUpO1xuXHQgICAgfSwgMCk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG5cdCAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG5cdCAgdGhpcy5vblN1Y2Nlc3MoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLmNsZWFudXAodHJ1ZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xlYW5zIHVwIGhvdXNlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRSZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuXHQgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIC8vIHhtbGh0dHByZXF1ZXN0XG5cdCAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0ICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG5cdCAgfVxuXHRcblx0ICBpZiAoZnJvbUVycm9yKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdFxuXHQgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0ICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuXHQgIH1cblx0XG5cdCAgdGhpcy54aHIgPSBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGxvYWQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgZGF0YTtcblx0ICB0cnkge1xuXHQgICAgdmFyIGNvbnRlbnRUeXBlO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuXHQgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0aGlzLm9uRXJyb3IoZSk7XG5cdCAgfVxuXHQgIGlmIChudWxsICE9IGRhdGEpIHtcblx0ICAgIHRoaXMub25EYXRhKGRhdGEpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFib3J0cyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmNsZWFudXAoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG5cdCAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcblx0ICogZW1pdHRlZC5cblx0ICovXG5cdFxuXHRSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuXHRSZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cdFxuXHRpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuXHQgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuXHQgIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcblx0ICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcblx0ICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0XG5cdHZhciBUcmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblx0dmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHR2YXIgaW5oZXJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHR2YXIgeWVhc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXHRcblx0LyoqXG5cdCAqIElzIFhIUjIgc3VwcG9ydGVkP1xuXHQgKi9cblx0XG5cdHZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG5cdCAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcblx0fSkoKTtcblx0XG5cdC8qKlxuXHQgKiBQb2xsaW5nIGludGVyZmFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuXHQgIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuXHQgIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuXHQgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblx0ICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblx0XG5cdGluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblx0XG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgbmFtZS5cblx0ICovXG5cdFxuXHRQb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXHRcblx0LyoqXG5cdCAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcblx0ICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnBvbGwoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQYXVzZXMgcG9sbGluZy5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG9uUGF1c2UpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblx0XG5cdCAgZnVuY3Rpb24gcGF1c2UgKCkge1xuXHRcblx0ICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuXHQgICAgb25QYXVzZSgpO1xuXHQgIH1cblx0XG5cdCAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuXHQgICAgdmFyIHRvdGFsID0gMDtcblx0XG5cdCAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG5cdFxuXHQgICAgICB0b3RhbCsrO1xuXHQgICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcblx0XG5cdCAgICAgIHRvdGFsKys7XG5cdCAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHBhdXNlKCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgIHRoaXMucG9sbGluZyA9IHRydWU7XG5cdCAgdGhpcy5kb1BvbGwoKTtcblx0ICB0aGlzLmVtaXQoJ3BvbGwnKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuXHQgICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuXHQgICAgaWYgKCdvcGVuaW5nJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSB7XG5cdCAgICAgIHNlbGYub25PcGVuKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuXHQgICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG5cdCAgICAgIHNlbGYub25DbG9zZSgpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuXHQgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH07XG5cdFxuXHQgIC8vIGRlY29kZSBwYXlsb2FkXG5cdCAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHRcblx0ICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuXHQgIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuXHQgICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXHRcblx0ICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgICB0aGlzLnBvbGwoKTtcblx0ICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIGZ1bmN0aW9uIGNsb3NlICgpIHtcblx0XG5cdCAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuXHQgIH1cblx0XG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFxuXHQgICAgY2xvc2UoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcblx0ICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cdFxuXHQgICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRQb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblx0ICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuXHQgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuXHQgIH07XG5cdFxuXHQgIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cdCAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcblx0ICB2YXIgcG9ydCA9ICcnO1xuXHRcblx0ICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuXHQgIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuXHQgICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuXHQgIH1cblx0XG5cdCAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcblx0ICAgIHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXHRcblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblx0XG5cdCAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblx0ICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG5cdCAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG5cdCAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuXHQgIH1cblx0XG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cdFxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cdFxuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblx0XG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcblx0ICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG5cdCAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuXHQgIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG5cdCAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG5cdCAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG5cdCAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcblx0ICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cdFxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZng7XG5cdCAgdGhpcy5rZXkgPSBvcHRzLmtleTtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuXHQgIHRoaXMuY2EgPSBvcHRzLmNhO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXHQgIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cdFxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cdFxuXHRFbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXHRcblx0LyoqXG5cdCAqIEVtaXRzIGFuIGVycm9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuXHQgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcblx0ICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG5cdCAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cdCAgICB0aGlzLmRvT3BlbigpO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLmRvQ2xvc2UoKTtcblx0ICAgIHRoaXMub25DbG9zZSgpO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuXHQgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgdGhpcy53cml0ZShwYWNrZXRzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gb3BlblxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuXHQgIHRoaXMub25QYWNrZXQocGFja2V0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuXHQgKi9cblx0XG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgdGhpcy5lbWl0KCdjbG9zZScpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0dmFyIGhhc0JpbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBzbGljZUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHR2YXIgYWZ0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblx0dmFyIHV0ZjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0XG5cdHZhciBiYXNlNjRlbmNvZGVyO1xuXHRpZiAoZ2xvYmFsICYmIGdsb2JhbC5BcnJheUJ1ZmZlcikge1xuXHQgIGJhc2U2NGVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2Vcblx0ICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cblx0ICpcblx0ICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cblx0ICovXG5cdFxuXHR2YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cblx0ICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdFxuXHQvKipcblx0ICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblx0XG5cdC8qKlxuXHQgKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cdFxuXHQvKipcblx0ICogUGFja2V0IHR5cGVzLlxuXHQgKi9cblx0XG5cdHZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuXHQgICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG5cdCAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3Ncblx0ICAsIHBpbmc6ICAgICAyXG5cdCAgLCBwb25nOiAgICAgM1xuXHQgICwgbWVzc2FnZTogIDRcblx0ICAsIHVwZ3JhZGU6ICA1XG5cdCAgLCBub29wOiAgICAgNlxuXHR9O1xuXHRcblx0dmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblx0XG5cdC8qKlxuXHQgKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cblx0ICovXG5cdFxuXHR2YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgKi9cblx0XG5cdHZhciBCbG9iID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cdFxuXHQvKipcblx0ICogRW5jb2RlcyBhIHBhY2tldC5cblx0ICpcblx0ICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgNWhlbGxvIHdvcmxkXG5cdCAqICAgICAzXG5cdCAqICAgICA0XG5cdCAqXG5cdCAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cdFxuXHQgIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuXHQgICAgdXRmOGVuY29kZSA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgPyB1bmRlZmluZWRcblx0ICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXHRcblx0ICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG5cdCAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgfVxuXHRcblx0ICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cblx0ICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuXHQgICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuXHQgIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdFxuXHQgIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcblx0ICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuXHQgICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXHRcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG5cdCAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG5cdCAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG5cdCAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHQgIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblx0XG5cdCAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdCAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcblx0ICB9O1xuXHQgIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXHRcblx0ICBpZiAoZG9udFNlbmRCbG9icykge1xuXHQgICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcblx0ICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXHRcblx0ICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICovXG5cdFxuXHRleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcblx0ICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuXHQgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG5cdCAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cdFxuXHQgIHZhciBiNjRkYXRhO1xuXHQgIHRyeSB7XG5cdCAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG5cdCAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcblx0ICAgIH1cblx0ICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcblx0ICB9XG5cdCAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcblx0ICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRleHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG5cdCAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIGVycjtcblx0ICB9XG5cdCAgLy8gU3RyaW5nIGRhdGFcblx0ICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICdiJykge1xuXHQgICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmICh1dGY4ZGVjb2RlKSB7XG5cdCAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG5cdCAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuXHQgICAgICAgIHJldHVybiBlcnI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cdFxuXHQgICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuXHQgICAgICByZXR1cm4gZXJyO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0ICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG5cdCAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcblx0ICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcblx0ICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuXHQgIH1cblx0ICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcblx0ICB0cnkge1xuXHQgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHJldHVybiBkYXRhO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcblx0ICovXG5cdFxuXHRleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuXHQgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG5cdCAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG5cdCAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG5cdCAgfVxuXHRcblx0ICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXHRcblx0ICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcblx0ICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuXHQgKlxuXHQgKiAgICAgPGxlbmd0aD46ZGF0YVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG5cdCAqXG5cdCAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG5cdCAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXHRcblx0ICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcblx0ICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG5cdCAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG5cdCAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdCAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcblx0ICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXHRcblx0ICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuXHQgICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuXHQgICAgICByZXN1bHRbaV0gPSBtc2c7XG5cdCAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcblx0ICB9XG5cdH1cblx0XG5cdC8qXG5cdCAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuXHQgKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRleHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHQgIH1cblx0XG5cdCAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdCAgICBiaW5hcnlUeXBlID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIHZhciBwYWNrZXQ7XG5cdCAgaWYgKGRhdGEgPT09ICcnKSB7XG5cdCAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICB9XG5cdFxuXHQgIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cdFxuXHQgICAgaWYgKGNociAhPT0gJzonKSB7XG5cdCAgICAgIGxlbmd0aCArPSBjaHI7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG5cdCAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICB9XG5cdFxuXHQgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXHRcblx0ICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuXHQgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChtc2cubGVuZ3RoKSB7XG5cdCAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuXHRcblx0ICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcblx0ICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcblx0ICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBhZHZhbmNlIGN1cnNvclxuXHQgICAgaSArPSBuO1xuXHQgICAgbGVuZ3RoID0gJyc7XG5cdCAgfVxuXHRcblx0ICBpZiAobGVuZ3RoICE9PSAnJykge1xuXHQgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgfVxuXHRcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG5cdCAqXG5cdCAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcblx0ICogMjU1PjxkYXRhPlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG5cdCAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG5cdCAgICAgIHZhciBsZW47XG5cdCAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuXHQgICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuXHQgICAgfSwgMCk7XG5cdFxuXHQgICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXHRcblx0ICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG5cdCAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0ICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuXHQgICAgICB2YXIgYWIgPSBwO1xuXHQgICAgICBpZiAoaXNTdHJpbmcpIHtcblx0ICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFiID0gdmlldy5idWZmZXI7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcblx0ICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG5cdCAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG5cdCAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblx0XG5cdCAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHRcblx0ICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuXHQgIH0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVuY29kZSBhcyBCbG9iXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcblx0ICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHQgICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHQgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcblx0ICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuXHQgICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0ICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuXHQgICAgICAgIDogZW5jb2RlZC5zaXplO1xuXHRcblx0ICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuXHQgICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG5cdCAgICAgIH1cblx0ICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXHRcblx0ICAgICAgaWYgKEJsb2IpIHtcblx0ICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuXHQgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHQvKlxuXHQgKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcblx0ICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuXHQgKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcblx0ICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuXHQgIHZhciBidWZmZXJzID0gW107XG5cdFxuXHQgIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG5cdCAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG5cdCAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG5cdCAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG5cdCAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cdFxuXHQgICAgICAvLyAzMTAgPSBjaGFyIGxlbmd0aCBvZiBOdW1iZXIuTUFYX1ZBTFVFXG5cdCAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG5cdCAgICB9XG5cdFxuXHQgICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcblx0ICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cdFxuXHQgICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG5cdCAgICBpZiAoaXNTdHJpbmcpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG5cdCAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcblx0ICAgICAgICBtc2cgPSAnJztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgYnVmZmVycy5wdXNoKG1zZyk7XG5cdCAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcblx0ICB9XG5cdFxuXHQgIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXHQgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcblx0ICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG5cdCAgdmFyIGFyciA9IFtdO1xuXHQgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHRcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xuXHQgICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcblx0ICAgICAgYXJyLnB1c2goaSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBhcnI7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cblx0ICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcblx0ICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXHRcblx0ICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cdFxuXHQgIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cblx0ICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cblx0ICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblx0XG5cdCAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuXHQgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcblx0ICB9XG5cdFxuXHQgIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcblx0ICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG5cdCAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXHRcblx0ZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcblx0ICAgIHZhciBiYWlsID0gZmFsc2Vcblx0ICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG5cdCAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cdFxuXHQgICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblx0XG5cdCAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuXHQgICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcblx0ICAgICAgICB9XG5cdCAgICAgICAgLS1wcm94eS5jb3VudFxuXHRcblx0ICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuXHQgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgYmFpbCA9IHRydWVcblx0ICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuXHQgICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuXHQgICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuXHQgICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlLCBnbG9iYWwpIHsvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblx0OyhmdW5jdGlvbihyb290KSB7XG5cdFxuXHRcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0XHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXHRcblx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHRcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0XG5cdFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0XHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHRcdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdFx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0XHR9XG5cdFxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0XHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0XG5cdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgZXh0cmE7XG5cdFx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblx0XG5cdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblx0XG5cdFx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0XHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHRcdFx0fVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHR9XG5cdFx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdFx0cmV0dXJuIHN5bWJvbDtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nLCBvcHRzKSB7XG5cdFx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cdFxuXHRcdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHRcdH1cblx0XG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHRcdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdFx0Ynl0ZUluZGV4Kys7XG5cdFxuXHRcdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0XHRcdHZhciBieXRlMTtcblx0XHRcdHZhciBieXRlMjtcblx0XHRcdHZhciBieXRlMztcblx0XHRcdHZhciBieXRlNDtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFxuXHRcdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0XHRieXRlSW5kZXgrKztcblx0XG5cdFx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiBieXRlMTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdFx0fVxuXHRcblx0XHR2YXIgYnl0ZUFycmF5O1xuXHRcdHZhciBieXRlQ291bnQ7XG5cdFx0dmFyIGJ5dGVJbmRleDtcblx0XHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcblx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdFx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblx0XG5cdFx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdFx0dmFyIHRtcDtcblx0XHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHRcdH1cblx0XG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHRcdHZhciB1dGY4ID0ge1xuXHRcdFx0J3ZlcnNpb24nOiAnMi4xLjInLFxuXHRcdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHRcdH07XG5cdFxuXHRcdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHRcdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0XHRpZiAoXG5cdFx0XHR0cnVlXG5cdFx0KSB7XG5cdFx0XHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB1dGY4O1xuXHRcdFx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0XHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdFx0cm9vdC51dGY4ID0gdXRmODtcblx0XHR9XG5cdFxuXHR9KHRoaXMpKTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KShtb2R1bGUpLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbW9kdWxlO1xyXG5cdH1cclxuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHQgKiBiYXNlNjQtYXJyYXlidWZmZXJcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG5cdCAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblx0ICovXG5cdChmdW5jdGlvbigpe1xuXHQgIFwidXNlIHN0cmljdFwiO1xuXHRcblx0ICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblx0XG5cdCAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuXHQgIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG5cdCAgfVxuXHRcblx0ICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG5cdCAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cdFxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuXHQgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcblx0ICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuXHQgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG5cdCAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBiYXNlNjQ7XG5cdCAgfTtcblx0XG5cdCAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG5cdCAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG5cdCAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcblx0ICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXHRcblx0ICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuXHQgICAgICBidWZmZXJMZW5ndGgtLTtcblx0ICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG5cdCAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcblx0ICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXHRcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcblx0ICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuXHQgICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcblx0ICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG5cdCAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXHRcblx0ICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcblx0ICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG5cdCAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuXHQgIH07XG5cdH0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3Rcblx0ICovXG5cdFxuXHR2YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuXHQgIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuXHQgKi9cblx0XG5cdHZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG5cdCAgICByZXR1cm4gYS5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2goZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fSkoKTtcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3Ncblx0ICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cblx0ICovXG5cdFxuXHR2YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xuXHQgICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcblx0ICB9IGNhdGNoKGUpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH0pKCk7XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG5cdCAqL1xuXHRcblx0dmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcblx0ICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG5cdCAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cdFxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuXHQgKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3Rcblx0ICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cblx0ICovXG5cdFxuXHRmdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG5cdCAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblx0XG5cdCAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuXHQgICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcblx0ICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcblx0ICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgYXJ5W2ldID0gYnVmO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XG5cdCAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuXHQgICAgYmIuYXBwZW5kKGFyeVtpXSk7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXHQgIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG5cdCAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcblx0ICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBnbG9iYWwuQmxvYiA6IEJsb2JDb25zdHJ1Y3Rvcjtcblx0ICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG5cdCAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3Rvcjtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cdH0pKCk7XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcclxuXHQgKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXHJcblx0ICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9XHJcblx0ICogQGFwaSBwcml2YXRlXHJcblx0ICovXHJcblx0XHJcblx0ZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICB2YXIgc3RyID0gJyc7XHJcblx0XHJcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0ICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XHJcblx0ICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gc3RyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuXHQgKiBAYXBpIHByaXZhdGVcclxuXHQgKi9cclxuXHRcclxuXHRleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcclxuXHQgIHZhciBxcnkgPSB7fTtcclxuXHQgIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XHJcblx0ICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHFyeTtcclxuXHR9O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuXHQgIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcblx0ICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcblx0ICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcblx0ICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG5cdCAgLCBsZW5ndGggPSA2NFxuXHQgICwgbWFwID0ge31cblx0ICAsIHNlZWQgPSAwXG5cdCAgLCBpID0gMFxuXHQgICwgcHJldjtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuXHQgIHZhciBlbmNvZGVkID0gJyc7XG5cdFxuXHQgIGRvIHtcblx0ICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcblx0ICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcblx0ICB9IHdoaWxlIChudW0gPiAwKTtcblx0XG5cdCAgcmV0dXJuIGVuY29kZWQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuXHQgIHZhciBkZWNvZGVkID0gMDtcblx0XG5cdCAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZGVjb2RlZDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24geWVhc3QoKSB7XG5cdCAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cdFxuXHQgIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcblx0ICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xuXHR9XG5cdFxuXHQvL1xuXHQvLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuXHQvL1xuXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblx0XG5cdC8vXG5cdC8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cblx0Ly9cblx0eWVhc3QuZW5jb2RlID0gZW5jb2RlO1xuXHR5ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5cdG1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXHRcblx0dmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0dmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblx0XG5cdC8qKlxuXHQgKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cblx0ICovXG5cdFxuXHR2YXIgck5ld2xpbmUgPSAvXFxuL2c7XG5cdHZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblx0XG5cdC8qKlxuXHQgKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuXHQgKi9cblx0XG5cdHZhciBjYWxsYmFja3M7XG5cdFxuXHQvKipcblx0ICogTm9vcC5cblx0ICovXG5cdFxuXHRmdW5jdGlvbiBlbXB0eSAoKSB7IH1cblx0XG5cdC8qKlxuXHQgKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cdFxuXHQgIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXHRcblx0ICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuXHQgIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG5cdCAgaWYgKCFjYWxsYmFja3MpIHtcblx0ICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG5cdCAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcblx0ICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG5cdCAgfVxuXHRcblx0ICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG5cdCAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cdFxuXHQgIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuXHQgICAgc2VsZi5vbkRhdGEobXNnKTtcblx0ICB9KTtcblx0XG5cdCAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuXHQgIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cdFxuXHQgIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcblx0ICAgIH0sIGZhbHNlKTtcblx0ICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG5cdCAqL1xuXHRcblx0aW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXHRcblx0Lypcblx0ICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuXHQgKi9cblx0XG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnNjcmlwdCkge1xuXHQgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG5cdCAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICBpZiAodGhpcy5mb3JtKSB7XG5cdCAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuXHQgICAgdGhpcy5mb3JtID0gbnVsbDtcblx0ICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0ICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuXHQgICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0ICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcblx0ICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcblx0ICB9O1xuXHRcblx0ICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG5cdCAgaWYgKGluc2VydEF0KSB7XG5cdCAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0ICB9XG5cdCAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cdFxuXHQgIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHRcblx0ICBpZiAoaXNVQWdlY2tvKSB7XG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblx0ICAgIH0sIDEwMCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0ICBpZiAoIXRoaXMuZm9ybSkge1xuXHQgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdCAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG5cdCAgICB2YXIgaWZyYW1lO1xuXHRcblx0ICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcblx0ICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG5cdCAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG5cdCAgICBmb3JtLnRhcmdldCA9IGlkO1xuXHQgICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG5cdCAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcblx0ICAgIGFyZWEubmFtZSA9ICdkJztcblx0ICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXHRcblx0ICAgIHRoaXMuZm9ybSA9IGZvcm07XG5cdCAgICB0aGlzLmFyZWEgPSBhcmVhO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cdFxuXHQgIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcblx0ICAgIGluaXRJZnJhbWUoKTtcblx0ICAgIGZuKCk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcblx0ICAgIGlmIChzZWxmLmlmcmFtZSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIHRyeSB7XG5cdCAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuXHQgICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuXHQgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0ICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuXHQgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG5cdCAgICB9XG5cdFxuXHQgICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblx0XG5cdCAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuXHQgIH1cblx0XG5cdCAgaW5pdElmcmFtZSgpO1xuXHRcblx0ICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcblx0ICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG5cdCAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblx0XG5cdCAgdHJ5IHtcblx0ICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXHRcblx0ICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcblx0ICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0ICAgICAgICBjb21wbGV0ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdHZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdHZhciBpbmhlcml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cdHZhciB5ZWFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXHR2YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblx0dmFyIE5vZGVXZWJTb2NrZXQ7XG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHQgIHRyeSB7XG5cdCAgICBOb2RlV2ViU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cdCAgfSBjYXRjaCAoZSkgeyB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG5cdCAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG5cdCAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cblx0ICovXG5cdFxuXHR2YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcblx0aWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblx0XG5cdC8qKlxuXHQgKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIFdTIChvcHRzKSB7XG5cdCAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG5cdCAgaWYgKGZvcmNlQmFzZTY0KSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuXHQgIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG5cdCAgdGhpcy5wcm90b2NvbHMgPSBvcHRzLnByb3RvY29scztcblx0ICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG5cdCAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuXHQgIH1cblx0ICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblx0XG5cdGluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cdFxuXHQvKipcblx0ICogVHJhbnNwb3J0IG5hbWUuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0Jztcblx0XG5cdC8qXG5cdCAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXHRcblx0LyoqXG5cdCAqIE9wZW5zIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoIXRoaXMuY2hlY2soKSkge1xuXHQgICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdFxuXHQgIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuXHQgIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcblx0ICB2YXIgb3B0cyA9IHtcblx0ICAgIGFnZW50OiB0aGlzLmFnZW50LFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcblx0ICB9O1xuXHRcblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXHQgIH1cblx0ICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcblx0ICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG5cdCAgfVxuXHRcblx0ICB0cnkge1xuXHQgICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gKHByb3RvY29scyA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIDogbmV3IFdlYlNvY2tldCh1cmkpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXHQgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIH1cblx0XG5cdCAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHRcblx0ICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuXHQgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdCAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgfVxuXHRcblx0ICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0ICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25PcGVuKCk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLm9uQ2xvc2UoKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG5cdCAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuXHQgIH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cdFxuXHQgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG5cdCAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuXHQgIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcblx0ICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIGlmICghc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcblx0ICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG5cdCAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuXHQgICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG5cdCAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcblx0ICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuXHQgICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuXHQgICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuXHQgICAgICAgIC8vIHRocm93IGFuIGVycm9yXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuXHQgICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuXHQgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHRcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pKHBhY2tldHNbaV0pO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gZG9uZSAoKSB7XG5cdCAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cdFxuXHQgICAgLy8gZmFrZSBkcmFpblxuXHQgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuXHQgICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG5cdCAgICB9LCAwKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gY2xvc2Vcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xvc2VzIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgdGhpcy53cy5jbG9zZSgpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cdCAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuXHQgIHZhciBwb3J0ID0gJyc7XG5cdFxuXHQgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cdCAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcblx0ICAgICgnd3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcblx0ICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG5cdCAgfVxuXHRcblx0ICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuXHQgIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG5cdCAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG5cdCAgfVxuXHRcblx0ICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcblx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXHRcblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblx0XG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cdFxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFdTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHR2YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcblx0ICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcclxuXHQgKiBKU09OIHBhcnNlLlxyXG5cdCAqXHJcblx0ICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdHZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xyXG5cdHZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xyXG5cdHZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XHJcblx0dmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcclxuXHR2YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcclxuXHR2YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xyXG5cdCAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XHJcblx0ICAgIHJldHVybiBudWxsO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcclxuXHRcclxuXHQgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxyXG5cdCAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcclxuXHQgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXHJcblx0ICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXHJcblx0ICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XHJcblx0ICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xyXG5cdCAgfVxyXG5cdH07XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciB0b0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdHZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xuXHR2YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblx0XG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cblx0ICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdHZhciBldmVudHMgPSB7XG5cdCAgY29ubmVjdDogMSxcblx0ICBjb25uZWN0X2Vycm9yOiAxLFxuXHQgIGNvbm5lY3RfdGltZW91dDogMSxcblx0ICBjb25uZWN0aW5nOiAxLFxuXHQgIGRpc2Nvbm5lY3Q6IDEsXG5cdCAgZXJyb3I6IDEsXG5cdCAgcmVjb25uZWN0OiAxLFxuXHQgIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuXHQgIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG5cdCAgcmVjb25uZWN0X2Vycm9yOiAxLFxuXHQgIHJlY29ubmVjdGluZzogMSxcblx0ICBwaW5nOiAxLFxuXHQgIHBvbmc6IDFcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cblx0ICovXG5cdFxuXHR2YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cdFxuXHQvKipcblx0ICogYFNvY2tldGAgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gU29ja2V0KGlvLCBuc3AsIG9wdHMpIHtcblx0ICB0aGlzLmlvID0gaW87XG5cdCAgdGhpcy5uc3AgPSBuc3A7XG5cdCAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG5cdCAgdGhpcy5pZHMgPSAwO1xuXHQgIHRoaXMuYWNrcyA9IHt9O1xuXHQgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuXHQgIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcblx0ICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuXHQgIH1cblx0ICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBNaXggaW4gYEVtaXR0ZXJgLlxuXHQgKi9cblx0XG5cdEVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblx0XG5cdCAgdmFyIGlvID0gdGhpcy5pbztcblx0ICB0aGlzLnN1YnMgPSBbb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLCBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLCBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKV07XG5cdH07XG5cdFxuXHQvKipcblx0ICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vcGVuID0gU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIHRoaXMuc3ViRXZlbnRzKCk7XG5cdCAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuXHQgIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG5cdCAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE92ZXJyaWRlIGBlbWl0YC5cblx0ICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuXHQgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG5cdCAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cdFxuXHQgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlci5FVkVOVCwgZGF0YTogYXJncyB9O1xuXHRcblx0ICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuXHQgIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cdFxuXHQgIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuXHQgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG5cdFxuXHQgICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG5cdCAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuXHQgIH1cblx0XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblx0XG5cdCAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cdFxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNlbmRzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcblx0ICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3Nhcnlcblx0ICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuXHQgICAgaWYgKHRoaXMucXVlcnkpIHtcblx0ICAgICAgdmFyIHF1ZXJ5ID0gX3R5cGVvZih0aGlzLnF1ZXJ5KSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG5cdFxuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnkgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFxuXHQgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuXHQgIGRlbGV0ZSB0aGlzLmlkO1xuXHQgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIGlmIChwYWNrZXQubnNwICE9PSB0aGlzLm5zcCkgcmV0dXJuO1xuXHRcblx0ICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG5cdCAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuXHQgICAgICB0aGlzLm9uY29ubmVjdCgpO1xuXHQgICAgICBicmVhaztcblx0XG5cdCAgICBjYXNlIHBhcnNlci5FVkVOVDpcblx0ICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcblx0ICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkFDSzpcblx0ICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuXHQgICAgICBicmVhaztcblx0XG5cdCAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuXHQgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG5cdCAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuXHQgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuXHQgICAgICBicmVhaztcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG5cdFxuXHQgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuXHRcblx0ICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcblx0ICB9XG5cdFxuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHQgICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciBzZW50ID0gZmFsc2U7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuXHQgICAgaWYgKHNlbnQpIHJldHVybjtcblx0ICAgIHNlbnQgPSB0cnVlO1xuXHQgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdFxuXHQgICAgc2VsZi5wYWNrZXQoe1xuXHQgICAgICB0eXBlOiBwYXJzZXIuQUNLLFxuXHQgICAgICBpZDogaWQsXG5cdCAgICAgIGRhdGE6IGFyZ3Ncblx0ICAgIH0pO1xuXHQgIH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcblx0XG5cdCAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuXHQgICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuXHQgIH0gZWxzZSB7fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcblx0ICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcblx0ICB9XG5cdCAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cdFxuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG5cdCAgfVxuXHQgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cdCAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG5cdCAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG5cdCAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGUuXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnN1YnMpIHtcblx0ICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuc3VicyA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IFNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0XG5cdCAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuXHQgIH1cblx0XG5cdCAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcblx0ICB0aGlzLmRlc3Ryb3koKTtcblx0XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICAvLyBmaXJlIGV2ZW50c1xuXHQgICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcblx0ICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcblx0ICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblx0XG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcblx0ICAgIHZhciBhcnJheSA9IFtdXG5cdFxuXHQgICAgaW5kZXggPSBpbmRleCB8fCAwXG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gYXJyYXlcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IG9uO1xuXHRcblx0LyoqXG5cdCAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuXHQgIG9iai5vbihldiwgZm4pO1xuXHQgIHJldHVybiB7XG5cdCAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogU2xpY2UgcmVmZXJlbmNlLlxuXHQgKi9cblx0XG5cdHZhciBzbGljZSA9IFtdLnNsaWNlO1xuXHRcblx0LyoqXG5cdCAqIEJpbmQgYG9iamAgdG8gYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuXHQgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuXHQgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHQgIHJldHVybiBmdW5jdGlvbigpe1xuXHQgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG5cdCAgfVxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBgQmFja29mZmAuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXHRcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cblx0ICpcblx0ICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG5cdCAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuXHQgKiAtIGBqaXR0ZXJgIFswXVxuXHQgKiAtIGBmYWN0b3JgIFsyXVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG5cdCAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcblx0ICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG5cdCAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcblx0ICB0aGlzLmF0dGVtcHRzID0gMDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdEJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG5cdCAgaWYgKHRoaXMuaml0dGVyKSB7XG5cdCAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuXHQgICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuXHQgICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRCYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5hdHRlbXB0cyA9IDA7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0QmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcblx0ICB0aGlzLm1zID0gbWluO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdEJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG5cdCAgdGhpcy5tYXggPSBtYXg7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSBqaXR0ZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuXHQgIHRoaXMuaml0dGVyID0gaml0dGVyO1xuXHR9O1xuXHRcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzb2NrZXQuaW8uc2xpbS5qcyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDZlZmMzM2Y0NTY2OTFmNDU4YTkwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcblxuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG5cbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9pbmRleC5qcyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcblxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG5cbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi91cmwuanMiLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2V1cmkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHt9OyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3VwcG9ydC9ub29wLmpzIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBpZiAoKG9iai50eXBlID09PSBleHBvcnRzLkVWRU5UIHx8IG9iai50eXBlID09PSBleHBvcnRzLkFDSykgJiYgaGFzQmluKG9iai5kYXRhKSkge1xuICAgIG9iai50eXBlID0gb2JqLnR5cGUgPT09IGV4cG9ydHMuRVZFTlQgPyBleHBvcnRzLkJJTkFSWV9FVkVOVCA6IGV4cG9ydHMuQklOQVJZX0FDSztcbiAgfVxuXG5cblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBzdHIgKz0gSlNPTi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICB9XG5cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHAgPSB0cnlQYXJzZShwLCBzdHIuc3Vic3RyKGkpKTtcbiAgfVxuXG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuICB0cnkge1xuICAgIHAuZGF0YSA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcDsgXG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBCbG9iIEZpbGUgKi9cblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgZ2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFN1cHBvcnRzIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEJsb2IgYW5kIEZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBnbG9iYWwuQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXMtYmluYXJ5Mi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGdsb2JhbC5CbG9iID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBnbG9iYWwuRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5GaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB2YXIgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2VuZXJhdGUgYHNvY2tldC5pZGAgZm9yIHRoZSBnaXZlbiBgbnNwYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuc3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG4gIHJldHVybiAobnNwID09PSAnLycgPyAnJyA6IChuc3AgKyAnIycpKSArIHRoaXMuZW5naW5lLmlkO1xufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG5cbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuXG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblxuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblxuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblxuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcgKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcblxuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG5cblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuXG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcblxuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG5cbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbWFuYWdlci5qcyIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmxvY2FsQWRkcmVzcykge1xuICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgb24gaGFuZHNoYWtlXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gbnVsbDtcblxuICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gcGVyLXRyYW5zcG9ydCBvcHRpb25zXG4gIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgYWdlbnQ6IG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogb3B0aW9ucy5ob3N0bmFtZSB8fCB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZSB8fCB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoLFxuICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IG9wdGlvbnMuanNvbnAgfHwgdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogb3B0aW9ucy5mb3JjZUJhc2U2NCB8fCB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IG9wdGlvbnMudGltZXN0YW1wUmVxdWVzdHMgfHwgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogb3B0aW9ucy50aW1lc3RhbXBQYXJhbSB8fCB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCB8fCB0aGlzLnBmeCxcbiAgICBrZXk6IG9wdGlvbnMua2V5IHx8IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogb3B0aW9ucy5jZXJ0IHx8IHRoaXMuY2VydCxcbiAgICBjYTogb3B0aW9ucy5jYSB8fCB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCB8fCB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgZm9yY2VOb2RlOiBvcHRpb25zLmZvcmNlTm9kZSB8fCB0aGlzLmZvcmNlTm9kZSxcbiAgICBsb2NhbEFkZHJlc3M6IG9wdGlvbnMubG9jYWxBZGRyZXNzIHx8IHRoaXMubG9jYWxBZGRyZXNzLFxuICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG4gICAgcHJvdG9jb2xzOiBvcHRpb25zLnByb3RvY29scyB8fCB2b2lkICgwKVxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuXG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcblxuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuXG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcblxuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuXG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuXG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblxuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuXG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhcy1jb3JzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUiAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgb3B0cy5yZXF1ZXN0VGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG5cbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICcqLyonKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuXG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuXG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG5cbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcblxuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcblxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuXG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKGdsb2JhbCAmJiBnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWZ0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHRcdH1cblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZywgb3B0cykge1xuXHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjEuMicsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibG9iL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2Vxcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29tcG9uZW50LWluaGVyaXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veWVhc3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH0gZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbnZhciBOb2RlV2ViU29ja2V0O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICB0aGlzLnByb3RvY29scyA9IG9wdHMucHJvdG9jb2xzO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0ID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPSB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA/IChwcm90b2NvbHMgPyBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKSA6IG5ldyBXZWJTb2NrZXQodXJpKSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAvLyBoYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgIC8vIGZha2UgZHJhaW5cbiAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICgnd3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2luZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBKU09OIHBhcnNlLlxyXG4gKlxyXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xyXG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcclxudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcclxudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcclxudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XHJcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcclxuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcclxuXHJcbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XHJcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxyXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcclxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XHJcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcclxuICB9XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlanNvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlci5FVkVOVCwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG5cbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnID8gcGFyc2Vxcy5lbmNvZGUodGhpcy5xdWVyeSkgOiB0aGlzLnF1ZXJ5O1xuXG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKHBhY2tldC5uc3AgIT09IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuXG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG5cbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcblxuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuXG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9zb2NrZXQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RvLWFycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbiAob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL29uLmpzIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29tcG9uZW50LWJpbmQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhY2tvMi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzMyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNjIwMzNiYjBlNTYyOTY2ZGJlNWIiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0cmluZyA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5hc3luYyA9IGV4cG9ydHMuYXJyYXkgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5PYmplY3Qua2V5cyhfY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hcnJheSA9IHJlcXVpcmUoJy4vYXJyYXkvYXJyYXknKTtcblxudmFyIF9hcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jL2FzeW5jJyk7XG5cbnZhciBfYXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmMpO1xuXG52YXIgX0Rpc3Bvc2FibGUgPSByZXF1aXJlKCcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZScpO1xuXG52YXIgX0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlzcG9zYWJsZSk7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3Qvb2JqZWN0Jyk7XG5cbnZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG5cbnZhciBfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcvc3RyaW5nJyk7XG5cbnZhciBfc3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuYXJyYXkgPSBfYXJyYXkyLmRlZmF1bHQ7XG5leHBvcnRzLmFzeW5jID0gX2FzeW5jMi5kZWZhdWx0O1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gX0Rpc3Bvc2FibGUyLmRlZmF1bHQ7XG5leHBvcnRzLm9iamVjdCA9IF9vYmplY3QyLmRlZmF1bHQ7XG5leHBvcnRzLnN0cmluZyA9IF9zdHJpbmcyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIHByaW50ZWQgYXMgSlNPTlxuICogd2hlbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QgaXMgY2FsbGVkLlxuICovXG5jbGFzcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgRW1ib2RpZWQgaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ib2R5XyA9IHt9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cbiAgYm9keSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5XztcbiAgfVxuXG4gIC8qKlxuXHQgKiBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEVtYm9kaWVkLCB0aGlzIHdpbGxcblx0ICogcmV0dXJuIGl0cyBib2R5IGNvbnRlbnQuIE90aGVyd2lzZSB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuXHQgKiBvcmlnaW5hbCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kn0gb2JqXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0b0JvZHkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVtYm9kaWVkID8gb2JqLmJvZHkoKSA6IG9iajtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbWJvZGllZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGktcXVlcnkvRW1ib2RpZWQuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRyZWVOb2RlID0gZXhwb3J0cy5NdWx0aU1hcCA9IHVuZGVmaW5lZDtcblxudmFyIF9NdWx0aU1hcCA9IHJlcXVpcmUoJy4uL011bHRpTWFwJyk7XG5cbnZhciBfTXVsdGlNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTXVsdGlNYXApO1xuXG52YXIgX1RyZWVOb2RlID0gcmVxdWlyZSgnLi4vVHJlZU5vZGUnKTtcblxudmFyIF9UcmVlTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmVlTm9kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuTXVsdGlNYXAgPSBfTXVsdGlNYXAyLmRlZmF1bHQ7XG5leHBvcnRzLlRyZWVOb2RlID0gX1RyZWVOb2RlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9hbGwvc3RydWN0cy5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCgpIHtcbiAgaWYgKCFnbG9iYWxzLndpbmRvdykge1xuICAgIHRocm93IG5ldyBFcnJvcignU2lnbi1pbiB0eXBlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7ISp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtIHshc3RyaW5nfSBlcnJvck1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgcHJvdmlkZWQgdG8gdGhlIGV4Y2VwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RGVmQW5kTm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG4gIGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGdpdmVuIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyEqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXJyb3JNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHByb3ZpZGVkIHRvIHRoZSBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoY29yZS5pc051bGwodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGdpdmVuIHZhbHVlIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshKn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGVycm9yTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcm92aWRlZCB0byB0aGUgZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG4gIGlmICghY29yZS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBnaXZlbiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LlxuICogQHBhcmFtIHshKn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGVycm9yTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcm92aWRlZCB0byB0aGUgZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRPYmplY3QodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoIWNvcmUuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSByZXNwb25zZSBoYXMgc3VjY2VlZGVkLiBUaGUgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBgc3VjY2VlZGVkYFxuICogbWV0aG9kIG9mIHJlc3BvbnNlIG9iamVjdCByZXR1cm5zIHRydWUuIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHJldHVybmVkXG4gKiB2YWx1ZSBpcyBmYWxzZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXNwb25zZSBpdHNlbGYgaWYgdmFsaWQuIE90aGVyd2lzZSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLnN1Y2NlZWRlZCgpKSB7XG4gICAgdGhyb3cgcmVzcG9uc2UuYm9keSgpO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWxpZCB1c2VyIGlzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbi4gVGhyb3dzIGFuIGV4Y2VwdGlvblxuICogaW4gY2FzZSBvZiBhbiBpbnZhbGlkIHVzZXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IHVzZXIgVGhlIHVzZXIgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VXNlclNpZ25lZEluKHVzZXIpIHtcbiAgaWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbCh1c2VyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgc2lnbmVkLWluIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24nKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBVUkwgd2l0aCBhIHZhbGlkIHBhdGggaXMgcHJvdmlkZWQuIFRocm93cyBhbiBleGNlcHRpb25cbiAqIGlmIHRoZSBwcm92aWRlZCBVUkwgZG9lc24ndCBoYXZlIGEgdmFsaWQgcGF0aC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXJyb3JNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHByb3ZpZGVkIHRvIHRoZSBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVyaVdpdGhOb1BhdGgodXJsLCBlcnJvck1lc3NhZ2UpIHtcbiAgbGV0IHVyaSA9IG5ldyBVcmkodXJsKTtcbiAgaWYgKHVyaS5nZXRQYXRobmFtZSgpLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQsXG4gIGFzc2VydERlZkFuZE5vdE51bGwsXG4gIGFzc2VydE5vdE51bGwsXG4gIGFzc2VydEZ1bmN0aW9uLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxuICBhc3NlcnRVc2VyU2lnbmVkSW4sXG4gIGFzc2VydFVyaVdpdGhOb1BhdGgsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9hc3NlcnRpb25zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBGaWx0ZXJCb2R5IGZyb20gJy4vRmlsdGVyQm9keSc7XG5pbXBvcnQgR2VvIGZyb20gJy4vR2VvJztcbmltcG9ydCBSYW5nZSBmcm9tICcuL1JhbmdlJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgZmlsdGVycy5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgRW1ib2RpZWQge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSBvcGVyYXRvck9yVmFsdWUgSWYgYSB0aGlyZCBwYXJhbSBpcyBnaXZlbiwgdGhpcyBzaG91bGRcblx0ICogICBiZSB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3IgKGxpa2UgXCI+PVwiKS4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgYmVcblx0ICogICB1c2VkIGFzIHRoZSBmaWx0ZXIncyB2YWx1ZSwgYW5kIHRoZSBmaWx0ZXIncyBvcGVyYXRvciB3aWxsIGJlIFwiPVwiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ib2R5XyA9IG5ldyBGaWx0ZXJCb2R5KGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0ZpbHRlcn0gUmV0dXJucyB0aGUge0BsaW5rIEZpbHRlcn0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgYWRkKG9wZXJhdG9yLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICBsZXQgZmlsdGVyID0gZmllbGRPckZpbHRlclxuICAgICAgPyBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKVxuICAgICAgOiBudWxsO1xuICAgIHRoaXMuYm9keV8uYWRkKG9wZXJhdG9yLCBmaWx0ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgZmlsdGVycyB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7Li4uKn0gZmlsdGVycyBBIHZhcmlhYmxlIGFtb3VudCBvZiBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkLlxuXHQgKiBAcmV0dXJuIHtGaWx0ZXJ9IFJldHVybnMgdGhlIHtAbGluayBGaWx0ZXJ9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpIHtcbiAgICB0aGlzLmJvZHlfLmFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJhbmRcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RmlsdGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRmlsdGVyfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBhbmQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKCdhbmQnLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiYW55XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fCp9IHZhbHVlcyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqICAgdGhlIFwiYW55XCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqICAgc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgYW55KGZpZWxkLCAuLi52YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICdhbnknLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3BcIiBvcGVyYXRvci5cblx0ICogVGhpcyBpcyBhIHNwZWNpYWwgdXNlIGNhc2Ugb2YgYEZpbHRlci5wb2x5Z29uYCBmb3IgYm91bmRpbmdcblx0ICogYm94ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGJveE9yVXBwZXJMZWZ0IEVpdGhlciBhIGBHZW8uQm91bmRpbmdCb3hgIGluc3RhbmNlLCBvclxuXHQgKiAgIGEgYm91bmRpbmcgYm94J3MgdXBwZXIgbGVmdCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbG93ZXJSaWdodCBBIGJvdW5kaW5nIGJveCdzIGxvd2VyIHJpZ2h0IGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG4gICAgaWYgKGJveE9yVXBwZXJMZWZ0IGluc3RhbmNlb2YgR2VvLkJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gRmlsdGVyLnBvbHlnb24oZmllbGQsIC4uLmJveE9yVXBwZXJMZWZ0LmdldFBvaW50cygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCBib3hPclVwcGVyTGVmdCwgb3B0X2xvd2VyUmlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9XG5cdCAqL1xuICBib2R5KCkge1xuICAgIHJldHVybiB0aGlzLmJvZHlfLmdldE9iamVjdCgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYSBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBkaXN0YW5jZSB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSB7XG4gICAgbGV0IGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZTtcbiAgICBsZXQgcmFuZ2UgPSBvcHRfcmFuZ2VPckRpc3RhbmNlO1xuICAgIGlmIChsb2NhdGlvbk9yQ2lyY2xlIGluc3RhbmNlb2YgR2VvLkNpcmNsZSkge1xuICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbk9yQ2lyY2xlLmdldENlbnRlcigpO1xuICAgICAgcmFuZ2UgPSBSYW5nZS50byhsb2NhdGlvbk9yQ2lyY2xlLmdldFJhZGl1cygpKTtcbiAgICB9IGVsc2UgaWYgKCEob3B0X3JhbmdlT3JEaXN0YW5jZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgcmFuZ2UgPSBSYW5nZS50byhvcHRfcmFuZ2VPckRpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbHRlci5kaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuIFRoaXNcblx0ICogaXMganVzdCBhbiBpbnRlcm5hbCBoZWxwZXIgdXNlZCBieSBgRmlsdGVyLmRpc3RhbmNlYC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gQSBsb2NhdGlvbiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSBBIGBSYW5nZWAgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGRpc3RhbmNlSW50ZXJuYWxfKGZpZWxkLCBsb2NhdGlvbiwgcmFuZ2UpIHtcbiAgICBsZXQgdmFsdWUgPSB7XG4gICAgICBsb2NhdGlvbjogRW1ib2RpZWQudG9Cb2R5KGxvY2F0aW9uKSxcbiAgICB9O1xuICAgIHJhbmdlID0gcmFuZ2UuYm9keSgpO1xuICAgIGlmIChyYW5nZS5mcm9tKSB7XG4gICAgICB2YWx1ZS5taW4gPSByYW5nZS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmFuZ2UudG8pIHtcbiAgICAgIHZhbHVlLm1heCA9IHJhbmdlLnRvO1xuICAgIH1cbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ2QnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImV4aXN0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGV4aXN0cyhmaWVsZCkge1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdleGlzdHMnLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImZ1enp5XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBmdXp6eShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG4gICAgcmV0dXJuIEZpbHRlci5mdXp6eUludGVybmFsXyhcbiAgICAgICdmdXp6eScsXG4gICAgICBmaWVsZE9yUXVlcnksXG4gICAgICBvcHRfcXVlcnlPckZ1enppbmVzcyxcbiAgICAgIG9wdF9mdXp6aW5lc3NcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIGdpdmVuIGZ1enp5IG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGFuIGludGVybmFsIGltcGxlbWVudGF0aW9uIHVzZWQgYnkgdGhlIGBGaWx0ZXIuZnV6enlgIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBmdXp6eSBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IG9wdF9xdWVyeU9yRnV6emluZXNzIElmIHRoaXMgaXMgYSBzdHJpbmcsIGl0IHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBiZSB0aGUgZnV6emluZXNzIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mdXp6aW5lc3MgVGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZnV6enlJbnRlcm5hbF8oXG4gICAgb3BlcmF0b3IsXG4gICAgZmllbGRPclF1ZXJ5LFxuICAgIG9wdF9xdWVyeU9yRnV6emluZXNzLFxuICAgIG9wdF9mdXp6aW5lc3NcbiAgKSB7XG4gICAgbGV0IGFyZzJJc1N0cmluZyA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5T3JGdXp6aW5lc3MpO1xuXG4gICAgbGV0IHZhbHVlID0ge1xuICAgICAgcXVlcnk6IGFyZzJJc1N0cmluZyA/IG9wdF9xdWVyeU9yRnV6emluZXNzIDogZmllbGRPclF1ZXJ5LFxuICAgIH07XG4gICAgbGV0IGZ1enppbmVzcyA9IGFyZzJJc1N0cmluZyA/IG9wdF9mdXp6aW5lc3MgOiBvcHRfcXVlcnlPckZ1enppbmVzcztcbiAgICBpZiAoZnV6emluZXNzKSB7XG4gICAgICB2YWx1ZS5mdXp6aW5lc3MgPSBmdXp6aW5lc3M7XG4gICAgfVxuXG4gICAgbGV0IGZpZWxkID0gYXJnMklzU3RyaW5nID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCBvcGVyYXRvciwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPlwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBndChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJz4nLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBndGUoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc+PScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm1hdGNoXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWF0Y2goZmllbGRPclF1ZXJ5LCBvcHRfcXVlcnkpIHtcbiAgICBsZXQgZmllbGQgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuICAgIGxldCBxdWVyeSA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IG9wdF9xdWVyeSA6IGZpZWxkT3JRdWVyeTtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnbWF0Y2gnLCBxdWVyeSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJtaXNzaW5nXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdtaXNzaW5nJywgbnVsbCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJwaHJhc2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBwaHJhc2UoZmllbGRPclF1ZXJ5LCBvcHRfcXVlcnkpIHtcbiAgICBsZXQgZmllbGQgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuICAgIGxldCBxdWVyeSA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IG9wdF9xdWVyeSA6IGZpZWxkT3JRdWVyeTtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncGhyYXNlJywgcXVlcnkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3BcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hT2JqZWN0fSBwb2ludHMgT2JqZWN0cyByZXByZXNlbnRpbmcgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgcG9seWdvbihmaWVsZCwgLi4ucG9pbnRzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLm1hcChwb2ludCA9PiBFbWJvZGllZC50b0JvZHkocG9pbnQpKTtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ3AnLCBwb2ludHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwicHJlZml4XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuIE90aGVyd2lzZSxcblx0ICogICB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBwcmVmaXgoZmllbGRPclF1ZXJ5LCBvcHRfcXVlcnkpIHtcbiAgICBsZXQgZmllbGQgPSBjb3JlLmlzRGVmQW5kTm90TnVsbChvcHRfcXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcbiAgICBsZXQgcXVlcnkgPSBjb3JlLmlzRGVmQW5kTm90TnVsbChvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwcmVmaXgnLCBxdWVyeSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgcmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcbiAgICBsZXQgcmFuZ2UgPSByYW5nZU9yTWluO1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICByYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JNaW4sIG9wdF9tYXgpO1xuICAgIH1cbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncmFuZ2UnLCByYW5nZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJ+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHJlZ2V4KGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnficsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHNoYXBlcyBPYmplY3RzIHJlcHJlc2VudGluZyBzaGFwZXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBzaGFwZShmaWVsZCwgLi4uc2hhcGVzKSB7XG4gICAgc2hhcGVzID0gc2hhcGVzLm1hcChzaGFwZSA9PiBFbWJvZGllZC50b0JvZHkoc2hhcGUpKTtcbiAgICBsZXQgdmFsdWUgPSB7XG4gICAgICB0eXBlOiAnZ2VvbWV0cnljb2xsZWN0aW9uJyxcbiAgICAgIGdlb21ldHJpZXM6IHNoYXBlcyxcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdncycsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInNpbWlsYXJcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHNpbWlsYXIoZmllbGRPclF1ZXJ5LCBxdWVyeSkge1xuICAgIGxldCBmaWVsZCA9IGNvcmUuaXNTdHJpbmcocXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcbiAgICBsZXQgdmFsdWUgPSB7XG4gICAgICBxdWVyeTogY29yZS5pc1N0cmluZyhxdWVyeSkgPyBxdWVyeSA6IGZpZWxkT3JRdWVyeSxcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdzaW1pbGFyJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBsdChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJzwnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBsdGUoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8PScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vbmVcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwqKX0gdmFsdWUgQSB2YXJpYWJsZSBhbW91bnQgb2YgdmFsdWVzIHRvIGJlIHVzZWQgd2l0aFxuXHQgKiB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIG5vbmUoZmllbGQsIC4uLnZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkodmFsdWVzWzBdKSkge1xuICAgICAgdmFsdWVzID0gdmFsdWVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJ25vbmUnLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiIT1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbm90RXF1YWwoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICchPScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vdFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIG5vdChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLnRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkuYWRkKFxuICAgICAgJ25vdCdcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkIGJlIHRoZVxuXHQgKiBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZSB1c2VkIGFzIHRoZVxuXHQgKiBmaWx0ZXIncyB2YWx1ZSwgYW5kIHRoZSBmaWx0ZXIncyBvcGVyYXRvciB3aWxsIGJlIFwiPVwiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZmllbGQoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwib3JcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0ZpbHRlcn0gUmV0dXJucyB0aGUge0BsaW5rIEZpbHRlcn0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgb3IoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKCdvcicsIGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGFyZ3VtZW50cyBpbnRvIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKi9cbiAgc3RhdGljIHRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGxldCBmaWx0ZXIgPSBmaWVsZE9yRmlsdGVyO1xuICAgIGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcbiAgICAgIGZpbHRlciA9IEZpbHRlci5maWVsZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnN0YW50IHRoYXQgcmVwcmVzZW50cyBhbGwgZmllbGRzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuRmlsdGVyLkFMTCA9ICcqJztcblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9GaWx0ZXIuanMiLCJsZXQgZ2xvYmFscyA9IHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFscy53aW5kb3cgPSB3aW5kb3c7XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9nbG9iYWxzL2dsb2JhbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBVcmkgPSByZXF1aXJlKCcuL2xpYi9VcmknKS5kZWZhdWx0O1xuXG5pZiAodHlwZW9mIFVSTCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG5cdC8vIElmIHRoZXJlIGlzIG5vIFwiZG9jdW1lbnRcIiwgdGhlbiB0aGlzIHNob3VsZCBiZSBydW5uaW5nIGluIE5vZGVKUyBvciBpbiBSZWFjdE5hdGl2ZSBlbnYgYW5kXG5cdC8vIGluIHRoaXMgY2FzZSB3ZSBzaG91bGQgdXNlIHRoZSBcInVybFwiIE5QTSBtb2R1bGUgYXMgdGhlIHBhcnNlIGZ1bmN0aW9uLlxuXHQvLyBJbiBSZWFjdE5hdGl2ZSBlbnYgXCJwYXRoXCIgd2lsbCBiZSByZXBsYWNlZCB3aXRoIFwicGF0aC1icm93c2VyaWZ5XCIuXG5cblx0dmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cdHZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuXHRVcmkuc2V0UGFyc2VGbihmdW5jdGlvbih1cmxTdHIpIHtcblx0XHR2YXIgcGFyc2VkID0gdXJsLnBhcnNlKHVybFN0cik7XG5cdFx0cGFyc2VkLnBhdGhuYW1lID0gcGF0aC5ub3JtYWxpemUocGFyc2VkLnBhdGhuYW1lKTtcblx0XHRyZXR1cm4gcGFyc2VkO1xuXHR9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVcmk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtdXJpL25vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IEFnZ3JlZ2F0aW9uIGZyb20gJy4vQWdncmVnYXRpb24nO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBxdWVyaWVzLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBRdWVyeSBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuXG5cdCAqICAge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImNvdW50XCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGNvdW50KCkge1xuICAgIHJldHVybiBuZXcgUXVlcnkoKS50eXBlKCdjb3VudCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJmZXRjaFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBmZXRjaCgpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSgnZmV0Y2gnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIHRoaXMgUXVlcnkuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkuZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgb2Zmc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZW50cnkgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWRcblx0ICogICBieSB0aGlzIHF1ZXJ5LlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBvZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLm9mZnNldChvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBoaWdobGlnaHQgZW50cnkgdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgaGlnaGxpZ2h0KGZpZWxkKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLmhpZ2hsaWdodChmaWVsZCk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgbGltaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRoYXQgdGhpcyBxdWVyeSBzaG91bGRcblx0ICogICByZXR1cm4uXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGxpbWl0KGxpbWl0KSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLmxpbWl0KGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIHtAbGluayBGaWx0ZXJ9XG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUXVlcnkoKS5zZWFyY2goXG4gICAgICBmaWx0ZXJPclRleHRPckZpZWxkLFxuICAgICAgb3B0X3RleHRPck9wZXJhdG9yLFxuICAgICAgb3B0X3ZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgc29ydCBlbnRyeSB0byB0aGlzIHF1ZXJ5LCBzcGVjaWZ5aW5nIHRoZSBmaWVsZCB0aGlzIHF1ZXJ5IHNob3VsZCBiZVxuXHQgKiBzb3J0ZWQgYnkgYW5kLCBvcHRpb25hbGx5LCB0aGUgc29ydCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIHNvcnRlZCBieS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIHNvcnQgb3BlcmF0aW9uIHNob3VsZCB1c2UuXG5cdCAqICAgSWYgbm9uZSBpcyBnaXZlbiwgXCJhc2NcIiBpcyB1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkuc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHF1ZXJ5J3MgdHlwZS4gRm9yIGV4YW1wbGU6IFwiY291bnRcIiwgXCJmZXRjaFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0eXBlKHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSh0eXBlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGFuIGFnZ3JlZ2F0aW9uIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGFnZ3JlZ2F0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUFnZ3JlZ2F0aW9ufHN0cmluZ30gYWdncmVnYXRpb25PckZpZWxkIEVpdGhlciBhblxuXHQgKiAgIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4ge1F1ZXJ5fSBSZXR1cm5zIHRoZSB7QGxpbmsgUXVlcnl9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBhZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpIHtcbiAgICBsZXQgYWdncmVnYXRpb24gPSBhZ2dyZWdhdGlvbk9yRmllbGQ7XG4gICAgaWYgKCEoYWdncmVnYXRpb24gaW5zdGFuY2VvZiBBZ2dyZWdhdGlvbikpIHtcbiAgICAgIGFnZ3JlZ2F0aW9uID0gQWdncmVnYXRpb24uZmllbGQoYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpO1xuICAgIH1cblxuICAgIGxldCBmaWVsZCA9IGFnZ3JlZ2F0aW9uLmdldEZpZWxkKCk7XG4gICAgbGV0IHZhbHVlID0ge307XG4gICAgdmFsdWVbZmllbGRdID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIG9wZXJhdG9yOiBhZ2dyZWdhdGlvbi5nZXRPcGVyYXRvcigpLFxuICAgIH07XG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGFnZ3JlZ2F0aW9uLmdldFZhbHVlKCkpKSB7XG4gICAgICB2YWx1ZVtmaWVsZF0udmFsdWUgPSBhZ2dyZWdhdGlvbi5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbikge1xuICAgICAgdGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbiA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJvZHlfLmFnZ3JlZ2F0aW9uLnB1c2godmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX0gUmV0dXJucyB0aGUge0BsaW5rIFF1ZXJ5fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSgnY291bnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIGZldGNoKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUoJ2ZldGNoJyk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIFF1ZXJ5LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX0gUmV0dXJucyB0aGUge0BsaW5rIFF1ZXJ5fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGxldCBmaWx0ZXIgPSBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcbiAgICBpZiAoIXRoaXMuYm9keV8uZmlsdGVyKSB7XG4gICAgICB0aGlzLmJvZHlfLmZpbHRlciA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJvZHlfLmZpbHRlci5wdXNoKGZpbHRlci5ib2R5KCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICAgYnkgdGhpcyBxdWVyeS5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLmJvZHlfLm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4ge1F1ZXJ5fSBSZXR1cm5zIHRoZSB7QGxpbmsgUXVlcnl9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBoaWdobGlnaHQoZmllbGQpIHtcbiAgICBpZiAoIXRoaXMuYm9keV8uaGlnaGxpZ2h0KSB7XG4gICAgICB0aGlzLmJvZHlfLmhpZ2hsaWdodCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuYm9keV8uaGlnaGxpZ2h0LnB1c2goZmllbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IGxpbWl0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcXVlcnkgc2hvdWxkXG5cdCAqICAgcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX0gUmV0dXJucyB0aGUge0BsaW5rIFF1ZXJ5fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLmJvZHlfLmxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHNlYXJjaCB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmc9fSBmaWx0ZXJPclRleHRPckZpZWxkIElmIG5vIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIGFyZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgZWl0aGVyIGEge0BsaW5rIEZpbHRlcn1cblx0ICogICBpbnN0YW5jZSBvciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhIG1hdGNoIGZpbHRlci4gSW4gYm90aCBjYXNlc1xuXHQgKiAgIHRoZSBmaWx0ZXIgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBmaWVsZHMuIEFub3RoZXIgb3B0aW9uIGlzIHRvXG5cdCAqICAgcGFzcyB0aGlzIGFzIGEgZmllbGQgbmFtZSBpbnN0ZWFkLCB0b2dldGhlciB3aXRoIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIHNvIHRoZSBmaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuIElmIHRoZSB2YWx1ZSBvZiB0aGlzIHBhcmFtZXRlciBpc1xuXHQgKiAgIHVuZGVmaW5lZCBvciBudWxsLCBubyBmaWx0ZXIgd2lsbCBiZSBwcm92aWRlZCB0byB0aGUgc2VhcmNoIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEByZXR1cm4ge1F1ZXJ5fSBSZXR1cm5zIHRoZSB7QGxpbmsgUXVlcnl9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBzZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcbiAgICBsZXQgZmlsdGVyID0gZmlsdGVyT3JUZXh0T3JGaWVsZDtcblxuICAgIGlmIChvcHRfdmFsdWUpIHtcbiAgICAgIGZpbHRlciA9IEZpbHRlci5maWVsZChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChvcHRfdGV4dE9yT3BlcmF0b3IpIHtcbiAgICAgIGZpbHRlciA9IEZpbHRlci5tYXRjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IpO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyICYmICEoZmlsdGVyIGluc3RhbmNlb2YgRmlsdGVyKSkge1xuICAgICAgZmlsdGVyID0gRmlsdGVyLm1hdGNoKGZpbHRlck9yVGV4dE9yRmllbGQpO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSgnc2VhcmNoJyk7XG5cbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICB0aGlzLmZpbHRlcihmaWx0ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBzb3J0IGVudHJ5IHRvIHRoaXMgcXVlcnksIHNwZWNpZnlpbmcgdGhlIGZpZWxkIHRoaXMgcXVlcnkgc2hvdWxkIGJlXG5cdCAqIHNvcnRlZCBieSBhbmQsIG9wdGlvbmFsbHksIHRoZSBzb3J0IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkIHVzZS5cblx0ICogICBJZiBub25lIGlzIGdpdmVuLCBcImFzY1wiIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuYm9keV8uc29ydCkge1xuICAgICAgdGhpcy5ib2R5Xy5zb3J0ID0gW107XG4gICAgfVxuICAgIGxldCBzb3J0RW50cnkgPSB7fTtcbiAgICBzb3J0RW50cnlbZmllbGRdID0gb3B0X2RpcmVjdGlvbiB8fCAnYXNjJztcbiAgICB0aGlzLmJvZHlfLnNvcnQucHVzaChzb3J0RW50cnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBxdWVyeSdzIHR5cGUuIEZvciBleGFtcGxlOiBcImNvdW50XCIsIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIHR5cGUodHlwZSkge1xuICAgIHRoaXMuYm9keV8udHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVlcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpLXF1ZXJ5L1F1ZXJ5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcmFuZ2Ugb2JqZWN0cyB0byBiZSB1c2VkIGJ5IGBGaWx0ZXJgLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBSYW5nZSBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSBvcHRfdG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihmcm9tLCBvcHRfdG8pIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmcm9tKSkge1xuICAgICAgdGhpcy5ib2R5Xy5mcm9tID0gZnJvbTtcbiAgICB9XG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90bykpIHtcbiAgICAgIHRoaXMuYm9keV8udG8gPSBvcHRfdG87XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZnJvbShmcm9tKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBmcm9tXG5cdCAqIEBwYXJhbSB7Kn0gdG9cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgcmFuZ2UoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0byh0bykge1xuICAgIHJldHVybiBuZXcgUmFuZ2UobnVsbCwgdG8pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9SYW5nZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHthc3NlcnREZWZBbmROb3ROdWxsfSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRpbmcgQVBJIGNhbGxzLlxuICovXG5jbGFzcyBBcGlIZWxwZXIge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshV2VEZXBsb3l9IHdlZGVwbG95Q2xpZW50IHtAbGluayBXZURlcGxveX0gY2xpZW50IHJlZmVyZW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoXG4gICAgICB3ZWRlcGxveUNsaWVudCxcbiAgICAgICdXZURlcGxveSBjbGllbnQgcmVmZXJlbmNlIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICk7XG4gICAgdGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuICAgIHRoaXMuaGVhZGVyc18gPSBuZXcgTXVsdGlNYXAoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXNcblx0ICogcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V9IFJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBoZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge0FwaUhlbHBlcn1cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgYXV0aChhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCkge1xuICAgIHRoaXMuaGVscGVyQXV0aFNjb3BlID0gQXV0aC5jcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpO1xuICAgIHRoaXMuaGVscGVyQXV0aFNjb3BlLndlZGVwbG95Q2xpZW50ID0gdGhpcy53ZWRlcGxveUNsaWVudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBcGlIZWxwZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL0FwaUhlbHBlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtjb3JlLCBpc0RlZiwgaXNEZWZBbmROb3ROdWxsLCBpc09iamVjdCwgaXNTdHJpbmd9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7TXVsdGlNYXB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG5pbXBvcnQge1xuICBhc3NlcnREZWZBbmROb3ROdWxsLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxufSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBBdXRoIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PckVtYWlsIEVpdGhlciB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiwgb3Jcblx0ICogICB0aGUgdXNlcm5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgdXNlcm5hbWUgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih0b2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCA9IG51bGwpIHtcbiAgICB0aGlzLnRva2VuID0gY29yZS5pc1N0cmluZyhvcHRfcGFzc3dvcmQpID8gbnVsbCA6IHRva2VuT3JFbWFpbDtcbiAgICB0aGlzLmVtYWlsID0gY29yZS5pc1N0cmluZyhvcHRfcGFzc3dvcmQpID8gdG9rZW5PckVtYWlsIDogbnVsbDtcbiAgICB0aGlzLnBhc3N3b3JkID0gb3B0X3Bhc3N3b3JkO1xuXG4gICAgdGhpcy5jcmVhdGVkQXQgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5waG90b1VybCA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0ZWRTY29wZXMgPSBbXTtcbiAgICB0aGlzLndlZGVwbG95Q2xpZW50ID0gbnVsbDtcbiAgICB0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG4gIH1cblxuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoT3JUb2tlbk9yRW1haWwgRWl0aGVyIGFuIGF1dGggaW5zdGFuY2UsIHRoZVxuXHQgKiAgIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yIHRoZSB1c2VybmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSB1c2VybmFtZSBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAcmV0dXJuIHshQXV0aH1cblx0ICovXG4gIHN0YXRpYyBjcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcbiAgICBpZiAoYXV0aE9yVG9rZW5PckVtYWlsIGluc3RhbmNlb2YgQXV0aCkge1xuICAgICAgcmV0dXJuIGF1dGhPclRva2VuT3JFbWFpbDtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGF1dGhPclRva2VuT3JFbWFpbCkgJiYgaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSkge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGF1dGhPclRva2VuT3JFbWFpbCkgJiYgIWlzRGVmKG9wdF9wYXNzd29yZCkpIHtcbiAgICAgIHJldHVybiBuZXcgQXV0aChhdXRoT3JUb2tlbk9yRW1haWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc0RlZkFuZE5vdE51bGwoYXV0aE9yVG9rZW5PckVtYWlsKSAmJlxuICAgICAgaXNPYmplY3QoYXV0aE9yVG9rZW5PckVtYWlsKVxuICAgICkge1xuICAgICAgcmV0dXJuIEF1dGguY3JlYXRlRnJvbURhdGEoYXV0aE9yVG9rZW5PckVtYWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIE1ha2VzIHVzZXIgQXV0aCBmcm9tIGRhdGEgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBzdGF0aWMgY3JlYXRlRnJvbURhdGEoZGF0YSkge1xuICAgIGxldCBhdXRoID0gbmV3IEF1dGgoKTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIGxldCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBkYXRhW2tleV0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGF1dGgsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBhdXRoLnNldFdlZGVwbG95Q2xpZW50KHRoaXMud2VkZXBsb3lDbGllbnQpO1xuICAgIHJldHVybiBhdXRoO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIGNyZWF0ZWQgYXQgZGF0ZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0Q3JlYXRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZWRBdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBlbWFpbC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0RW1haWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1haWw7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgaWQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBwYXNzd29yZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0UGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFzc3dvcmQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgcGhvdG8gdXJsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRQaG90b1VybCgpIHtcbiAgICByZXR1cm4gdGhpcy5waG90b1VybDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBzdXBwb3J0ZWQgc2NvcGVzLlxuXHQgKiBAcmV0dXJuIHthcnJheS48c3RyaW5nPn1cblx0ICovXG4gIGdldFN1cHBvcnRlZFNjb3BlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY29wZXM7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9rZW4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldFRva2VuKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiBjcmVhdGVkIGF0IGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc0NyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5jcmVhdGVkQXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZW1haWwgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzRW1haWwoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZW1haWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgaWQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzSWQoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuaWQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgbmFtZSBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBoYXNOYW1lKCkge1xuICAgIHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGFzc3dvcmQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzUGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucGFzc3dvcmQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGhvdG8gdXJsIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc1Bob3RvVXJsKCkge1xuICAgIHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnBob3RvVXJsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHVzZXIgaGFzIHNjb3Blcy5cblx0ICogQHBhcmFtIHtzdHJpbmd8YXJyYXkuPHN0cmluZz59IHNjb3BlcyBTY29wZSBvciBhcnJheSBvZiBzY29wZXMgdG8gY2hlY2suXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBoYXNTdXBwb3J0ZWRTY29wZXMoc2NvcGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NvcGVzKSkge1xuICAgICAgcmV0dXJuIHNjb3Blcy5ldmVyeSh2YWwgPT4gdGhpcy5zdXBwb3J0ZWRTY29wZXMuaW5kZXhPZih2YWwpID4gLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY29wZXMuaW5kZXhPZihzY29wZXMpID4gLTE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdG9rZW4gaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzVG9rZW4oKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMudG9rZW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgY3JlYXRlZCBhdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNyZWF0ZWRBdFxuXHQgKi9cbiAgc2V0Q3JlYXRlZEF0KGNyZWF0ZWRBdCkge1xuICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcblx0ICovXG4gIHNldEVtYWlsKGVtYWlsKSB7XG4gICAgdGhpcy5lbWFpbCA9IGVtYWlsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIGhlYWRlcnMuXG5cdCAqIEBwYXJhbSB7IU11bHRpTWFwfE9iamVjdH0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSBzZXRcblx0ICovXG4gIHNldEhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICghKGhlYWRlcnMgaW5zdGFuY2VvZiBNdWx0aU1hcCkpIHtcbiAgICAgIGhlYWRlcnMgPSBNdWx0aU1hcC5mcm9tT2JqZWN0KGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGhlYWRlcnMubmFtZXMoKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gaGVhZGVycy5nZXRBbGwobmFtZSk7XG5cbiAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgaWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKi9cbiAgc2V0SWQoaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICovXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcGFzc3dvcmQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuXHQgKi9cbiAgc2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcGhvdG8gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGhvdG9Vcmxcblx0ICovXG4gIHNldFBob3RvVXJsKHBob3RvVXJsKSB7XG4gICAgdGhpcy5waG90b1VybCA9IHBob3RvVXJsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgc3VwcG9ydGVkIHNjb3Blcy5cblx0ICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gc3VwcG9ydGVkU2NvcGVzXG5cdCAqL1xuICBzZXRTdXBwb3J0ZWRTY29wZXMoc3VwcG9ydGVkU2NvcGVzKSB7XG4gICAgdGhpcy5zdXBwb3J0ZWRTY29wZXMgPSBzdXBwb3J0ZWRTY29wZXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuXHQgKi9cbiAgc2V0VG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgV2VEZXBsb3kgY2xpZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gd2VkZXBsb3lDbGllbnRcblx0ICovXG4gIHNldFdlZGVwbG95Q2xpZW50KHdlZGVwbG95Q2xpZW50KSB7XG4gICAgdGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHVzZXIuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtDb21wbGV0YWJsZUZ1dHVyZX1cblx0ICovXG4gIHVwZGF0ZVVzZXIoZGF0YSkge1xuICAgIGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsXygpXG4gICAgICAucGF0aCgnL3VzZXJzJywgdGhpcy5nZXRJZCgpLnRvU3RyaW5nKCkpXG4gICAgICAuYXV0aCh0aGlzKVxuICAgICAgLnBhdGNoKGRhdGEpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERlbGV0ZXMgdGhlIGN1cnJlbnQgdXNlci5cblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuICBkZWxldGVVc2VyKCkge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwodGhpcy5nZXRJZCgpLCAnQ2Fubm90IGRlbGV0ZSB1c2VyIHdpdGhvdXQgaWQnKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VycycsIHRoaXMuZ2V0SWQoKS50b1N0cmluZygpKVxuICAgICAgLmF1dGgodGhpcylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBCdWlsZHMgVVJMIGJ5IGpvaW5pbmcgdGhlIGhlYWRlcnMuXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGJ1aWxkVXJsXygpIHtcbiAgICByZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuICAgICAgLnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuICAgICAgLmhlYWRlcnModGhpcy5oZWFkZXJzXyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9BdXRoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgcHJvdmlkZXIgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgIHRoaXMucHJvdmlkZXJTY29wZSA9IG51bGw7XG4gICAgdGhpcy5yZWRpcmVjdFVyaSA9IG51bGw7XG4gICAgdGhpcy5zY29wZSA9IG51bGw7XG4gIH1cblxuICAvKipcblx0ICogQ2hlY2tzIGlmIHByb3ZpZGVyIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucHJvdmlkZXIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiBzY29wZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc1Byb3ZpZGVyU2NvcGUoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucHJvdmlkZXJTY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQ2hlY2tzIGlmIHJlZGlyZWN0IHVyaSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc1JlZGlyZWN0VXJpKCkge1xuICAgIHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnJlZGlyZWN0VXJpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgaWYgc2NvcGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBoYXNTY29wZSgpIHtcbiAgICByZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5zY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogTWFrZXMgYXV0aG9yaXphdGlvbiB1cmwuIEFuIG9wdGlvbmFsIGF1dGhvcml6YXRpb24gVVJMIG1pZ2h0IGJlIHByb3ZpZGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0X2F1dGhVcmwgT3B0aW9uYWwgYXV0aG9yaXphdGlvbiBVUkwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBhdXRob3JpemF0aW9uIFVSTC5cblx0ICovXG4gIG1ha2VBdXRob3JpemF0aW9uVXJsKG9wdF9hdXRoVXJsKSB7XG4gICAgbGV0IHVyaSA9IG5ldyBVcmkob3B0X2F1dGhVcmwpO1xuXG4gICAgdXJpLnNldFBhdGhuYW1lKCcvb2F1dGgvYXV0aG9yaXplJyk7XG5cbiAgICBpZiAodGhpcy5oYXNQcm92aWRlcigpKSB7XG4gICAgICB1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Byb3ZpZGVyJywgdGhpcy5nZXRQcm92aWRlcigpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzUHJvdmlkZXJTY29wZSgpKSB7XG4gICAgICB1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Byb3ZpZGVyX3Njb3BlJywgdGhpcy5nZXRQcm92aWRlclNjb3BlKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZWRpcmVjdFVyaSgpKSB7XG4gICAgICB1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3JlZGlyZWN0X3VyaScsIHRoaXMuZ2V0UmVkaXJlY3RVcmkoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1Njb3BlKCkpIHtcbiAgICAgIHVyaS5zZXRQYXJhbWV0ZXJWYWx1ZSgnc2NvcGUnLCB0aGlzLmdldFNjb3BlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHByb3ZpZGVyIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gUHJvdmlkZXIgbmFtZS5cblx0ICovXG4gIGdldFByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgcHJvdmlkZXIgc2NvcGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHdpdGggc2NvcGVzLlxuXHQgKi9cbiAgZ2V0UHJvdmlkZXJTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlclNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9LlxuXHQgKi9cbiAgZ2V0UmVkaXJlY3RVcmkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkaXJlY3RVcmk7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyBzY29wZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgd2l0aCBzY29wZXMuXG5cdCAqL1xuICBnZXRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXRzIHByb3ZpZGVyIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHByb3ZpZGVyU2NvcGUgU2NvcGUgc3RyaW5nLiBTZXBhcmF0ZSBieSBzcGFjZSBmb3IgbXVsdGlwbGVcblx0ICogICBzY29wZXMsIGUuZy4gXCJzY29wZTEgc2NvcGUyXCIuXG5cdCAqL1xuICBzZXRQcm92aWRlclNjb3BlKHByb3ZpZGVyU2NvcGUpIHtcbiAgICBhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwoXG4gICAgICBwcm92aWRlclNjb3BlLFxuICAgICAgJ1Byb3ZpZGVyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcnXG4gICAgKTtcbiAgICB0aGlzLnByb3ZpZGVyU2NvcGUgPSBwcm92aWRlclNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmVkaXJlY3RVcmkgVGhlIHJlZGlyZWN0IFVSSSB0byBiZSBzZXQgdG8gdGhlIGN1cnJlbnRcblx0ICogICBpbnN0YW5jZS5cblx0ICovXG4gIHNldFJlZGlyZWN0VXJpKHJlZGlyZWN0VXJpKSB7XG4gICAgYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHJlZGlyZWN0VXJpLCAnUmVkaXJlY3QgdXJpIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB0aGlzLnJlZGlyZWN0VXJpID0gcmVkaXJlY3RVcmk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyBzY29wZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBzY29wZSBTY29wZSBzdHJpbmcuIFNlcGFyYXRlIGJ5IHNwYWNlIGZvciBtdWx0aXBsZVxuXHQgKiAgIHNjb3BlcywgZS5nLiBcInNjb3BlMSBzY29wZTJcIi5cblx0ICovXG4gIHNldFNjb3BlKHNjb3BlKSB7XG4gICAgYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHNjb3BlLCAnU2NvcGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLCBidXQgbm90IGFcbiAqICAgc3RyaW5nLlxuICogQHBhcmFtIHshKn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGVycm9yTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcm92aWRlZCB0byB0aGUgZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpICYmICFjb3JlLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhQcm92aWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9BdXRoUHJvdmlkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3RvcmFnZU1lY2hhbmlzbSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gU3RvcmFnZU1lY2hhbmlzbSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZU1lY2hhbmlzbSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU3RvcmFnZU1lY2hhbmlzbSwgW3tcblx0XHRrZXk6ICdjbGVhcicsXG5cblx0XHQvKipcbiAgICogQ2xlYXIgYWxsIGl0ZW1zIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgYW4gaXRlbSBpbiB0aGUgZGF0YSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXJpYWxpemUgdG8gYSBzdHJpbmcgYW5kIHNhdmUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBnZXQuXG4gICAqIEByZXR1cm4geyp9IERlc2VyaWFsaXplZCB2YWx1ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIG1lY2hhbmlzbSBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgd2hlbiBuZWNlc3NhcnkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdrZXlzJyxcblxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2l6ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG5cdFx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0XHR9XG5cdH1dLCBbe1xuXHRcdGtleTogJ2lzU3VwcG9ydGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gU3RvcmFnZU1lY2hhbmlzbTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RvcmFnZU1lY2hhbmlzbTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtc3RvcmFnZS9saWIvbWVjaGFuaXNtL1N0b3JhZ2VNZWNoYW5pc20uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZ2VvbWV0cmljXG4gKiBzaGFwZXMuXG4gKi9cbmNsYXNzIEdlbyB7XG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBCb3VuZGluZ0JveH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gdXBwZXJMZWZ0IFRoZSB1cHBlciBsZWZ0IHBvaW50LlxuXHQgKiBAcGFyYW0geyp9IGxvd2VyUmlnaHQgVGhlIGxvd2VyIHJpZ2h0IHBvaW50LlxuXHQgKiBAcmV0dXJuIHshQm91bmRpbmdCb3h9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBib3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IEdlby5Cb3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIENpcmNsZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gY2VudGVyIFRoZSBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJhZGl1cyBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHshQ2lyY2xlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgY2lyY2xlKGNlbnRlciwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIG5ldyBHZW8uQ2lyY2xlKGNlbnRlciwgcmFkaXVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBMaW5lfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBsaW5lJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshTGluZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGxpbmUoLi4ucG9pbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBHZW8uTGluZSguLi5wb2ludHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcmV0dXJuIHshUG9pbnR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBwb2ludChsYXQsIGxvbikge1xuICAgIHJldHVybiBuZXcgR2VvLlBvaW50KGxhdCwgbG9uKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshUG9seWdvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHBvbHlnb24oLi4ucG9pbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBHZW8uUG9seWdvbiguLi5wb2ludHMpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcG9pbnQgY29vcmRpbmF0ZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGxhdCwgbG9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHlfID0gW2xhdCwgbG9uXTtcbiAgfVxufVxuR2VvLlBvaW50ID0gUG9pbnQ7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbGluZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgTGluZSBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvciguLi5wb2ludHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYm9keV8gPSB7XG4gICAgICB0eXBlOiAnbGluZXN0cmluZycsXG4gICAgICBjb29yZGluYXRlczogcG9pbnRzLm1hcChwb2ludCA9PiBFbWJvZGllZC50b0JvZHkocG9pbnQpKSxcbiAgICB9O1xuICB9XG59XG5HZW8uTGluZSA9IExpbmU7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgYm91bmRpbmcgYm94LlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBCb3VuZGluZ0JveCBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYm9keV8gPSB7XG4gICAgICB0eXBlOiAnZW52ZWxvcGUnLFxuICAgICAgY29vcmRpbmF0ZXM6IFtFbWJvZGllZC50b0JvZHkodXBwZXJMZWZ0KSwgRW1ib2RpZWQudG9Cb2R5KGxvd2VyUmlnaHQpXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhpcyBib3VuZGluZyBib3gncyBwb2ludHMuXG5cdCAqIEByZXR1cm4geyFBcnJheX1cblx0ICovXG4gIGdldFBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5Xy5jb29yZGluYXRlcztcbiAgfVxufVxuR2VvLkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3g7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2lyY2xlLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIENpcmNsZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gY2VudGVyIFRoZSBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJhZGl1cyBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNlbnRlciwgcmFkaXVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHlfID0ge1xuICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICBjb29yZGluYXRlczogRW1ib2RpZWQudG9Cb2R5KGNlbnRlciksXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhpcyBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7Kn1cblx0ICovXG4gIGdldENlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5Xy5jb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9keV8ucmFkaXVzO1xuICB9XG59XG5HZW8uQ2lyY2xlID0gQ2lyY2xlO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvbHlnb24uXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvbHlnb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIHBvbHlnb24ncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHlfID0ge1xuICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgY29vcmRpbmF0ZXM6IFtdLFxuICAgIH07XG4gICAgdGhpcy5hZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgY29vcmRpbmF0ZXMgZm9yIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cykge1xuICAgIHRoaXMuYm9keV8uY29vcmRpbmF0ZXMucHVzaChwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgYSBob2xlIGluc2lkZSB0aGlzIHBvbHlnb24uXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzXG5cdCAqIEByZXR1cm4ge1BvbHlnb259IFJldHVybnMgdGhlIHtAbGluayBQb2x5Z29ufSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBob2xlKC4uLnBvaW50cykge1xuICAgIHRoaXMuYWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbkdlby5Qb2x5Z29uID0gUG9seWdvbjtcblxuZXhwb3J0IGRlZmF1bHQgR2VvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9HZW8uanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCBtZXNzYWdlIChlLmcuIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlKS5cbiAqL1xuY2xhc3MgQ2xpZW50TWVzc2FnZSB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBDbGllbnRNZXNzYWdlfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGJvZHkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9ib2R5IFJlcXVlc3QgYm9keSB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvZHkgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7Kn0gUmV0dXJucyByZXF1ZXN0IGJvZHkgaWYgbm8gYm9keSB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZVxuXHQgKiAgIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG4gIGJvZHkob3B0X2JvZHkpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keV8gPSBvcHRfYm9keTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ib2R5XztcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXNcblx0ICogcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V9IFJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBoZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGhlYWRlcnMuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X2hlYWRlcnMgUmVxdWVzdCBoZWFkZXJzIGxpc3QgdG9cblx0ICogICBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGhlYWRlcnMgd2lsbFxuXHQgKiAgIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBoZWFkZXJzXG5cdCAqICAgaWYgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgaGVhZGVycyhvcHRfaGVhZGVycykge1xuICAgIGlmIChjb3JlLmlzRGVmKG9wdF9oZWFkZXJzKSkge1xuICAgICAgaWYgKG9wdF9oZWFkZXJzIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzXyA9IG9wdF9oZWFkZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzXy52YWx1ZXMgPSBvcHRfaGVhZGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRfaGVhZGVycztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyc187XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlcyB0aGUgYm9keS5cblx0ICovXG4gIHJlbW92ZUJvZHkoKSB7XG4gICAgdGhpcy5ib2R5XyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9DbGllbnRNZXNzYWdlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC9saWIvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IHtjb3JlfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5pbXBvcnQgQXV0aEFwaUhlbHBlciBmcm9tICcuL2F1dGgvQXV0aEFwaUhlbHBlcic7XG5pbXBvcnQgRGF0YUFwaUhlbHBlciBmcm9tICcuL2RhdGEvRGF0YUFwaUhlbHBlcic7XG5pbXBvcnQgRW1haWxBcGlIZWxwZXIgZnJvbSAnLi9lbWFpbC9FbWFpbEFwaUhlbHBlcic7XG5pbXBvcnQgQmFzZTY0IGZyb20gJy4uL2NyeXB0L0Jhc2U2NCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi4vYXBpLXF1ZXJ5L0VtYm9kaWVkJztcbmltcG9ydCBRdWVyeSBmcm9tICcuLi9hcGktcXVlcnkvUXVlcnknO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi9hcGktcXVlcnkvRmlsdGVyJztcbmltcG9ydCBUcmFuc3BvcnRGYWN0b3J5IGZyb20gJy4vVHJhbnNwb3J0RmFjdG9yeSc7XG5pbXBvcnQgQ2xpZW50UmVxdWVzdCBmcm9tICcuL0NsaWVudFJlcXVlc3QnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQge2Fzc2VydFVyaVdpdGhOb1BhdGh9IGZyb20gJy4vYXNzZXJ0aW9ucyc7XG5cbmxldCBpbztcbmxldCBGb3JtRGF0YUltcGw7XG5cbi8vIE9wdGltaXN0aWMgaW5pdGlhbGl6YXRpb24gb2YgYGlvYCByZWZlcmVuY2UgZnJvbSBnbG9iYWwgYGdsb2JhbHMud2luZG93LmlvYC5cbmlmICh0eXBlb2YgZ2xvYmFscy53aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlvID0gZ2xvYmFscy53aW5kb3cuaW87XG59XG5cbi8vIE9wdGltaXN0aWMgaW5pdGlhbGl6YXRpb24gb2YgYEZvcm1EYXRhYCByZWZlcmVuY2UgZnJvbSBnbG9iYWxcbi8vIGBnbG9iYWxzLndpbmRvdy5Gb3JtRGF0YWAuXG5pZiAodHlwZW9mIGdsb2JhbHMud2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBGb3JtRGF0YUltcGwgPSBnbG9iYWxzLndpbmRvdy5Gb3JtRGF0YTtcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBjbGFzcyBmb3IgbWFraW5nIGFwaSByZXF1ZXN0cy4gU2VuZGluZyByZXF1ZXN0cyByZXR1cm5zIGEgcHJvbWlzZVxuICogdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSByZXNwb25zZSBhcnJpdmVzLiBVc2FnZSBleGFtcGxlOlxuICogYGBgamF2YXNjcmlwdFxuICogV2VEZXBsb3lcbiAqICAgLnVybCgnL2RhdGEvdGFza3MnKVxuICogICAucG9zdCh7ZGVzYzogJ0J1eSBtaWxrJ30pXG4gKiAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgLy8gSGFuZGxlIHJlc3BvbnNlIGhlcmUuXG4gKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2UuYm9keSgpKVxuICogICB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBXZURlcGxveSB7XG4gIC8qKlxuXHQgKiBXZURlcGxveSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSB1cmwuXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRocyBBbnkgYW1vdW50IG9mIHBhdGhzIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBiYXNlXG5cdCAqIHVybC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih1cmwsIC4uLnBhdGhzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMsIHRyeSBgbmV3IFdlRGVwbG95KGJhc2VVcmwsIHVybClgJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRoXyA9IG51bGw7XG4gICAgdGhpcy5kYXRhXyA9IG51bGw7XG4gICAgdGhpcy5ib2R5XyA9IG51bGw7XG4gICAgdGhpcy51cmxfID0gVXJpLmpvaW5QYXRocyh1cmwgfHwgJycsIC4uLnBhdGhzKTtcbiAgICB0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG4gICAgdGhpcy5wYXJhbXNfID0gbmV3IE11bHRpTWFwKCk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHNfID0gdHJ1ZTtcblxuICAgIHRoaXMuaGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHRoaXMuaGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gIH1cblxuICAvKipcblx0ICogU3RhdGljIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFdlRGVwbG95IGRhdGEgZm9yIHRoZSBnaXZlbiB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RhdGFVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgZGF0YSBzZXJ2aWNlcy5cblx0ICogQHJldHVybiB7ZGF0YX0gV2VEZXBsb3kgZGF0YSBpbnN0YW5jZS5cblx0ICovXG4gIHN0YXRpYyBkYXRhKG9wdF9kYXRhVXJsKSB7XG4gICAgYXNzZXJ0VXJpV2l0aE5vUGF0aChvcHRfZGF0YVVybCwgJ1RoZSBkYXRhIHVybCBzaG91bGQgbm90IGhhdmUgYSBwYXRoJyk7XG5cbiAgICBpZiAoY29yZS5pc1N0cmluZyhvcHRfZGF0YVVybCkpIHtcbiAgICAgIFdlRGVwbG95LmRhdGFVcmxfID0gb3B0X2RhdGFVcmw7XG4gICAgfVxuICAgIGlmICghV2VEZXBsb3kuZGF0YV8pIHtcbiAgICAgIFdlRGVwbG95LmRhdGFfID0gbmV3IERhdGFBcGlIZWxwZXIoV2VEZXBsb3kpO1xuICAgIH1cbiAgICBXZURlcGxveS5kYXRhXy5hdXRoKFdlRGVwbG95LmF1dGgoKS5jdXJyZW50VXNlcik7XG4gICAgcmV0dXJuIFdlRGVwbG95LmRhdGFfO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBlbWFpbCBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZW1haWxVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgZW1haWwgc2VydmljZXMuXG5cdCAqIEByZXR1cm4ge2RhdGF9IFdlRGVwbG95IGVtYWlsIGluc3RhbmNlLlxuXHQgKi9cbiAgc3RhdGljIGVtYWlsKG9wdF9lbWFpbFVybCkge1xuICAgIGFzc2VydFVyaVdpdGhOb1BhdGgob3B0X2VtYWlsVXJsLCAnVGhlIGVtYWlsIHVybCBzaG91bGQgbm90IGhhdmUgYSBwYXRoJyk7XG5cbiAgICBpZiAoY29yZS5pc1N0cmluZyhvcHRfZW1haWxVcmwpKSB7XG4gICAgICBXZURlcGxveS5lbWFpbFVybF8gPSBvcHRfZW1haWxVcmw7XG4gICAgfVxuICAgIGlmICghV2VEZXBsb3kuZW1haWxfKSB7XG4gICAgICBXZURlcGxveS5lbWFpbF8gPSBuZXcgRW1haWxBcGlIZWxwZXIoV2VEZXBsb3kpO1xuICAgIH1cbiAgICBXZURlcGxveS5lbWFpbF8uYXV0aChXZURlcGxveS5hdXRoKCkuY3VycmVudFVzZXIpO1xuICAgIHJldHVybiBXZURlcGxveS5lbWFpbF87XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGF1dGgoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcbiAgICB0aGlzLmF1dGhfID0gQXV0aC5jcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpO1xuICAgIHRoaXMuYXV0aF8uc2V0V2VkZXBsb3lDbGllbnQoV2VEZXBsb3kpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBhdXRoIGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9hdXRoVXJsIFRoZSB1cmwgdGhhdCBwb2ludHMgdG8gdGhlIGF1dGggc2VydmljZS5cblx0ICogQHJldHVybiB7IUF1dGh9IFJldHVybnMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKi9cbiAgc3RhdGljIGF1dGgob3B0X2F1dGhVcmwpIHtcbiAgICBpZiAoY29yZS5pc1N0cmluZyhvcHRfYXV0aFVybCkpIHtcbiAgICAgIFdlRGVwbG95LmF1dGhVcmxfID0gb3B0X2F1dGhVcmw7XG4gICAgfVxuICAgIGlmICghV2VEZXBsb3kuYXV0aF8pIHtcbiAgICAgIFdlRGVwbG95LmF1dGhfID0gbmV3IEF1dGhBcGlIZWxwZXIoV2VEZXBsb3kpO1xuICAgIH1cbiAgICByZXR1cm4gV2VEZXBsb3kuYXV0aF87XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgYm9keSB0aGF0IHdpbGwgYmUgc2VudCB3aXRoIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHsqfSBib2R5XG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGJvZHkoYm9keSkge1xuICAgIHRoaXMuYm9keV8gPSBib2R5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBib2R5IG9iamVjdCB0byBxdWVyeSBwYXJhbXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3QgQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb252ZXJ0Qm9keVRvUGFyYW1zXyhjbGllbnRSZXF1ZXN0LCBib2R5KSB7XG4gICAgaWYgKGNvcmUuaXNTdHJpbmcoYm9keSkpIHtcbiAgICAgIGJvZHkgPSB7XG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG4gICAgICBib2R5ID0gYm9keS5ib2R5KCk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGJvZHkgfHwge30pLmZvckVhY2gobmFtZSA9PlxuICAgICAgY2xpZW50UmVxdWVzdC5wYXJhbShuYW1lLCBib2R5W25hbWVdKVxuICAgICk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBjbGllbnQgcmVxdWVzdCBhbmQgZW5jb2RlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNyZWF0ZUNsaWVudFJlcXVlc3RfKG1ldGhvZCwgYm9keSkge1xuICAgIGNvbnN0IGNsaWVudFJlcXVlc3QgPSBuZXcgQ2xpZW50UmVxdWVzdCgpO1xuXG4gICAgY2xpZW50UmVxdWVzdC5ib2R5KGJvZHkgfHwgdGhpcy5ib2R5Xyk7XG5cbiAgICBpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKGNsaWVudFJlcXVlc3QuYm9keSgpKSkge1xuICAgICAgaWYgKHRoaXMuZm9ybURhdGFfKSB7XG4gICAgICAgIGNsaWVudFJlcXVlc3QuYm9keSh0aGlzLmZvcm1EYXRhXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xpZW50UmVxdWVzdC5tZXRob2QobWV0aG9kKTtcbiAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcnModGhpcy5oZWFkZXJzKCkpO1xuICAgIGNsaWVudFJlcXVlc3QucGFyYW1zKHRoaXMucGFyYW1zKCkpO1xuICAgIGNsaWVudFJlcXVlc3QudXJsKHRoaXMudXJsKCkpO1xuICAgIGNsaWVudFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzXyk7XG5cbiAgICB0aGlzLmVuY29kZShjbGllbnRSZXF1ZXN0KTtcblxuICAgIHJldHVybiBjbGllbnRSZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG5cdCAqIERlY29kZXMgY2xpZW50UmVzcG9uc2UgYm9keSwgcGFyc2luZyB0aGUgYm9keSBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVzcG9uc2V9IGNsaWVudFJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3QgdG8gYmVcblx0ICogZGVjb2RlZC5cblx0ICogQHJldHVybiB7IUNsaWVudFJlc3BvbnNlfSBUaGUgZGVjb2RlZCByZXNwb25zZS5cblx0ICovXG4gIGRlY29kZShjbGllbnRSZXNwb25zZSkge1xuICAgIGlmIChXZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbihjbGllbnRSZXNwb25zZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWVudFJlc3BvbnNlLmJvZHkoSlNPTi5wYXJzZShjbGllbnRSZXNwb25zZS5ib2R5KCkpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudFJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgREVMRVRFIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgZGVsZXRlKG9wdF9ib2R5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdERUxFVEUnLCBvcHRfYm9keSk7XG4gIH1cblxuICAvKipcblx0ICogRW5jb2RlcyB0aGUgZ2l2ZW4ge0BsaW5rIENsaWVudFJlcXVlc3R9LCBjb252ZXJ0aW5nIGl0cyBib2R5IHRvIGFuXG5cdCAqIGFwcHJvcHJpYXRlIGZvcm1hdCBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBUaGUgcmVxdWVzdCBvYmplY3QgdG8gZW5jb2RlLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gVGhlIGVuY29kZWQgcmVxdWVzdC5cblx0ICovXG4gIGVuY29kZShjbGllbnRSZXF1ZXN0KSB7XG4gICAgbGV0IGJvZHkgPSBjbGllbnRSZXF1ZXN0LmJvZHkoKTtcblxuICAgIGlmIChjb3JlLmlzRWxlbWVudChib2R5KSkge1xuICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YUltcGwoYm9keSk7XG4gICAgICBjbGllbnRSZXF1ZXN0LmJvZHkoYm9keSk7XG4gICAgfVxuXG4gICAgYm9keSA9IHRoaXMubWF5YmVXcmFwV2l0aFF1ZXJ5Xyhib2R5KTtcbiAgICBpZiAoY2xpZW50UmVxdWVzdC5tZXRob2QoKSA9PT0gJ0dFVCcpIHtcbiAgICAgIHRoaXMuY29udmVydEJvZHlUb1BhcmFtc18oY2xpZW50UmVxdWVzdCwgYm9keSk7XG4gICAgICBjbGllbnRSZXF1ZXN0LnJlbW92ZUJvZHkoKTtcbiAgICAgIGJvZHkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRm9ybURhdGFJbXBsICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgRm9ybURhdGFJbXBsKSB7XG4gICAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKS5yZW1vdmUoJ2NvbnRlbnQtdHlwZScpO1xuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG4gICAgICBjbGllbnRSZXF1ZXN0LmJvZHkoYm9keS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKFdlRGVwbG95LmlzQ29udGVudFR5cGVKc29uKGNsaWVudFJlcXVlc3QpKSB7XG4gICAgICBsZXQgYm9keSA9IGNsaWVudFJlcXVlc3QuYm9keSgpO1xuICAgICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGJvZHkpKSB7XG4gICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY2xpZW50UmVxdWVzdC5ib2R5KGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KTtcbiAgICB0aGlzLnJlc29sdmVBdXRoZW50aWNhdGlvbl8oY2xpZW50UmVxdWVzdCk7XG5cbiAgICByZXR1cm4gY2xpZW50UmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBFbmNvZGVzIHRoZSBwYXJhbXMgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LCBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KSB7XG4gICAgbGV0IHBhcmFtcyA9IGNsaWVudFJlcXVlc3QucGFyYW1zKCk7XG4gICAgcGFyYW1zLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBsZXQgdmFsdWVzID0gcGFyYW1zLmdldEFsbChuYW1lKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3JlLmlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGtleS92YWx1ZSBwYWlyIHRvIGJlIHNlbnQgdmlhIHRoZSBib2R5IGluIGEgYG11bHRpcGFydC9mb3JtLWRhdGFgXG5cdCAqIGZvcm1hdC5cblx0ICogSWYgdGhlIGJvZHkgaXMgc2V0IGJ5IG90aGVyIG1lYW5zIChmb3IgZXhhbXBsZSwgdGhyb3VnaCB0aGUgYGJvZHlgIG1ldGhvZCksXG5cdCAqIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGZvcm0obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIEZvcm1EYXRhSW1wbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2Zvcm0oKSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIEZvcm1EYXRhIEFQSSBpcyBhdmFpbGFibGUuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZm9ybURhdGFfKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhXyA9IG5ldyBGb3JtRGF0YUltcGwoKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtRGF0YV8uYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIEdFVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9wYXJhbXMgUGFyYW1zIHRvIGJlIGFkZGVkIHRvIHRoZSByZXF1ZXN0IHVybC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGdldChvcHRfcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdHRVQnLCBvcHRfcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiB0aGUgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbFxuXHQgKiBub3QgYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhlYWRlciBrZXkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgSGVhZGVyIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtXZURlcGxveX0gUmV0dXJucyB0aGUge0BsaW5rIFdlRGVwbG95fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBoZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyBvciBzZXRzIHRoZSBoZWFkZXJzLiBJZiBoZWFkZXJzIGFyZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFzXG4gICAqIHBhcmFtZXRlciwgdGhleSB3aWxsIGJlIHNldCBhcyBpbnRlcm5hbCBoZWFkZXJzLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICogb25lcy4gT3RoZXJ3aXNlLCB0aGUgY3VycmVudGx5IHNldCBoZWFkZXJzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X2hlYWRlcnMgSGVhZGVycyB0byBiZSBzZXRcblx0ICogQHJldHVybiB7V2VEZXBsb3l8TXVsdGlNYXB9IElmIGhlYWRlcnMgd2VyZSBwYXNzZWQgdG8gdGUgZnVuY3Rpb24sXG4gICAqICAgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzXG4gICAqICAgY2FuIGJlIGNoYWluZWQuIElmIGhlYWRlcnMgd2VyZSBub3QgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiwgdGhlIHJldHVybmVkXG4gICAqICAgcmVzdWx0IHdpbGwgYmUgdGhlIGN1cnJlbnQgaGVhZGVycy5cbiAgICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cbiAgICovXG4gIGhlYWRlcnMob3B0X2hlYWRlcnMpIHtcbiAgICBpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwob3B0X2hlYWRlcnMpKSB7XG4gICAgICBpZiAoIShvcHRfaGVhZGVycyBpbnN0YW5jZW9mIE11bHRpTWFwKSkge1xuICAgICAgICBvcHRfaGVhZGVycyA9IE11bHRpTWFwLmZyb21PYmplY3Qob3B0X2hlYWRlcnMpO1xuICAgICAgfVxuXG4gICAgICBvcHRfaGVhZGVycy5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdF9oZWFkZXJzLmdldEFsbChuYW1lKTtcblxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc187XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrIGlmIGNsaWVudE1lc3NhZ2UgY29udGVudCB0eXBlIGlzIGFwcGxpY2F0aW9uL2pzb24uXG5cdCAqIEBwYXJhbSB7Q2xpZW50TWVzc2FnZX0gY2xpZW50TWVzc2FnZSBDbGllbnQgbWVzc2FnZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIHN0YXRpYyBpc0NvbnRlbnRUeXBlSnNvbihjbGllbnRNZXNzYWdlKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBjbGllbnRNZXNzYWdlLmhlYWRlcnMoKS5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuICAgIHJldHVybiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IDA7XG4gIH1cblxuICAvKipcblx0ICogV3JhcHMgdGhlIGdpdmVuIGBFbWJvZGllZGAgaW5zdGFuY2Ugd2l0aCBhIHtAbGluayBRdWVyeX0gaW5zdGFuY2UgaWZcblx0ICogbmVlZGVkLlxuXHQgKiBAcGFyYW0ge0VtYm9kaWVkfSBlbWJvZGllZFxuXHQgKiBAcmV0dXJuIHtFbWJvZGllZH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbWF5YmVXcmFwV2l0aFF1ZXJ5XyhlbWJvZGllZCkge1xuICAgIGlmIChlbWJvZGllZCBpbnN0YW5jZW9mIEZpbHRlcikge1xuICAgICAgZW1ib2RpZWQgPSBRdWVyeS5maWx0ZXIoZW1ib2RpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gZW1ib2RpZWQ7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiB0aGUgcXVlcnkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdFxuXHQgKiBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUGFyYW0ga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFBhcmFtIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtXZURlcGxveX0gUmV0dXJucyB0aGUge0BsaW5rIFdlRGVwbG95fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBwYXJhbShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHF1ZXJ5IHN0cmluZ3MgbWFwLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuICBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBBVENIIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgcGF0Y2gob3B0X2JvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BBVENIJywgb3B0X2JvZHkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIHVybCByZXN1bHRpbmcgaW5cblx0ICogdGhlIHVuaW9uIG9mIHRoZSBjdXJyZW50IHVybCB3aXRoIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMuXG5cdCAqIEByZXR1cm4geyFXZURlcGxveX0gQSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGdpdmVuXG5cdCAqICAgcGF0aHMuXG5cdCAqL1xuICBwYXRoKC4uLnBhdGhzKSB7XG4gICAgbGV0IHdlZGVwbG95Q2xpZW50ID0gbmV3IFdlRGVwbG95KHRoaXMudXJsKCksIC4uLnBhdGhzKTtcblxuICAgIGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLmF1dGhfKSkge1xuICAgICAgd2VkZXBsb3lDbGllbnQuYXV0aCh0aGlzLmF1dGhfKTtcbiAgICB9XG5cbiAgICB3ZWRlcGxveUNsaWVudC5oZWFkZXJzKHRoaXMuaGVhZGVyc18pO1xuXG4gICAgcmV0dXJuIHdlZGVwbG95Q2xpZW50LnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUE9TVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIHBvc3Qob3B0X2JvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BPU1QnLCBvcHRfYm9keSk7XG4gIH1cblxuICAvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQVVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBwdXQob3B0X2JvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BVVCcsIG9wdF9ib2R5KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIHRoZSBhdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbiB0byB0aGUgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpIHtcbiAgICBpZiAoIXRoaXMuYXV0aF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aF8uaGFzVG9rZW4oKSkge1xuICAgICAgY2xpZW50UmVxdWVzdC5oZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLmF1dGhfLnRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aF8uaGFzRW1haWwoKSAmJiB0aGlzLmF1dGhfLmhhc1Bhc3N3b3JkKCkpIHtcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy5hdXRoXy5lbWFpbCArICc6JyArIHRoaXMuYXV0aF8ucGFzc3dvcmQ7XG4gICAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcihcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nLFxuICAgICAgICAnQmFzaWMgJyArIEJhc2U2NC5lbmNvZGVTdHJpbmcoY3JlZGVudGlhbHMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VzIHRyYW5zcG9ydCB0byBzZW5kIHJlcXVlc3Qgd2l0aCBnaXZlbiBtZXRob2QgbmFtZSBhbmQgYm9keVxuXHQgKiBhc3luY2hyb25vdXNseS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgSFRUUCBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIHNlbmRpbmcgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gRGVmZXJyZWQgcmVxdWVzdC5cblx0ICovXG4gIHNlbmRBc3luYyhtZXRob2QsIGJvZHkpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPVxuICAgICAgdGhpcy5jdXN0b21UcmFuc3BvcnRfIHx8IFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2UoKS5nZXREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XyhtZXRob2QsIGJvZHkpO1xuXG4gICAgcmV0dXJuIHRyYW5zcG9ydC5zZW5kKGNsaWVudFJlcXVlc3QpLnRoZW4odGhpcy5kZWNvZGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHNvY2tldCB0cmFuc3BvcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHNvY2tldCBpbXBsZW1lbnRhdGlvbiBvYmplY3QuXG5cdCAqL1xuICBzdGF0aWMgc29ja2V0KHNvY2tldCkge1xuICAgIGlvID0gc29ja2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIEZvcm1EYXRhXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtRGF0YSBpbXBsZW1lbnRhdGlvbiBvYmplY3QuXG5cdCAqL1xuICBzdGF0aWMgZm9ybURhdGEoZm9ybURhdGEpIHtcbiAgICBGb3JtRGF0YUltcGwgPSBmb3JtRGF0YTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgY2xpZW50IGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB1c2UgZm9yIHNlbmRpbmdcblx0ICogICByZXF1ZXN0cy5cblx0ICogQHJldHVybiB7V2VEZXBsb3l9IFJldHVybnMgdGhlIHtAbGluayBXZURlcGxveX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICovXG4gIHN0YXRpYyB1cmwodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBXZURlcGxveSh1cmwpLnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIFVSTCB1c2VkIGJ5IHRoaXMgY2xpZW50LlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKi9cbiAgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnVybF87XG4gIH1cblxuICAvKipcblx0ICogU3BlY2lmaWVzIHtAbGluayBUcmFuc3BvcnR9IGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcGFyYW0geyFUcmFuc3BvcnR9IHRyYW5zcG9ydCBUaGUgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uIHRoYXQgc2hvdWxkIGJlXG5cdCAqIHVzZWQuXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqL1xuICB1c2UodHJhbnNwb3J0KSB7XG4gICAgdGhpcy5jdXN0b21UcmFuc3BvcnRfID0gdHJhbnNwb3J0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gVGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHNvY2tldC5pb1xuXHQgKiBjb25zdHJ1Y3RvciB3aWxsIGJlIHByb3ZpZGVkOlxuXHQgKlxuXHQgKiBgYGBqYXZhc2NyaXB0XG5cdCAqIFdlRGVwbG95LnVybCgnaHR0cDovL2RvbWFpbjo4MDgwL3BhdGgvYScpLndhdGNoKHtpZDogJ215SWQnfSwge2ZvbzogdHJ1ZX0pO1xuXHQgKiAvLyBFcXVhbHM6XG5cdCAqIGlvKCdkb21haW46ODA4MC8/dXJsPXBhdGglMkZhJTNGaWQlM0RteUlkJywge2ZvbzogdHJ1ZX0pO1xuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zIFBhcmFtcyB0byBiZSBzZW50IHdpdGggdGhlIFNvY2tldCBJTyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIE9iamVjdCB3aXRoIFNvY2tldCBJTyBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHshaW99IFNvY2tldCBJTyByZWZlcmVuY2UuIFNlcnZlciBldmVudHMgY2FuIGJlIGxpc3RlbmVkIG9uIGl0LlxuXHQgKi9cbiAgd2F0Y2gob3B0X3BhcmFtcywgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGlvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb2NrZXQuaW8gY2xpZW50IG5vdCBsb2FkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XygnR0VUJywgb3B0X3BhcmFtcyk7XG4gICAgY29uc3QgdXJpID0gbmV3IFVyaShjbGllbnRSZXF1ZXN0LnVybCgpKTtcbiAgICB1cmkuYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChjbGllbnRSZXF1ZXN0LnBhcmFtcygpKTtcblxuICAgIGNvbnN0IGpzb25wID1cbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8IG5hdmlnYXRvci5wcm9kdWN0ICE9PSAnUmVhY3ROYXRpdmUnO1xuXG4gICAgb3B0X29wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7XG4gICAgICBmb3JjZU5ldzogdHJ1ZSxcbiAgICAgIGpzb25wOiBqc29ucCxcbiAgICB9O1xuICAgIG9wdF9vcHRpb25zLnF1ZXJ5ID1cbiAgICAgICd1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmkuZ2V0UGF0aG5hbWUoKSArIHVyaS5nZXRTZWFyY2goKSk7XG4gICAgb3B0X29wdGlvbnMucGF0aCA9IG9wdF9vcHRpb25zLnBhdGggfHwgdXJpLmdldFBhdGhuYW1lKCk7XG5cbiAgICByZXR1cm4gaW8odXJpLmdldFByb3RvY29sKCkgKyAnLy8nICsgdXJpLmdldEhvc3QoKSwgb3B0X29wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFzc2lnbnMgdGhlIHBhc3NlZCB2YWx1ZSB0byB0aGUgaW50ZXJuYWwgd2l0aCBjcmVkZW50aWFscyBvcHRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aENyZWRlbnRpYWxzXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqL1xuICB3aXRoQ3JlZGVudGlhbHMod2l0aENyZWRlbnRpYWxzKSB7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHNfID0gISF3aXRoQ3JlZGVudGlhbHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuV2VEZXBsb3kuYXV0aF8gPSBudWxsO1xuV2VEZXBsb3kuZGF0YV8gPSBudWxsO1xuV2VEZXBsb3kuZW1haWxfID0gbnVsbDtcbldlRGVwbG95LmF1dGhVcmxfID0gJyc7XG5XZURlcGxveS5kYXRhVXJsXyA9ICcnO1xuV2VEZXBsb3kuZW1haWxVcmxfID0gJyc7XG5cbmV4cG9ydCBkZWZhdWx0IFdlRGVwbG95O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9XZURlcGxveS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4vUmFuZ2UnO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHNlYXJjaCBhZ2dyZWdhdGlvbi5cbiAqL1xuY2xhc3MgQWdncmVnYXRpb24ge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGFnZ3JlZ2F0aW9uIHZhbHVlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBvcGVyYXRvciwgb3B0X3ZhbHVlKSB7XG4gICAgdGhpcy5maWVsZF8gPSBmaWVsZDtcbiAgICB0aGlzLm9wZXJhdG9yXyA9IG9wZXJhdG9yO1xuICAgIHRoaXMudmFsdWVfID0gb3B0X3ZhbHVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImF2Z1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBhdmcoZmllbGQpIHtcbiAgICByZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdhdmcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJjb3VudFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBjb3VudChmaWVsZCkge1xuICAgIHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2NvdW50Jyk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgRGlzdGFuY2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJnZW9EaXN0YW5jZVwiXG5cdCAqIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIFRoZSBhZ2dyZWdhdGlvbiBsb2NhdGlvbi5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAcmV0dXJuIHshRGlzdGFuY2VBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbi5EaXN0YW5jZUFnZ3JlZ2F0aW9uKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJleHRlbmRlZFN0YXRzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGV4dGVuZGVkU3RhdHMoZmllbGQpIHtcbiAgICByZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdleHRlbmRlZFN0YXRzJyk7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgZmllbGQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldEZpZWxkKCkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyBvcGVyYXRvci5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0T3BlcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0b3JfO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImhpc3RvZ3JhbVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWwgVGhlIGhpc3RvZ3JhbSdzIGludGVydmFsLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBoaXN0b2dyYW0oZmllbGQsIGludGVydmFsKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbihmaWVsZCwgJ2hpc3RvZ3JhbScsIGludGVydmFsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtYXhcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWF4KGZpZWxkKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWF4Jyk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWluXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIG1pbihmaWVsZCkge1xuICAgIHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ21pbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1pc3NpbmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ21pc3NpbmcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGZpZWxkKGZpZWxkLCBvcGVyYXRvcikge1xuICAgIHJldHVybiBuZXcgQWdncmVnYXRpb24oZmllbGQsIG9wZXJhdG9yKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBSYW5nZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInJhbmdlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQHJldHVybiB7IVJhbmdlQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyByYW5nZShmaWVsZCwgLi4ucmFuZ2VzKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbi5SYW5nZUFnZ3JlZ2F0aW9uKGZpZWxkLCAuLi5yYW5nZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInN0YXRzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHN0YXRzKGZpZWxkKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnc3RhdHMnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJzdW1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgc3VtKGZpZWxkKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnc3VtJyk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwidGVybXNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgdGVybXMoZmllbGQpIHtcbiAgICByZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICd0ZXJtcycpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZGlzdGFuY2UgYWdncmVnYXRpb24uXG4gKiBAZXh0ZW5kcyB7QWdncmVnYXRpb259XG4gKi9cbmNsYXNzIERpc3RhbmNlQWdncmVnYXRpb24gZXh0ZW5kcyBBZ2dyZWdhdGlvbiB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBEaXN0YW5jZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsqfSBsb2NhdGlvbiBUaGUgYWdncmVnYXRpb24gbG9jYXRpb24uXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvcihmaWVsZCwgbG9jYXRpb24sIC4uLnJhbmdlcykge1xuICAgIHN1cGVyKGZpZWxkLCAnZ2VvRGlzdGFuY2UnLCB7fSk7XG4gICAgdGhpcy52YWx1ZV8ubG9jYXRpb24gPSBFbWJvZGllZC50b0JvZHkobG9jYXRpb24pO1xuICAgIHRoaXMudmFsdWVfLnJhbmdlcyA9IHJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgcmFuZ2UgdG8gdGhpcyBhZ2dyZWdhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yRnJvbVxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdG9cblx0ICogQHJldHVybiB7QWdncmVnYXRpb259IFJldHVybnMgdGhlIHtAbGluayBBZ2dyZWdhdGlvbn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgcmFuZ2UocmFuZ2VPckZyb20sIG9wdF90bykge1xuICAgIGxldCByYW5nZSA9IHJhbmdlT3JGcm9tO1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICByYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXy5yYW5nZXMucHVzaChyYW5nZS5ib2R5KCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhpcyBhZ2dyZWdhdGlvbidzIHVuaXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1bml0XG5cdCAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9ufSBSZXR1cm5zIHRoZSB7QGxpbmsgQWdncmVnYXRpb259IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHVuaXQodW5pdCkge1xuICAgIHRoaXMudmFsdWVfLnVuaXQgPSB1bml0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5BZ2dyZWdhdGlvbi5EaXN0YW5jZUFnZ3JlZ2F0aW9uID0gRGlzdGFuY2VBZ2dyZWdhdGlvbjtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSByYW5nZSBhZ2dyZWdhdGlvbi5cbiAqIEBleHRlbmRzIHtBZ2dyZWdhdGlvbn1cbiAqL1xuY2xhc3MgUmFuZ2VBZ2dyZWdhdGlvbiBleHRlbmRzIEFnZ3JlZ2F0aW9uIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIFJhbmdlQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoZmllbGQsIC4uLnJhbmdlcykge1xuICAgIHN1cGVyKGZpZWxkLCAncmFuZ2UnKTtcbiAgICB0aGlzLnZhbHVlXyA9IHJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgcmFuZ2UgdG8gdGhpcyBhZ2dyZWdhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yRnJvbVxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdG9cblx0ICogQHJldHVybiB7QWdncmVnYXRpb259IFJldHVybnMgdGhlIHtAbGluayBBZ2dyZWdhdGlvbn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgcmFuZ2UocmFuZ2VPckZyb20sIG9wdF90bykge1xuICAgIGxldCByYW5nZSA9IHJhbmdlT3JGcm9tO1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICByYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXy5wdXNoKHJhbmdlLmJvZHkoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbkFnZ3JlZ2F0aW9uLlJhbmdlQWdncmVnYXRpb24gPSBSYW5nZUFnZ3JlZ2F0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCBBZ2dyZWdhdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGktcXVlcnkvQWdncmVnYXRpb24uanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBzdG9yaW5nIGFuZCBoYW5kbGluZyB0aGUgYm9keSBjb250ZW50c1xuICogb2YgYSBGaWx0ZXIgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIEZpbHRlckJvZHkge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBGaWx0ZXJCb2R5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlXG5cdCAqICAgdXNlZCBhcyB0aGUgZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICBsZXQgb2JqID0ge1xuICAgICAgb3BlcmF0b3I6IGNvcmUuaXNEZWYob3B0X3ZhbHVlKSA/IG9wZXJhdG9yT3JWYWx1ZSA6ICc9JyxcbiAgICB9O1xuXG4gICAgbGV0IHZhbHVlID0gY29yZS5pc0RlZihvcHRfdmFsdWUpID8gb3B0X3ZhbHVlIDogb3BlcmF0b3JPclZhbHVlO1xuXG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5ib2R5KCk7XG4gICAgICB9XG4gICAgICBvYmoudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwoZmllbGQpKSB7XG4gICAgICB0aGlzLmNyZWF0ZUJvZHlfKGZpZWxkLCBvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZUJvZHlfKCdhbmQnLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENvbXBvc2VzIHRoZSBjdXJyZW50IGZpbHRlciB3aXRoIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7RmlsdGVyPX0gb3B0X2ZpbHRlciBBbm90aGVyIGZpbHRlciB0byBjb21wb3NlIHRoaXMgZmlsdGVyIHdpdGgsXG5cdCAqICAgaWYgdGhlIG9wZXJhdG9yIGlzIG5vdCB1bmFyeS5cblx0ICovXG4gIGFkZChvcGVyYXRvciwgb3B0X2ZpbHRlcikge1xuICAgIGlmIChvcHRfZmlsdGVyKSB7XG4gICAgICB0aGlzLmFkZEFycmF5T3BlcmF0b3JfKG9wZXJhdG9yLCBvcHRfZmlsdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVCb2R5XyhvcGVyYXRvciwgdGhpcy5ib2R5Xyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENvbXBvc2VzIHRoZSBjdXJyZW50IGZpbHRlciB3aXRoIGFuIG9wZXJhdG9yIHRoYXQgc3RvcmVzIGl0cyB2YWx1ZXMgaW4gYW5cblx0ICogYXJyYXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ9IGZpbHRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBhZGRBcnJheU9wZXJhdG9yXyhvcGVyYXRvciwgZmlsdGVyKSB7XG4gICAgaWYgKCEodGhpcy5ib2R5X1tvcGVyYXRvcl0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRoaXMuY3JlYXRlQm9keV8ob3BlcmF0b3IsIFt0aGlzLmJvZHlfXSk7XG4gICAgfVxuICAgIHRoaXMuYm9keV9bb3BlcmF0b3JdLnB1c2goZmlsdGVyLmJvZHkoKSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgYm9keSB1c2luZyB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0gey4uLip9IGZpbHRlcnMgQSB2YXJpYWJsZSBhbW91bnQgb2YgZmlsdGVycyB0byBiZSBjb21wb3NlZC5cblx0ICovXG4gIGFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkKG9wZXJhdG9yLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBib2R5IG9iamVjdCwgc2V0dGluZyB0aGUgcmVxdWVzdGVkIGtleSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQgaW4gdGhlIG5ldyBib2R5IG9iamVjdFxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgcmVxdWVzdGVkIGtleSBzaG91bGQgaGF2ZSBpbiB0aGUgbmV3IGJvZHlcblx0ICogICBvYmplY3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNyZWF0ZUJvZHlfKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmJvZHlfID0ge307XG4gICAgdGhpcy5ib2R5X1trZXldID0gdmFsdWU7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUganNvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgZmlsdGVyJ3MgYm9keS5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG4gIGdldE9iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5XztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXJCb2R5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9GaWx0ZXJCb2R5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBDbGllbnRNZXNzYWdlIGZyb20gJy4vQ2xpZW50TWVzc2FnZSc7XG5pbXBvcnQge011bHRpTWFwfSBmcm9tICdtZXRhbC1zdHJ1Y3RzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xpZW50IHJlcXVlc3Qgb2JqZWN0LlxuICogQGV4dGVuZHMge0NsaWVudE1lc3NhZ2V9XG4gKi9cbmNsYXNzIENsaWVudFJlcXVlc3QgZXh0ZW5kcyBDbGllbnRNZXNzYWdlIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIENsaWVudFJlcXVlc3R9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXJhbXNfID0gbmV3IE11bHRpTWFwKCk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHNfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHdpdGggY3JlZGVudGlhbHMgb3B0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2l0aENyZWRlbnRpYWxzXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXF1ZXN0fGJvb2xlYW59IFJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3Rcblx0ICogICBpdHNlbGYgd2hlbiB1c2VkIGFzIHNldHRlciwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2Ygd2l0aFxuXHQgKiAgIGNyZWRlbnRpYWxzIG9wdGlvbi5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG4gIHdpdGhDcmVkZW50aWFscyhvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG4gICAgaWYgKGNvcmUuaXNEZWYob3B0X3dpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzXyA9ICEhb3B0X3dpdGhDcmVkZW50aWFscztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoQ3JlZGVudGlhbHNfO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21ldGhvZCBSZXF1ZXN0IG1ldGhvZCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgbWV0aG9kIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfHN0cmluZ30gUmV0dXJucyByZXF1ZXN0IG1ldGhvZCBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG4gIG1ldGhvZChvcHRfbWV0aG9kKSB7XG4gICAgaWYgKGNvcmUuaXNEZWYob3B0X21ldGhvZCkpIHtcbiAgICAgIHRoaXMubWV0aG9kXyA9IG9wdF9tZXRob2Q7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kXyB8fCBDbGllbnRSZXF1ZXN0LkRFRkFVTFRfTUVUSE9EO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBxdWVyeS4gSWYgYSBxdWVyeSB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkIGFzIHdlbGwuIFRoZSBvcmRlciBpc1xuXHQgKiBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHshQ2xpZW50TWVzc2FnZX0gUmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsXG5cdCAqICAgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHBhcmFtKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgdGhpcy5wYXJhbXNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IHF1ZXJ5c3RyaW5nLlxuXHQgKiBAcGFyYW0ge011bHRpTWFwfE9iamVjdD19IG9wdF9wYXJhbXMgUmVxdWVzdCBxdWVyeXN0cmluZyBtYXAgdG8gYmUgc2V0LlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBxdWVyeXN0cmluZyBpZlxuXHQgKiAgIG5vIG5ldyB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX1cblx0ICogICBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICovXG4gIHBhcmFtcyhvcHRfcGFyYW1zKSB7XG4gICAgaWYgKGNvcmUuaXNEZWYob3B0X3BhcmFtcykpIHtcbiAgICAgIGlmIChvcHRfcGFyYW1zIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcbiAgICAgICAgdGhpcy5wYXJhbXNfID0gb3B0X3BhcmFtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyYW1zXy52YWx1ZXMgPSBvcHRfcGFyYW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdF9wYXJhbXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcmFtc187XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdXJsIFJlcXVlc3QgdXJsIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdXJsIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfHN0cmluZ30gUmV0dXJucyByZXF1ZXN0IHVybCBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICBnaXZlbi5cblx0ICogIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgdXJsKG9wdF91cmwpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfdXJsKSkge1xuICAgICAgdGhpcy51cmxfID0gb3B0X3VybDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51cmxfO1xuICB9XG59XG5cbkNsaWVudFJlcXVlc3QuREVGQVVMVF9NRVRIT0QgPSAnR0VUJztcblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50UmVxdWVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvQ2xpZW50UmVxdWVzdC5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtjb3JlfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQ2xpZW50TWVzc2FnZSBmcm9tICcuL0NsaWVudE1lc3NhZ2UnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgcmVzcG9uc2Ugb2JqZWN0LlxuICogQGV4dGVuZHMge0NsaWVudE1lc3NhZ2V9XG4gKi9cbmNsYXNzIENsaWVudFJlc3BvbnNlIGV4dGVuZHMgQ2xpZW50TWVzc2FnZSB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBDbGllbnRSZXNwb25zZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3QgSW5zdGFuY2Ugb2Yge0BsaW5rIENsaWVudFJlcXVlc3R9XG5cdCAqICAgb2JqZWN0LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudFJlcXVlc3QpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghY2xpZW50UmVxdWVzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNyZWF0ZSByZXNwb25zZSB3aXRob3V0IHJlcXVlc3QnKTtcbiAgICB9XG4gICAgdGhpcy5jbGllbnRSZXF1ZXN0XyA9IGNsaWVudFJlcXVlc3Q7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGlzIHJlc3BvbnNlLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH1cblx0ICovXG4gIHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50UmVxdWVzdF87XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXNwb25zZSBzdGF0dXMgY29kZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc3RhdHVzQ29kZSBSZXF1ZXN0IHN0YXR1cyBjb2RlIHRvIGJlIHNldC4gSWYgbm9uZSBpc1xuXHQgKiAgZ2l2ZW4sIHRoZSBjdXJyZW50IHN0YXR1cyBjb2RlIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfG51bWJlcn0gUmV0dXJucyByZXNwb25zZSBzdGF0dXMgY29kZSBpZiBubyBuZXdcblx0ICogICB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0XG5cdCAqICAgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG4gIHN0YXR1c0NvZGUob3B0X3N0YXR1c0NvZGUpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfc3RhdHVzQ29kZSkpIHtcbiAgICAgIHRoaXMuc3RhdHVzQ29kZV8gPSBvcHRfc3RhdHVzQ29kZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0dXNDb2RlXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlc3BvbnNlIHN0YXR1cyB0ZXh0LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdGF0dXNUZXh0IFJlcXVlc3Qgc3RhdHVzIHRleHQgdG8gYmUgc2V0LiBJZiBub25lIGlzXG5cdCAqICAgZ2l2ZW4sIHRoZSBjdXJyZW50IHN0YXR1cyB0ZXh0IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfG51bWJlcn0gUmV0dXJucyByZXNwb25zZSBzdGF0dXMgdGV4dCBpZiBubyBuZXdcblx0ICogICB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0XG5cdCAqICAgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG4gIHN0YXR1c1RleHQob3B0X3N0YXR1c1RleHQpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfc3RhdHVzVGV4dCkpIHtcbiAgICAgIHRoaXMuc3RhdHVzVGV4dF8gPSBvcHRfc3RhdHVzVGV4dDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0dXNUZXh0XztcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgaWYgcmVzcG9uc2Ugc3VjY2VlZGVkLiBBbnkgc3RhdHVzIGNvZGUgMnh4IG9yIDN4eCBpcyBjb25zaWRlcmVkXG5cdCAqIHZhbGlkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgc3VjY2VlZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGUoKSA+PSAyMDAgJiYgdGhpcy5zdGF0dXNDb2RlKCkgPD0gMzk5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudFJlc3BvbnNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9DbGllbnRSZXNwb25zZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgaW50ZXJmYWNlIGZvciBkYXRhIHRyYW5zcG9ydC5cbiAqIEBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgVHJhbnNwb3J0IHtcbiAgLyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZSBmb3IgdGhlIHNwZWNpZmllZCBjbGllbnQuXG5cdCAqIEBtZXRob2Qgc2VuZFxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0XG5cdCAqIEByZXR1cm4geyFQcm9taXNlfSBEZWZlcnJlZCByZXF1ZXN0LlxuXHQgKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9UcmFuc3BvcnQuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBamF4VHJhbnNwb3J0IGZyb20gJy4vYnJvd3Nlci9BamF4VHJhbnNwb3J0JztcblxuLyoqXG4gKiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGRhdGEgdHJhbnNwb3J0LlxuICovXG5jbGFzcyBUcmFuc3BvcnRGYWN0b3J5IHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIFRyYW5zcG9ydEZhY3Rvcnl9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHJhbnNwb3J0cyA9IHt9O1xuICAgIHRoaXMudHJhbnNwb3J0c1tUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdID1cbiAgICAgIFRyYW5zcG9ydEZhY3RvcnlbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHtAbGluayBUcmFuc3BvcnRGYWN0b3J5fSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7IVRyYW5zcG9ydEZhY3Rvcnl9IEluc3RhbmNlIG9mIFRyYW5zcG9ydEZhY3Rvcnlcblx0ICovXG4gIHN0YXRpYyBpbnN0YW5jZSgpIHtcbiAgICBpZiAoIVRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfKSB7XG4gICAgICBUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXyA9IG5ldyBUcmFuc3BvcnRGYWN0b3J5KCk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIGFuIGluc3RhbmNlIG9mIHRoZSB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGltcGxlbWVudGF0aW9uTmFtZVxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0fVxuXHQgKi9cbiAgZ2V0KGltcGxlbWVudGF0aW9uTmFtZSkge1xuICAgIGxldCBUcmFuc3BvcnRDbGFzcyA9IHRoaXMudHJhbnNwb3J0c1tpbXBsZW1lbnRhdGlvbk5hbWVdO1xuXG4gICAgaWYgKCFUcmFuc3BvcnRDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zcG9ydCBuYW1lOiAnICsgaW1wbGVtZW50YXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRDbGFzcygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNyZWF0ZSB0cmFuc3BvcnQnLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHJldHVybiB7IVRyYW5zcG9ydH1cblx0ICovXG4gIGdldERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRSk7XG4gIH1cbn1cblxuVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FID0gJ2RlZmF1bHQnO1xuXG5UcmFuc3BvcnRGYWN0b3J5W1RyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRV0gPSBBamF4VHJhbnNwb3J0O1xuXG5leHBvcnQgZGVmYXVsdCBUcmFuc3BvcnRGYWN0b3J5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9UcmFuc3BvcnRGYWN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aCBmcm9tICcuL0F1dGgnO1xuaW1wb3J0IEFwaUhlbHBlciBmcm9tICcuLi9BcGlIZWxwZXInO1xuaW1wb3J0IEZhY2Vib29rQXV0aFByb3ZpZGVyIGZyb20gJy4vRmFjZWJvb2tBdXRoUHJvdmlkZXInO1xuaW1wb3J0IEdpdGh1YkF1dGhQcm92aWRlciBmcm9tICcuL0dpdGh1YkF1dGhQcm92aWRlcic7XG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi8uLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IEdvb2dsZUF1dGhQcm92aWRlciBmcm9tICcuL0dvb2dsZUF1dGhQcm92aWRlcic7XG5pbXBvcnQge1N0b3JhZ2UsIExvY2FsU3RvcmFnZU1lY2hhbmlzbX0gZnJvbSAnbWV0YWwtc3RvcmFnZSc7XG5cbmltcG9ydCB7XG4gIGFzc2VydERlZkFuZE5vdE51bGwsXG4gIGFzc2VydEZ1bmN0aW9uLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFVzZXJTaWduZWRJbixcbiAgYXNzZXJ0QnJvd3NlckVudmlyb25tZW50LFxuICBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCxcbn0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRpbmcgYXV0aCBBUEkgY2FsbHMuXG4gKi9cbmNsYXNzIEF1dGhBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aEFwaUhlbHBlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gd2VkZXBsb3lDbGllbnRcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuICAgIHN1cGVyKHdlZGVwbG95Q2xpZW50KTtcbiAgICB0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcbiAgICB0aGlzLm9uU2lnbkluQ2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMub25TaWduT3V0Q2FsbGJhY2sgPSBudWxsO1xuXG4gICAgaWYgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgU3RvcmFnZShuZXcgTG9jYWxTdG9yYWdlTWVjaGFuaXNtKCkpO1xuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc1NpZ25Jbl8oKTtcblxuICAgIHRoaXMucHJvdmlkZXIgPSB7XG4gICAgICBGYWNlYm9vazogRmFjZWJvb2tBdXRoUHJvdmlkZXIsXG4gICAgICBHb29nbGU6IEdvb2dsZUF1dGhQcm92aWRlcixcbiAgICAgIEdpdGh1YjogR2l0aHViQXV0aFByb3ZpZGVyLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhY2Nlc3MgdG9rZW4gY29va2llLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW5cblx0ICovXG4gIGNyZWF0ZUFjY2Vzc1Rva2VuQ29va2llKGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKGdsb2JhbHMuZG9jdW1lbnQgJiYgZ2xvYmFscy53aW5kb3cpIHtcbiAgICAgIGdsb2JhbHMuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgJ2FjY2Vzc190b2tlbj0nICtcbiAgICAgICAgYWNjZXNzVG9rZW4gK1xuICAgICAgICAnOyBEb21haW49JyArXG4gICAgICAgIGdsb2JhbHMud2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICtcbiAgICAgICAgJzsnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtBdXRofVxuICAgKi9cbiAgY3JlYXRlQXV0aEZyb21EYXRhKGRhdGEpIHtcbiAgICBjb25zdCBhdXRoID0gQXV0aC5jcmVhdGVGcm9tRGF0YShkYXRhKTtcbiAgICBhdXRoLnNldFdlZGVwbG95Q2xpZW50KHRoaXMud2VkZXBsb3lDbGllbnQpO1xuICAgIHJldHVybiBhdXRoO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgdXNlci5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSB1c2VyLlxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBjcmVhdGVVc2VyKGRhdGEpIHtcbiAgICBhc3NlcnRPYmplY3QoZGF0YSwgJ1VzZXIgZGF0YSBtdXN0IGJlIHNwZWNpZmllZCBhcyBvYmplY3QnKTtcblxuICAgIGxldCByZXF1ZXN0ID0gdGhpcy5idWlsZFVybF8oKS5wYXRoKCcvdXNlcnMnKTtcblxuICAgIGxldCBhdXRoU2NvcGUgPSB0aGlzLnJlc29sdmVBdXRoU2NvcGUoKTtcbiAgICBpZiAoYXV0aFNjb3BlKSB7XG4gICAgICByZXF1ZXN0LmF1dGgoYXV0aFNjb3BlLnRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdFxuICAgICAgLnBvc3QoZGF0YSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHRoaXMuY3JlYXRlQXV0aEZyb21EYXRhKHJlc3BvbnNlLmJvZHkoKSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERlbGV0ZXMgYWNjZXNzIHRva2VuIGNvb2tpZS5cblx0ICovXG4gIGRlbGV0ZUFjY2Vzc1Rva2VuQ29va2llKCkge1xuICAgIGlmIChnbG9iYWxzLmRvY3VtZW50ICYmIGdsb2JhbHMud2luZG93KSB7XG4gICAgICBnbG9iYWxzLmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICdhY2Nlc3NfdG9rZW49O2V4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMSBHTVQ7RG9tYWluPScgK1xuICAgICAgICBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSArXG4gICAgICAgICc7JztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgY3VycmVudCBicm93c2VyIHVybCB3aXRob3V0IHRoZSBmcmFnbWVudCBwYXJ0LlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRIcmVmV2l0aG91dEZyYWdtZW50XygpIHtcbiAgICBsZXQgbG9jYXRpb24gPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gKFxuICAgICAgbG9jYXRpb24ucHJvdG9jb2wgK1xuICAgICAgJy8vJyArXG4gICAgICBsb2NhdGlvbi5ob3N0ICtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgIChsb2NhdGlvbi5zZWFyY2ggPyBsb2NhdGlvbi5zZWFyY2ggOiAnJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSB1cmwgZnJhZ21lbnQgYW5kIHJlbW92ZXMgaXQuXG5cdCAqIEByZXR1cm4gez9zdHJpbmd9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFJlZGlyZWN0QWNjZXNzVG9rZW5fKCkge1xuICAgIGlmIChnbG9iYWxzLndpbmRvdyAmJiBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbikge1xuICAgICAgbGV0IGZyYWdtZW50ID0gZ2xvYmFscy53aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgIGlmIChmcmFnbWVudC5pbmRleE9mKCcjYWNjZXNzX3Rva2VuPScpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zdWJzdHJpbmcoMTQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHVzZXIgYnkgaWQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdXNlcklkXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGdldFVzZXIodXNlcklkKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbCh1c2VySWQsICdVc2VyIHVzZXJJZCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICAgIGFzc2VydFVzZXJTaWduZWRJbih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VycycsIHVzZXJJZClcbiAgICAgIC5hdXRoKHRoaXMucmVzb2x2ZUF1dGhTY29wZSgpLnRva2VuKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB0aGlzLmNyZWF0ZUF1dGhGcm9tRGF0YShyZXNwb25zZS5ib2R5KCkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBMb2FkcyBjdXJyZW50IHVzZXIuIFJlcXVpcmVzIGEgdXNlciB0b2tlbiBhcyBhcmd1bWVudC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB0b2tlblxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBsb2FkQ3VycmVudFVzZXIodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlVc2VyKHRva2VuKS50aGVuKGN1cnJlbnRVc2VyID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBjdXJyZW50VXNlcjtcbiAgICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCgnY3VycmVudFVzZXInLCBjdXJyZW50VXNlcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50VXNlci5oYXNUb2tlbigpKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlQWNjZXNzVG9rZW5Db29raWUodGhpcy5jdXJyZW50VXNlci5nZXRUb2tlbigpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIHRoZSBvbiBzaWduIGluIGNhbGxiYWNrIGlmIHNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbWF5YmVDYWxsT25TaWduSW5DYWxsYmFja18oKSB7XG4gICAgaWYgKHRoaXMub25TaWduSW5DYWxsYmFjaykge1xuICAgICAgdGhpcy5vblNpZ25JbkNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5jdXJyZW50VXNlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIHRoZSBvbiBzaWduIG91dCBjYWxsYmFjayBpZiBzZXQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIG1heWJlQ2FsbE9uU2lnbk91dENhbGxiYWNrXygpIHtcbiAgICBpZiAodGhpcy5vblNpZ25PdXRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblNpZ25PdXRDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFVzZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBGaXJlcyBwYXNzZWQgY2FsbGJhY2sgd2hlbiBhIHVzZXIgc2lnbi1pbi4gTm90ZSB0aGF0IGl0IGtlZXBzIG9ubHkgdGhlXG5cdCAqIGxhc3QgY2FsbGJhY2sgcGFzc2VkLlxuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICovXG4gIG9uU2lnbkluKGNhbGxiYWNrKSB7XG4gICAgYXNzZXJ0RnVuY3Rpb24oY2FsbGJhY2ssICdTaWduLWluIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMub25TaWduSW5DYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcmVzIHBhc3NlZCBjYWxsYmFjayB3aGVuIGEgdXNlciBzaWduLW91dC4gTm90ZSB0aGF0IGl0IGtlZXBzIG9ubHkgdGhlXG5cdCAqIGxhc3QgY2FsbGJhY2sgcGFzc2VkLlxuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICovXG4gIG9uU2lnbk91dChjYWxsYmFjaykge1xuICAgIGFzc2VydEZ1bmN0aW9uKGNhbGxiYWNrLCAnU2lnbi1vdXQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5vblNpZ25PdXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG5cdCAqIFByb2Nlc3NlcyBzaWduLWluIGJ5IGRldGVjdGluZyBhIHByZXNlbmNlIG9mIGEgZnJhZ21lbnRcblx0ICogPGNvZGU+I2FjY2Vzc190b2tlbj08L2NvZGU+IGluIHRoZSB1cmwgb3IsIGFsdGVybmF0aXZlbHksIGJ5IGxvY2FsXG5cdCAqIHN0b3JhZ2UgY3VycmVudCB1c2VyLlxuXHQgKi9cbiAgcHJvY2Vzc1NpZ25Jbl8oKSB7XG4gICAgbGV0IHJlZGlyZWN0QWNjZXNzVG9rZW4gPSB0aGlzLmdldFJlZGlyZWN0QWNjZXNzVG9rZW5fKCk7XG4gICAgaWYgKHJlZGlyZWN0QWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XygpO1xuICAgICAgdGhpcy5sb2FkQ3VycmVudFVzZXIocmVkaXJlY3RBY2Nlc3NUb2tlbikudGhlbigoKSA9PlxuICAgICAgICB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50VXNlciA9IHRoaXMuc3RvcmFnZSAmJiB0aGlzLnN0b3JhZ2UuZ2V0KCdjdXJyZW50VXNlcicpO1xuICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHRoaXMuY3JlYXRlQXV0aEZyb21EYXRhKGN1cnJlbnRVc2VyKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlcyBmcmFnbWVudCBmcm9tIHVybCBieSBwZXJmb3JtaW5nIGEgcHVzaCBzdGF0ZSB0byB0aGUgY3VycmVudCBwYXRoLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCkge1xuICAgIGdsb2JhbHMud2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKFxuICAgICAge30sXG4gICAgICAnJyxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc29sdmVzIGF1dGggc2NvcGUgZnJvbSBsYXN0IGxvZ2luIG9yIGFwaSBoZWxwZXIuXG5cdCAqIEByZXR1cm4ge0F1dGh9XG5cdCAqL1xuICByZXNvbHZlQXV0aFNjb3BlKCkge1xuICAgIGlmICh0aGlzLmhlbHBlckF1dGhTY29wZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyQXV0aFNjb3BlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZW5kcyBwYXNzd29yZCByZXNldCBlbWFpbCB0byB0aGUgc3BlY2lmaWVkIGVtYWlsIGlmIGZvdW5kIGluIGRhdGFiYXNlLlxuXHQgKiBGb3Igc2VjdXJpdHkgcmVhc29ucyBjYWxsIGRvIG5vdCBmYWlsIGlmIGVtYWlsIG5vdCBmb3VuZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBlbWFpbFxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGVtYWlsKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChlbWFpbCwgJ1NlbmQgcGFzc3dvcmQgcmVzZXQgZW1haWwgbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VyL3JlY292ZXInKVxuICAgICAgLnBhcmFtKCdlbWFpbCcsIGVtYWlsKVxuICAgICAgLnBvc3QoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTaWducyBpbiB1c2luZyBlbWFpbCBhbmQgcGFzc3dvcmQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gZW1haWxcblx0ICogQHBhcmFtIHshc3RyaW5nfSBwYXNzd29yZFxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGVtYWlsLCAnU2lnbi1pbiBlbWFpbCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwocGFzc3dvcmQsICdTaWduLWluIHBhc3N3b3JkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy9vYXV0aC90b2tlbicpXG4gICAgICAucGFyYW0oJ2dyYW50X3R5cGUnLCAncGFzc3dvcmQnKVxuICAgICAgLnBhcmFtKCd1c2VybmFtZScsIGVtYWlsKVxuICAgICAgLnBhcmFtKCdwYXNzd29yZCcsIHBhc3N3b3JkKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB0aGlzLmxvYWRDdXJyZW50VXNlcihyZXNwb25zZS5ib2R5KCkuYWNjZXNzX3Rva2VuKSlcbiAgICAgIC50aGVuKHVzZXIgPT4ge1xuICAgICAgICB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCk7XG4gICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogU2lnbnMgaW4gd2l0aCByZWRpcmVjdC4gU29tZSBwcm92aWRlcnMgYW5kIGVudmlyb25tZW50IG1heSBub3Qgc3VwcG9ydFxuXHQgKiB0aGlzIGZsb3cuXG5cdCAqIEBwYXJhbSB7QXV0aFByb3ZpZGVyfSBwcm92aWRlclxuXHQgKi9cbiAgc2lnbkluV2l0aFJlZGlyZWN0KHByb3ZpZGVyKSB7XG4gICAgYXNzZXJ0QnJvd3NlckVudmlyb25tZW50KCk7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChwcm92aWRlciwgJ1NpZ24taW4gcHJvdmlkZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIocHJvdmlkZXIpO1xuXG4gICAgaWYgKCFwcm92aWRlci5oYXNSZWRpcmVjdFVyaSgpKSB7XG4gICAgICBwcm92aWRlci5zZXRSZWRpcmVjdFVyaSh0aGlzLmdldEhyZWZXaXRob3V0RnJhZ21lbnRfKCkpO1xuICAgIH1cbiAgICBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5ocmVmID0gcHJvdmlkZXIubWFrZUF1dGhvcml6YXRpb25VcmwoXG4gICAgICB0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTaWducyBvdXQgPGNvZGU+Y3VycmVudFVzZXI8L2NvZGU+IGFuZCByZW1vdmVzIGZyb21cblx0ICogICA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzaWduT3V0KCkge1xuICAgIGFzc2VydFVzZXJTaWduZWRJbih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy9vYXV0aC9yZXZva2UnKVxuICAgICAgLnBhcmFtKCd0b2tlbicsIHRoaXMuY3VycmVudFVzZXIudG9rZW4pXG4gICAgICAuZ2V0KClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5tYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18oKTtcbiAgICAgICAgdGhpcy51bmxvYWRDdXJyZW50VXNlcl8oKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIFVSTCBieSBqb2luaW5nIHRoZSBoZWFkZXJzLlxuICAgKiBAcmV0dXJuIHtXZURlcGxveX0gUmV0dXJucyB0aGUge0BsaW5rIFdlRGVwbG95fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cbiAgICogICBiZSBjaGFpbmVkLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBidWlsZFVybF8oKSB7XG4gICAgcmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcbiAgICAgIC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcbiAgICAgIC5oZWFkZXJzKHRoaXMuaGVhZGVyc18pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVubG9hZHMgYWxsIGluZm9ybWF0aW9uIGZvciA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbVxuXHQgKiA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlmIHByZXNlbnQuXG5cdCAqL1xuICB1bmxvYWRDdXJyZW50VXNlcl8oKSB7XG4gICAgdGhpcy5jdXJyZW50VXNlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZSgnY3VycmVudFVzZXInKTtcbiAgICB9XG4gICAgdGhpcy5kZWxldGVBY2Nlc3NUb2tlbkNvb2tpZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE1ldGhvZCBmb3IgdmVyaWZ5aW5nIHRva2Vucy4gSWYgdGhlIHByb3ZpZGVkIHRva2VuIGhhcyB0aGUgY29ycmVjdFxuXHQgKiBmb3JtYXQsIGlzIG5vdCBleHBpcmVkLCBhbmQgaXMgcHJvcGVybHkgc2lnbmVkLCB0aGUgbWV0aG9kIHJldHVybnMgdGhlXG5cdCAqIGRlY29kZWQgdG9rZW4uXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgdmVyaWZ5VG9rZW4odG9rZW4pIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKHRva2VuLCAnVG9rZW4gbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy9vYXV0aC90b2tlbmluZm8nKVxuICAgICAgLnBhcmFtKCd0b2tlbicsIHRva2VuKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE1ldGhvZCBmb3IgdmVyaWZ5aW5nIHVzZXIgYnkgdG9rZW4uIElmIHRoZSBwcm92aWRlZCB0b2tlbiBoYXMgdGhlIGNvcnJlY3Rcblx0ICogZm9ybWF0LCBpcyBub3QgZXhwaXJlZCwgYW5kIGlzIHByb3Blcmx5IHNpZ25lZCwgdGhlIG1ldGhvZCByZXR1cm5zIHRoZVxuXHQgKiB1c2VyIHBheWxvYWQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5PckVtYWlsIEVpdGhlciBhbiBhdXRob3JpemF0aW9uIHRva2VuLFxuXHQgKiBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIHZlcmlmeVVzZXIodG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKHRva2VuT3JFbWFpbCwgJ1Rva2VuIG9yIGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKCcvdXNlcicpXG4gICAgICAuYXV0aCh0b2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZClcbiAgICAgIC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlLmJvZHkoKTtcbiAgICAgICAgaWYgKG9wdF9wYXNzd29yZCkge1xuICAgICAgICAgIGRhdGEudG9rZW4gPSBudWxsO1xuICAgICAgICAgIGRhdGEuZW1haWwgPSB0b2tlbk9yRW1haWw7XG4gICAgICAgICAgZGF0YS5wYXNzd29yZCA9IG9wdF9wYXNzd29yZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLnRva2VuID0gdG9rZW5PckVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF1dGhGcm9tRGF0YShkYXRhKTtcbiAgICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0cyBhIHBhc3NlZCBzaWduLWluIHByb3ZpZGVyIGlzIHN1cHBvcnRlZC5cbiAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHBhc3NlZCBwcm92aWRlciBpcyBub3Qgb25lIG9mOlxuICogLSBGYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUlxuICogLSBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVJcbiAqIC0gR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByb3ZpZGVyXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gIHN3aXRjaCAocHJvdmlkZXIuY29uc3RydWN0b3IuUFJPVklERVIpIHtcbiAgICBjYXNlIEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuICAgIGNhc2UgR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuICAgIGNhc2UgR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbi1pbiBwcm92aWRlciBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aEFwaUhlbHBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9BdXRoQXBpSGVscGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBGYWNlYm9vayBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBGYWNlYm9va0F1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVI7XG4gIH1cbn1cblxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZmFjZWJvb2snO1xuXG5leHBvcnQgZGVmYXVsdCBGYWNlYm9va0F1dGhQcm92aWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9GYWNlYm9va0F1dGhQcm92aWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR2l0aHViIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHaXRodWJBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcm92aWRlciA9IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjtcbiAgfVxufVxuXG5HaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ2l0aHViJztcblxuZXhwb3J0IGRlZmF1bHQgR2l0aHViQXV0aFByb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR29vZ2xlIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdvb2dsZUF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHb29nbGVBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcm92aWRlciA9IEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUjtcbiAgfVxufVxuXG5Hb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ29vZ2xlJztcblxuZXhwb3J0IGRlZmF1bHQgR29vZ2xlQXV0aFByb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9hdXRoL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXggZnJvbSAnbWV0YWwtYWpheCc7XG5pbXBvcnQgVHJhbnNwb3J0IGZyb20gJy4uL1RyYW5zcG9ydCc7XG5pbXBvcnQgQ2xpZW50UmVzcG9uc2UgZnJvbSAnLi4vQ2xpZW50UmVzcG9uc2UnO1xuXG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBhamF4IHRyYW5zcG9ydCB0byBiZSB1c2VkIHdpdGgge0BsaW5rIFdlRGVwbG95fS5cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnR9XG4gKi9cbmNsYXNzIEFqYXhUcmFuc3BvcnQgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG4gIHNlbmQoY2xpZW50UmVxdWVzdCkge1xuICAgIGxldCBkZWZlcnJlZCA9IEFqYXgucmVxdWVzdChcbiAgICAgIGNsaWVudFJlcXVlc3QudXJsKCksXG4gICAgICBjbGllbnRSZXF1ZXN0Lm1ldGhvZCgpLFxuICAgICAgY2xpZW50UmVxdWVzdC5ib2R5KCksXG4gICAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKSxcbiAgICAgIGNsaWVudFJlcXVlc3QucGFyYW1zKCksXG4gICAgICBudWxsLFxuICAgICAgZmFsc2UsXG4gICAgICBjbGllbnRSZXF1ZXN0LndpdGhDcmVkZW50aWFscygpXG4gICAgKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBsZXQgY2xpZW50UmVzcG9uc2UgPSBuZXcgQ2xpZW50UmVzcG9uc2UoY2xpZW50UmVxdWVzdCk7XG4gICAgICBjbGllbnRSZXNwb25zZS5ib2R5KHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICBjbGllbnRSZXNwb25zZS5zdGF0dXNDb2RlKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjbGllbnRSZXNwb25zZS5zdGF0dXNUZXh0KHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgQWpheC5wYXJzZVJlc3BvbnNlSGVhZGVycyhcbiAgICAgICAgcmVzcG9uc2UuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICkuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgY2xpZW50UmVzcG9uc2UuaGVhZGVyKGhlYWRlci5uYW1lLCBoZWFkZXIudmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xpZW50UmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWpheFRyYW5zcG9ydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYnJvd3Nlci9BamF4VHJhbnNwb3J0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQge1xuICBhc3NlcnREZWZBbmROb3ROdWxsLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxufSBmcm9tICcuLi9hc3NlcnRpb25zJztcbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBkYXRhIGFwaSBjYWxscy5cbiAqL1xuY2xhc3MgRGF0YUFwaUhlbHBlciBleHRlbmRzIEFwaUhlbHBlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBEYXRhQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshV2VEZXBsb3l9IHdlZGVwbG95Q2xpZW50IHtAbGluayBXZURlcGxveX0gY2xpZW50IHJlZmVyZW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuICAgIHN1cGVyKHdlZGVwbG95Q2xpZW50KTtcblxuICAgIHRoaXMuaXNTZWFyY2hfID0gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIEZpbHRlciBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHdoZXJlKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkuYW5kKFxuICAgICAgZmllbGRPckZpbHRlcixcbiAgICAgIG9wdF9vcGVyYXRvck9yVmFsdWUsXG4gICAgICBvcHRfdmFsdWVcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJvclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqICAgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGlmICh0aGlzLmdldE9yQ3JlYXRlRmlsdGVyXygpLmJvZHkoKS5hbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGEgY29uZGl0aW9uIGJlZm9yZSB1c2luZyBhbiBcXCdvcigpXFwnICcgK1xuICAgICAgICAgICdmb3IgdGhlIGZpcnN0IHRpbWUuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5vcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwibm9uZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHshKEFycmF5fCopfSBhcmdzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbm9uZShmaWVsZCwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5ub25lKGZpZWxkLCBhcmdzKSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJtYXRjaFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG1hdGNoKGZpZWxkLCBvcHRfcXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubWF0Y2goZmllbGQsIG9wdF9xdWVyeSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwicHJlZml4XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIHByZWZpeChmaWVsZCwgb3B0X3F1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLnByZWZpeChmaWVsZCwgb3B0X3F1ZXJ5KSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJzaW1pbGFyXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBzaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuc2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBsdChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubHQoZmllbGQsIHZhbHVlKSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbHRlKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5sdGUoZmllbGQsIHZhbHVlKSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJhbnlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwqKX0gYXJncyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqIHRoZSBcIm5vbmVcIiBvcGVyYXRvci4gQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYXMgYSBzaW5nbGUgYXJyYXkgb3IgYXNcblx0ICogc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIGFueShmaWVsZCwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5hbnkoZmllbGQsIGFyZ3MpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcImdwXCIgb3BlcmF0b3IuIFRoaXMgaXMgYVxuXHQgKiBzcGVjaWFsIHVzZSBjYXNlIG9mIGBGaWx0ZXIucG9seWdvbmAgZm9yIGJvdW5kaW5nIGJveGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBib3hPclVwcGVyTGVmdCBFaXRoZXIgYSBgR2VvLkJvdW5kaW5nQm94YCBpbnN0YW5jZSwgb3IgYVxuXHQgKiBib3VuZGluZyBib3gncyB1cHBlciBsZWZ0IGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9sb3dlclJpZ2h0IEEgYm91bmRpbmcgYm94J3MgbG93ZXIgcmlnaHQgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMud2hlcmUoXG4gICAgICBGaWx0ZXIuYm91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodClcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYVxuXHQgKiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiB0aGUgZGlzdGFuY2UgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uT3JDaXJjbGUsIG9wdF9yYW5nZU9yRGlzdGFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShcbiAgICAgIEZpbHRlci5kaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwicmFuZ2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPck1pbiBFaXRoZXIgYSBgUmFuZ2VgIGluc3RhbmNlIG9yIGEgdGhlIHJhbmdlJ3MgbWluXG5cdCAqIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbWF4IFRoZSByYW5nZSdzIG1heCB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICByYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5yYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIGxpbWl0IGZvciB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcmVxdWVzdCBzaG91bGRcblx0ICogICByZXR1cm4uXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkubGltaXQobGltaXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIG9mZnNldCBmb3IgdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlXG5cdCAqIHJldHVybmVkIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgb2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5vZmZzZXQob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIGhpZ2hsaWdodChmaWVsZCkge1xuICAgIHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5oaWdobGlnaHQoZmllbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuIHtAbGlua1xuXHQgKiBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG4gICAgdGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGlzIHJlcXVlc3QncyBxdWVyeSB0eXBlIHRvICdjb3VudCcuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgY291bnQoKSB7XG4gICAgdGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLnR5cGUoJ2NvdW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHNvcnQgcXVlcnkgdG8gdGhpcyByZXF1ZXN0J3MgYm9keS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkXG5cdCAqIHVzZS4gSWYgbm9uZSBpcyBnaXZlbiwgJ2FzYycgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG9yZGVyQnkoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICB0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGFuZCBzYXZlcyBpdCB0byBXZURlcGxveSBkYXRhLiBJZlxuXHQgKiB0aGVyZSdzIGEgdmFsaWRhdGlvbiByZWdpc3RlcmVkIGluIHRoZSBjb2xsZWN0aW9uIGFuZCB0aGUgcmVxdWVzdCBpc1xuXHQgKiBzdWNjZXNzZnVsLCB0aGUgcmVzdWx0aW5nIG9iamVjdCAob3IgYXJyYXkgb2Ygb2JqZWN0cykgaXMgcmV0dXJuZWQuIFRoZVxuXHQgKiBkYXRhIHBhcmFtZXRlciBjYW4gYmUgZWl0aGVyIGFuIE9iamVjdCBvciBhbiBBcnJheSBvZiBPYmplY3RzLlxuXHQgKiBUaGVzZSBPYmplY3RzIGRlc2NyaWJlIHRoZSBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3RzIHRoYXQgYXJlIHRvIGJlXG5cdCAqICAgY3JlYXRlZC5cblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLmNyZWF0ZShcblx0ICogICAnbW92aWVzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEkg4oCTIFRoZSBQaGFudG9tIE1lbmFjZSd9KVxuXHQgKiBcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqICAgICBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICB9KTtcblx0ICpcblx0ICogZGF0YS5jcmVhdGUoXG5cdCAqICAgJ21vdmllcycsIFt7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSUkg4oCTIEF0dGFjayBvZiB0aGUgQ2xvbmVzJ30sXG5cdCAqIFx0XHRcdFx0XHRcdCAgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIElJSSDigJMgUmV2ZW5nZSBvZiB0aGUgU2l0aCd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllcyl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZXMpXG5cdCAqICAgICB9KTtcblx0ICogYGBgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gKGtleSkgdXNlZCB0byBjcmVhdGUgdGhlIG5ldyBkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QgdGhhdCBpcyB0byBiZSBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgY3JlYXRlKGNvbGxlY3Rpb24sIGRhdGEpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGNvbGxlY3Rpb24sICdDb2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICBhc3NlcnRPYmplY3QoZGF0YSwgJ0RhdGEgY2FuXFwndCBiZSBlbXB0eS4nKTtcblxuICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsXygpXG4gICAgICAucGF0aChjb2xsZWN0aW9uKVxuICAgICAgLnBvc3QoZGF0YSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG4gIH1cblxuICAvKipcblx0ICogUmVwbGFjZXMgdGhlIGF0dHJpYnV0ZXMgb2YgYSBkb2N1bWVudCBmb3JtIHRoZSBwYXNzZWQtaW4gb2JqZWN0IGFuZCBzYXZlc1xuXHQgKiB0aGUgcmVjb3JkLiBJZiB0aGUgb2JqZWN0IGlzIGludmFsaWQsIHRoZSBzYXZpbmcgd2lsbCBmYWlsIGFuZCBhbiBlcnJvclxuXHQgKiBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLnJlcGxhY2UoJ21vdmllcy8xMDE5MTEyMzUzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEknfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICAgIH0pO1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRvYyBLZXkgdXNlZCB0byB1cGRhdGUgdGhlIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QgdGhhdCBpcyB0byBiZSB1cGRhdGVkLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgcmVwbGFjZShkb2MsIGRhdGEpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGRvYywgJ0RvY3VtZW50IGtleSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICBhc3NlcnRPYmplY3QoZGF0YSwgJ0RhdGEgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoZG9jKVxuICAgICAgLnB1dChkYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgYSBkb2N1bWVudCBmb3JtIHRoZSBwYXNzZWQtaW4gb2JqZWN0IGFuZCBzYXZlc1xuXHQgKiB0aGUgcmVjb3JkLiBJZiB0aGUgb2JqZWN0IGlzIGludmFsaWQsIHRoZSBzYXZpbmcgd2lsbCBmYWlsIGFuZCBhbiBlcnJvclxuXHQgKiBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLnVwZGF0ZSgnbW92aWVzLzEwMTkxMTIzNTMnLCB7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSSd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllKXtcblx0ICogXHRcdFx0IGNvbnNvbGUubG9nKG1vdmllKVxuXHQgKiAgICAgfSk7XG5cdCAqIGBgYFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZG9jIEtleSB1c2VkIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCB0aGF0IGlzIHRvIGJlIHVwZGF0ZWQuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICB1cGRhdGUoZG9jLCBkYXRhKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChkb2MsICdEb2N1bWVudCBrZXkgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gICAgYXNzZXJ0T2JqZWN0KGRhdGEsICdEYXRhIG11c3QgYmUgc3BlY2lmaWVkLicpO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKGRvYylcbiAgICAgIC5wYXRjaChkYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZWxldGVzIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGVcblx0ICogZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoa2V5KVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHJpZXZlIGRhdGEgZnJvbSBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBnZXQoa2V5KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKGtleSlcbiAgICAgIC5nZXQodGhpcy5wcm9jZXNzQW5kUmVzZXRRdWVyeVN0YXRlKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHJpZXZlIGRhdGEgZnJvbSBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXSBhbmQgcHV0IGl0IGluIGEgc2VhcmNoXG5cdCAqIGZvcm1hdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzZWFyY2goa2V5KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgdGhpcy5pc1NlYXJjaF8gPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKGtleSlcbiAgICAgIC5nZXQodGhpcy5wcm9jZXNzQW5kUmVzZXRRdWVyeVN0YXRlKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gTW9uaXRvciB0aGUgYXJyaXZhbCBvZiBuZXcgYnJvYWRjYXN0ZWRcblx0ICogZGF0YS5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjb2xsZWN0aW9uIGtleS9jb2xsZWN0aW9uIHVzZWQgdG8gZmluZCBvcmdhbml6ZWQgZGF0YS5cblx0ICogQHBhcmFtICB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT2JqZWN0IHdpdGggU29ja2V0IElPIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4geyFpb30gU29ja2V0IElPIHJlZmVyZW5jZS4gU2VydmVyIGV2ZW50cyBjYW4gYmUgbGlzdGVuZWQgb24gaXQuXG5cdCAqL1xuICB3YXRjaChjb2xsZWN0aW9uLCBvcHRfb3B0aW9ucykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoY29sbGVjdGlvbiwgJ0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoY29sbGVjdGlvbilcbiAgICAgIC53YXRjaCh0aGlzLnByb2Nlc3NBbmRSZXNldFF1ZXJ5U3RhdGUoKSwgb3B0X29wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG5cdCogQnVpbGRzIFVSTCBieSBqb2luaW5nIHRoZSBoZWFkZXJzIGFuZCBhdXRoLlxuXHQqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQqICAgYmUgY2hhaW5lZC5cblx0KiBAY2hhaW5hYmxlXG5cdCovXG4gIGJ1aWxkVXJsXygpIHtcbiAgICByZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuICAgICAgLnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuICAgICAgLmhlYWRlcnModGhpcy5oZWFkZXJzXylcbiAgICAgIC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgdXNlZCBtYWluIHtAbGluayBGaWx0ZXJ9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LCBhXG5cdCAqIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRPckNyZWF0ZUZpbHRlcl8oKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcl8pIHtcbiAgICAgIHRoaXMuZmlsdGVyXyA9IG5ldyBGaWx0ZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgdXNlZCB7QGxpbmsgUXVlcnl9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LFxuXHQgKiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRPckNyZWF0ZVF1ZXJ5XygpIHtcbiAgICBpZiAoIXRoaXMucXVlcnlfKSB7XG4gICAgICB0aGlzLnF1ZXJ5XyA9IG5ldyBRdWVyeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdWVyeV87XG4gIH1cblxuICAvKipcblx0ICogQWdncmVnYXRlIGZpbHRlcnMgaW50byBxdWVyeSBhbmQgcmV0dXJuIGl0cyBsYXRlc3QgdmFsdWUuIFF1ZXJ5IGFuZFxuXHQgKiBmaWx0ZXJzIGFyZSBjbGVhbmVkIGFmdGVyIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcHJvY2Vzc0FuZFJlc2V0UXVlcnlTdGF0ZSgpIHtcbiAgICBsZXQgZmlsdGVyO1xuXG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZmlsdGVyXykpIHtcbiAgICAgIGZpbHRlciA9IHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTZWFyY2hfKSB7XG4gICAgICB0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc2VhcmNoKGZpbHRlcik7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5maWx0ZXIoZmlsdGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlfO1xuICAgIHRoaXMuaGVhZGVyc18uY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlcl8gPSBudWxsO1xuICAgIHRoaXMuaXNTZWFyY2hfID0gZmFsc2U7XG4gICAgdGhpcy5xdWVyeV8gPSBudWxsO1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhQXBpSGVscGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9kYXRhL0RhdGFBcGlIZWxwZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7YXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWR9IGZyb20gJy4uL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRlIGVtYWlsIGFwaSBjYWxscy5cbiAqL1xuY2xhc3MgRW1haWxBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRW1haWxBcGlIZWxwZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFXZURlcGxveX0gd2VkZXBsb3lDbGllbnQge0BsaW5rIFdlRGVwbG95fSBjbGllbnQgcmVmZXJlbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG4gICAgc3VwZXIod2VkZXBsb3lDbGllbnQpO1xuICAgIHRoaXMucGFyYW1zID0gbmV3IE11bHRpTWFwKCk7XG4gIH1cblxuICAvKipcblx0ICogU2V0IGZyb20gYXR0cmlidXRlIG9uIHBhcmFtcyB0byBiZSBzZW5kIG9uIGVtYWlsIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZnJvbVxuXHQgKiBAcmV0dXJuIHtFbWFpbEFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIEVtYWlsQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLFxuXHQgKiAgIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBmcm9tKGZyb20pIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGZyb20sICdQYXJhbWV0ZXIgXCJmcm9tXCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLnNldCgnZnJvbScsIGZyb20pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0IGJjYyBhdHRyaWJ1dGUgb24gcGFyYW1zIHRvIGJlIHNlbmQgb24gZW1haWwgcmVxdWVzdC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBiY2Ncblx0ICogQHJldHVybiB7RW1haWxBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBFbWFpbEFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgYmNjKGJjYykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoYmNjLCAnUGFyYW1ldGVyIFwiYmNjXCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLmFkZCgnYmNjJywgYmNjKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBjYyBhdHRyaWJ1dGUgb24gcGFyYW1zIHRvIGJlIHNlbmQgb24gZW1haWwgcmVxdWVzdC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjY1xuXHQgKiBAcmV0dXJuIHtFbWFpbEFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIEVtYWlsQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLFxuXHQgKiAgIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBjYyhjYykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoY2MsICdQYXJhbWV0ZXIgXCJjY1wiIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICB0aGlzLnBhcmFtcy5hZGQoJ2NjJywgY2MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0IG1lc3NhZ2UgYXR0cmlidXRlIG9uIHBhcmFtcyB0byBiZSBzZW5kIG9uIGVtYWlsIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcmV0dXJuIHtFbWFpbEFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIEVtYWlsQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLFxuXHQgKiAgIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBtZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKG1lc3NhZ2UsICdQYXJhbWV0ZXIgXCJtZXNzYWdlXCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLnNldCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0IHByaW9yaXR5IGF0dHJpYnV0ZSBvbiBwYXJhbXMgdG8gYmUgc2VuZCBvbiBlbWFpbCByZXF1ZXN0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHByaW9yaXR5XG5cdCAqIEByZXR1cm4ge0VtYWlsQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRW1haWxBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsXG5cdCAqICAgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHByaW9yaXR5KHByaW9yaXR5KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChwcmlvcml0eSwgJ1BhcmFtZXRlciBcInByaW9yaXR5XCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLnNldCgncHJpb3JpdHknLCBwcmlvcml0eSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgcmVwbHlUbyBhdHRyaWJ1dGUgb24gcGFyYW1zIHRvIGJlIHNlbmQgb24gZW1haWwgcmVxdWVzdC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSByZXBseVRvXG5cdCAqIEByZXR1cm4ge0VtYWlsQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRW1haWxBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsXG5cdCAqICAgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHJlcGx5VG8ocmVwbHlUbykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwocmVwbHlUbywgJ1BhcmFtZXRlciBcInJlcGx5VG9cIiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgdGhpcy5wYXJhbXMuc2V0KCdyZXBseVRvJywgcmVwbHlUbyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgdG8gYXR0cmlidXRlIG9uIHBhcmFtcyB0byBiZSBzZW5kIG9uIGVtYWlsIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdG9cblx0ICogQHJldHVybiB7RW1haWxBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBFbWFpbEFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgdG8odG8pIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKHRvLCAnUGFyYW1ldGVyIFwidG9cIiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgdGhpcy5wYXJhbXMuYWRkKCd0bycsIHRvKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBzdWJqZWN0IGF0dHJpYnV0ZSBvbiBwYXJhbXMgdG8gYmUgc2VuZCBvbiBlbWFpbCByZXF1ZXN0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHN1YmplY3Rcblx0ICogQHJldHVybiB7RW1haWxBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBFbWFpbEFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgc3ViamVjdChzdWJqZWN0KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChzdWJqZWN0LCAnUGFyYW1ldGVyIFwic3ViamVjdFwiIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICB0aGlzLnBhcmFtcy5zZXQoJ3N1YmplY3QnLCBzdWJqZWN0KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNlbmRzIGFuIGVtYWlsIGJhc2VkIG9uIGdpdmVuIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIHNlbmQoKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5idWlsZFVybF8oKS5wYXRoKCdlbWFpbHMnKTtcblxuICAgIHRoaXMucGFyYW1zLm5hbWVzKCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyYW1zLmdldEFsbChuYW1lKTtcblxuICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBjbGllbnQuZm9ybShuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMucGFyYW1zLmNsZWFyKCk7XG4gICAgdGhpcy5oZWFkZXJzXy5jbGVhcigpO1xuXG4gICAgcmV0dXJuIGNsaWVudFxuICAgICAgLnBvc3QoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhbiBlbWFpbC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBlbWFpbElkXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzdGF0dXMoZW1haWxJZCkge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoZW1haWxJZCwgJ1BhcmFtZXRlciBcImVtYWlsSWRcIiBwYXJhbSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKCdlbWFpbHMnLCBlbWFpbElkLCAnc3RhdHVzJylcbiAgICAgIC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgVVJMIGJ5IGpvaW5pbmcgdGhlIGhlYWRlcnMgYW5kIGF1dGguXG4gICAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuICAgKiAgIGJlIGNoYWluZWQuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGJ1aWxkVXJsXygpIHtcbiAgICByZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuICAgICAgLnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmVtYWlsVXJsXylcbiAgICAgIC5oZWFkZXJzKHRoaXMuaGVhZGVyc18pXG4gICAgICAuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRW1haWxBcGlIZWxwZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL2VtYWlsL0VtYWlsQXBpSGVscGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGxheWVyIGZvciBzdHJpbmcgdG8gYmFzZTY0IGNvbnZlcnNpb25cbiAqIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zNDYyXG4gKi9cbmNsYXNzIEJhc2U2NCB7XG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgYmFzZS02NCBlbmNvZGVkIEFTQ0lJIHN0cmluZyBmcm9tIGEgXCJzdHJpbmdcIiBvZiBiaW5hcnkgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBiZSBlbmNvZGVkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBlbmNvZGVTdHJpbmcoc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN0cmluZy50b1N0cmluZygpLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U2NDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jcnlwdC9CYXNlNjQuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9hcGktcXVlcnkvR2VvJztcbmltcG9ydCBXZURlcGxveSBmcm9tICcuLi9hcGkvV2VEZXBsb3knO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vYXBpLXF1ZXJ5L1JhbmdlJztcblxuZ2xvYmFscy53aW5kb3cuRmlsdGVyID0gRmlsdGVyO1xuZ2xvYmFscy53aW5kb3cuR2VvID0gR2VvO1xuZ2xvYmFscy53aW5kb3cuUXVlcnkgPSBRdWVyeTtcbmdsb2JhbHMud2luZG93LlJhbmdlID0gUmFuZ2U7XG5nbG9iYWxzLndpbmRvdy5XZURlcGxveSA9IFdlRGVwbG95O1xuXG5leHBvcnQge0ZpbHRlciwgR2VvLCBRdWVyeSwgUmFuZ2UsIFdlRGVwbG95fTtcbmV4cG9ydCBkZWZhdWx0IFdlRGVwbG95O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Vudi9icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9tZXRhbFVyaSA9IHJlcXVpcmUoJ21ldGFsLXVyaScpO1xuXG52YXIgX21ldGFsVXJpMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ldGFsVXJpKTtcblxudmFyIF9tZXRhbFByb21pc2UgPSByZXF1aXJlKCdtZXRhbC1wcm9taXNlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBamF4ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBBamF4KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBamF4KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhBamF4LCBudWxsLCBbe1xuXHRcdGtleTogJ3BhcnNlUmVzcG9uc2VIZWFkZXJzJyxcblxuXG5cdFx0LyoqXG4gICAqIFhtbEh0dHBSZXF1ZXN0J3MgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2ZcbiAgICogcmVzcG9uc2UgaGVhZGVycyBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdCBkZXNjcmliZWQgb24gdGhlIHNwZWM6XG4gICAqIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLWdldGFsbHJlc3BvbnNlaGVhZGVycy1tZXRob2R9LlxuICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgdGhhdCBzdHJpbmcgaW50byBhIHVzZXItZnJpZW5kbHkgbmFtZS92YWx1ZSBwYWlyXG4gICAqIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFsbEhlYWRlcnMgQWxsIGhlYWRlcnMgYXMgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPE9iamVjdDxzdHJpbmcsIHN0cmluZz4+fVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gcGFyc2VSZXNwb25zZUhlYWRlcnMoYWxsSGVhZGVycykge1xuXHRcdFx0dmFyIGhlYWRlcnMgPSBbXTtcblx0XHRcdGlmICghYWxsSGVhZGVycykge1xuXHRcdFx0XHRyZXR1cm4gaGVhZGVycztcblx0XHRcdH1cblx0XHRcdHZhciBwYWlycyA9IGFsbEhlYWRlcnMuc3BsaXQoJ1xcclxcbicpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBwYWlyc1tpXS5pbmRleE9mKCc6ICcpO1xuXHRcdFx0XHRpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhaXJzW2ldLnN1YnN0cmluZyhpbmRleCArIDIpO1xuXHRcdFx0XHRcdGhlYWRlcnMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoZWFkZXJzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgdXJsIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IG1ldGhvZFxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGJvZHlcbiAgICogQHBhcmFtIHtNdWx0aU1hcD19IG9wdF9oZWFkZXJzXG4gICAqIEBwYXJhbSB7TXVsdGlNYXA9fSBvcHRfcGFyYW1zXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RpbWVvdXRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3N5bmNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dpdGhDcmVkZW50aWFsc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBEZWZlcnJlZCBhamF4IHJlcXVlc3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcXVlc3QnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0KHVybCwgbWV0aG9kLCBib2R5LCBvcHRfaGVhZGVycywgb3B0X3BhcmFtcywgb3B0X3RpbWVvdXQsIG9wdF9zeW5jLCBvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0XHR1cmwgPSB1cmwgfHwgJyc7XG5cdFx0XHRtZXRob2QgPSBtZXRob2QgfHwgJ0dFVCc7XG5cblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdHZhciBwcm9taXNlID0gbmV3IF9tZXRhbFByb21pc2UuQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuXHRcdFx0XHRcdFx0cmVxdWVzdC5vbmVycm9yKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc29sdmUocmVxdWVzdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgZXJyb3InKTtcblx0XHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSkudGhlbkNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdFx0cmVxdWVzdC5hYm9ydCgpO1xuXHRcdFx0XHR0aHJvdyByZWFzb247XG5cdFx0XHR9KS50aGVuQWx3YXlzKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHVybCA9IG5ldyBfbWV0YWxVcmkyLmRlZmF1bHQodXJsKTtcblxuXHRcdFx0aWYgKG9wdF9wYXJhbXMpIHtcblx0XHRcdFx0dXJsLmFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAob3B0X3BhcmFtcykudG9TdHJpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dXJsID0gdXJsLnRvU3RyaW5nKCk7XG5cblx0XHRcdHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgIW9wdF9zeW5jKTtcblxuXHRcdFx0aWYgKG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRcdFx0cmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0X2hlYWRlcnMpIHtcblx0XHRcdFx0b3B0X2hlYWRlcnMubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdFx0cmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG9wdF9oZWFkZXJzLmdldEFsbChuYW1lKS5qb2luKCcsICcpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJlcXVlc3Quc2VuZCgoMCwgX21ldGFsLmlzRGVmKShib2R5KSA/IGJvZHkgOiBudWxsKTtcblxuXHRcdFx0aWYgKCgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKShvcHRfdGltZW91dCkpIHtcblx0XHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRwcm9taXNlLmNhbmNlbCgnUmVxdWVzdCB0aW1lb3V0Jyk7XG5cdFx0XHRcdH0sIG9wdF90aW1lb3V0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEFqYXg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFqYXg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLWFqYXgvbGliL0FqYXguanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogUHJvbWlzZXMgcG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKlxuICogICAgICBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9URShlZHVhcmRvKTogUHJvbWlzZSBzdXBwb3J0IGlzIG5vdCByZWFkeSBvbiBhbGwgc3VwcG9ydGVkIGJyb3dzZXJzLFxuICogdGhlcmVmb3JlIG1ldGFsLXByb21pc2UgaXMgdGVtcG9yYXJpbHkgdXNpbmcgR29vZ2xlJ3MgcHJvbWlzZXMgYXMgcG9seWZpbGwuXG4gKiBJdCBzdXBwb3J0cyBjYW5jZWxsYWJsZSBwcm9taXNlcyBhbmQgaGFzIGNsZWFuIGFuZCBmYXN0IGltcGxlbWVudGF0aW9uLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ2FuY2VsbGFibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbW9yZSBzdHJpY3QgaW50ZXJmYWNlIGZvciBUaGVuYWJsZXMgaW4gdGVybXMgb2ZcbiAqIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbSBmb3IgaW50ZXJvcCB3aXRoIHtAc2VlIENhbmNlbGxhYmxlUHJvbWlzZX0uXG4gKlxuICogQGludGVyZmFjZVxuICogQGV4dGVuZHMge0lUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG52YXIgVGhlbmFibGUgPSBmdW5jdGlvbiBUaGVuYWJsZSgpIHt9O1xuXG4vKipcbiAqIEFkZHMgY2FsbGJhY2tzIHRoYXQgd2lsbCBvcGVyYXRlIG9uIHRoZSByZXN1bHQgb2YgdGhlIFRoZW5hYmxlLCByZXR1cm5pbmcgYVxuICogbmV3IGNoaWxkIFByb21pc2UuXG4gKlxuICogSWYgdGhlIFRoZW5hYmxlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZVxuICogaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGxcbiAqIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzXG4gKiBhbiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlXG4gKiBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBUaGVuYWJsZSBpcyByZWplY3RlZCwgdGhlIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXG4gKiB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrIG9yIHRocm93biB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gez8oZnVuY3Rpb24odGhpczpUSElTLCBUWVBFKTpcbiAqICAgICAgICAgICAgIChSRVNVTFR8SVRoZW5hYmxlLjxSRVNVTFQ+fFRoZW5hYmxlKSk9fSBvcHRfb25GdWxmaWxsZWQgQVxuICogICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlmIHRoZSBQcm9taXNlXG4gKiAgICAgaXMgZnVsbGZpbGxlZC5cbiAqIEBwYXJhbSB7PyhmdW5jdGlvbigqKTogKik9fSBvcHRfb25SZWplY3RlZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gKiAgICAgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGVcbiAqICAgICBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy4gQnkgZGVmYXVsdCwgZnVuY3Rpb25zIGFyZSBleGVjdXRlZFxuICogICAgIHdpdGggdGhlIGRlZmF1bHQgdGhpcy5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFJFU1VMVD59IEEgbmV3IFByb21pc2UgdGhhdCB3aWxsIHJlY2VpdmUgdGhlXG4gKiAgICAgcmVzdWx0IG9mIHRoZSBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gY2FsbGJhY2suXG4gKiBAdGVtcGxhdGUgUkVTVUxULFRISVNcbiAqL1xuVGhlbmFibGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoKSB7fTtcblxuLyoqXG4gKiBBbiBleHBhbmRvIHByb3BlcnR5IHRvIGluZGljYXRlIHRoYXQgYW4gb2JqZWN0IGltcGxlbWVudHNcbiAqIHtAY29kZSBUaGVuYWJsZX0uXG4gKlxuICoge0BzZWUgYWRkSW1wbGVtZW50YXRpb259LlxuICpcbiAqIEBjb25zdFxuICovXG5UaGVuYWJsZS5JTVBMRU1FTlRFRF9CWV9QUk9QID0gJyRnb29nX1RoZW5hYmxlJztcblxuLyoqXG4gKiBNYXJrcyBhIGdpdmVuIGNsYXNzIChjb25zdHJ1Y3RvcikgYXMgYW4gaW1wbGVtZW50YXRpb24gb2YgVGhlbmFibGUsIHNvXG4gKiB0aGF0IHdlIGNhbiBxdWVyeSB0aGF0IGZhY3QgYXQgcnVudGltZS4gVGhlIGNsYXNzIG11c3QgaGF2ZSBhbHJlYWR5XG4gKiBpbXBsZW1lbnRlZCB0aGUgaW50ZXJmYWNlLlxuICogRXhwb3J0cyBhICd0aGVuJyBtZXRob2Qgb24gdGhlIGNvbnN0cnVjdG9yIHByb3RvdHlwZSwgc28gdGhhdCB0aGUgb2JqZWN0c1xuICogYWxzbyBpbXBsZW1lbnQgdGhlIGV4dGVybiB7QHNlZSBUaGVuYWJsZX0gaW50ZXJmYWNlIGZvciBpbnRlcm9wIHdpdGhcbiAqIG90aGVyIFByb21pc2UgaW1wbGVtZW50YXRpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VGhlbmFibGUsLi4uWz9dKX0gY3RvciBUaGUgY2xhc3MgY29uc3RydWN0b3IuIFRoZVxuICogICAgIGNvcnJlc3BvbmRpbmcgY2xhc3MgbXVzdCBoYXZlIGFscmVhZHkgaW1wbGVtZW50ZWQgdGhlIGludGVyZmFjZS5cbiAqL1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbiAoY3Rvcikge1xuICBjdG9yLnByb3RvdHlwZS50aGVuID0gY3Rvci5wcm90b3R5cGUudGhlbjtcbiAgY3Rvci5wcm90b3R5cGUuJGdvb2dfVGhlbmFibGUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGdpdmVuIGluc3RhbmNlIGltcGxlbWVudHMge0Bjb2RlIFRoZW5hYmxlfS5cbiAqICAgICBUaGUgY2xhc3Mvc3VwZXJjbGFzcyBvZiB0aGUgaW5zdGFuY2UgbXVzdCBjYWxsIHtAY29kZSBhZGRJbXBsZW1lbnRhdGlvbn0uXG4gKi9cblRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gISFvYmplY3QuJGdvb2dfVGhlbmFibGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBQcm9wZXJ0eSBhY2Nlc3Mgc2VlbXMgdG8gYmUgZm9yYmlkZGVuLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGJpbmQoKSwgZXhjZXB0IHRoYXQgYSAndGhpcyBvYmplY3QnIGlzIG5vdCByZXF1aXJlZC4gVXNlZnVsIHdoZW4gdGhlXG4gKiB0YXJnZXQgZnVuY3Rpb24gaXMgYWxyZWFkeSBib3VuZC5cbiAqXG4gKiBVc2FnZTpcbiAqIHZhciBnID0gcGFydGlhbChmLCBhcmcxLCBhcmcyKTtcbiAqIGcoYXJnMywgYXJnNCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIGZuLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGJpbmQoKSB3YXNcbiAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICovXG52YXIgcGFydGlhbCA9IGZ1bmN0aW9uIHBhcnRpYWwoZm4pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIENsb25lIHRoZSBhcnJheSAod2l0aCBzbGljZSgpKSBhbmQgYXBwZW5kIGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgLy8gdG8gdGhlIGV4aXN0aW5nIGFyZ3VtZW50cy5cbiAgICB2YXIgbmV3QXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICBuZXdBcmdzLnB1c2guYXBwbHkobmV3QXJncywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gIH07XG59O1xuXG4vKipcbiAqIFByb21pc2VzIHByb3ZpZGUgYSByZXN1bHQgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHkuIEEgUHJvbWlzZSBtYXlcbiAqIGJlIHJlc29sdmVkIGJ5IGJlaW5nIGZ1bGZpbGxlZCBvciByZWplY3RlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIHdpbGwgYmUga25vd25cbiAqIGFzIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvciB0aGUgcmVqZWN0aW9uIHJlYXNvbi4gV2hldGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLCB0aGUgUHJvbWlzZSByZXN1bHQgaXMgaW1tdXRhYmxlIG9uY2UgaXQgaXMgc2V0LlxuICpcbiAqIFByb21pc2VzIG1heSByZXByZXNlbnQgcmVzdWx0cyBvZiBhbnkgdHlwZSwgaW5jbHVkaW5nIHVuZGVmaW5lZC4gUmVqZWN0aW9uXG4gKiByZWFzb25zIGFyZSB0eXBpY2FsbHkgRXJyb3JzLCBidXQgbWF5IGFsc28gYmUgb2YgYW55IHR5cGUuIENsb3N1cmUgUHJvbWlzZXNcbiAqIGFsbG93IGZvciBvcHRpb25hbCB0eXBlIGFubm90YXRpb25zIHRoYXQgZW5mb3JjZSB0aGF0IGZ1bGZpbGxtZW50IHZhbHVlcyBhcmVcbiAqIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlcyBhdCBjb21waWxlIHRpbWUuXG4gKlxuICogVGhlIHJlc3VsdCBvZiBhIFByb21pc2UgaXMgYWNjZXNzaWJsZSBieSBjYWxsaW5nIHtAY29kZSB0aGVufSBhbmQgcmVnaXN0ZXJpbmdcbiAqIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MuIE9uY2UgdGhlIFByb21pc2VcbiAqIHJlc29sdmVzLCB0aGUgcmVsZXZhbnQgY2FsbGJhY2tzIGFyZSBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIG9yXG4gKiByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LiBDYWxsYmFja3MgYXJlIGFsd2F5cyBpbnZva2VkIGluIHRoZSBvcmRlciB0aGV5XG4gKiB3ZXJlIHJlZ2lzdGVyZWQsIGV2ZW4gd2hlbiBhZGRpdGlvbmFsIHtAY29kZSB0aGVufSBjYWxscyBhcmUgbWFkZSBmcm9tIGluc2lkZVxuICogYW5vdGhlciBjYWxsYmFjay4gQSBjYWxsYmFjayBpcyBhbHdheXMgcnVuIGFzeW5jaHJvbm91c2x5IHNvbWV0aW1lIGFmdGVyIHRoZVxuICogc2NvcGUgY29udGFpbmluZyB0aGUgcmVnaXN0ZXJpbmcge0Bjb2RlIHRoZW59IGludm9jYXRpb24gaGFzIHJldHVybmVkLlxuICpcbiAqIElmIGEgUHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIGFub3RoZXIgUHJvbWlzZSwgdGhlIGZpcnN0IFByb21pc2Ugd2lsbCBibG9ja1xuICogdW50aWwgdGhlIHNlY29uZCBpcyByZXNvbHZlZCwgYW5kIHRoZW4gYXNzdW1lcyB0aGUgc2FtZSByZXN1bHQgYXMgdGhlIHNlY29uZFxuICogUHJvbWlzZS4gVGhpcyBhbGxvd3MgUHJvbWlzZXMgdG8gZGVwZW5kIG9uIHRoZSByZXN1bHRzIG9mIG90aGVyIFByb21pc2VzLFxuICogbGlua2luZyB0b2dldGhlciBtdWx0aXBsZSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbiBhbmRcbiAqIHBhc3NlcyB0aGF0IHNwZWNpZmljYXRpb24ncyBjb25mb3JtYW5jZSB0ZXN0IHN1aXRlLiBBIENsb3N1cmUgUHJvbWlzZSBtYXkgYmVcbiAqIHJlc29sdmVkIHdpdGggYSBQcm9taXNlIGluc3RhbmNlIChvciBzdWZmaWNpZW50bHkgY29tcGF0aWJsZSBQcm9taXNlLWxpa2VcbiAqIG9iamVjdCkgY3JlYXRlZCBieSBvdGhlciBQcm9taXNlIGltcGxlbWVudGF0aW9ucy4gRnJvbSB0aGUgc3BlY2lmaWNhdGlvbixcbiAqIFByb21pc2UtbGlrZSBvYmplY3RzIGFyZSBrbm93biBhcyBcIlRoZW5hYmxlc1wiLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tL1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oXG4gKiAgICAgICAgICAgICB0aGlzOlJFU09MVkVSX0NPTlRFWFQsXG4gKiAgICAgICAgICAgICBmdW5jdGlvbigoVFlQRXxJVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKSksXG4gKiAgICAgICAgICAgICBmdW5jdGlvbigqKSk6IHZvaWR9IHJlc29sdmVyXG4gKiAgICAgSW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5IHdpdGgge0Bjb2RlIHJlc29sdmV9XG4gKiAgICAgYW5kIHtAY29kZSByZWplY3R9IGZ1bmN0aW9ucyBhcyBhcmd1bWVudHMuIFRoZSBQcm9taXNlIGlzIHJlc29sdmVkIG9yXG4gKiAgICAgcmVqZWN0ZWQgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGVpdGhlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7UkVTT0xWRVJfQ09OVEVYVD19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgZm9yIGV4ZWN1dGluZyB0aGVcbiAqICAgICByZXNvbHZlciBmdW5jdGlvbi4gSWYgdW5zcGVjaWZpZWQsIHRoZSByZXNvbHZlciBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGRlZmF1bHQgc2NvcGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBmaW5hbFxuICogQGltcGxlbWVudHMge1RoZW5hYmxlLjxUWVBFPn1cbiAqIEB0ZW1wbGF0ZSBUWVBFLFJFU09MVkVSX0NPTlRFWFRcbiAqL1xudmFyIENhbmNlbGxhYmxlUHJvbWlzZSA9IGZ1bmN0aW9uIENhbmNlbGxhYmxlUHJvbWlzZShyZXNvbHZlciwgb3B0X2NvbnRleHQpIHtcbiAgLyoqXG4gICAqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIFByb21pc2UuIEVpdGhlciBQRU5ESU5HLCBGVUxGSUxMRUQsIFJFSkVDVEVELCBvclxuICAgKiBCTE9DS0VELlxuICAgKiBAcHJpdmF0ZSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX31cbiAgICovXG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgcmVzdWx0IG9mIHRoZSBQcm9taXNlLiBJbW11dGFibGUgb25jZSBzZXQgd2l0aCBlaXRoZXIgYVxuICAgKiBmdWxmaWxsbWVudCB2YWx1ZSBvciByZWplY3Rpb24gcmVhc29uLlxuICAgKiBAcHJpdmF0ZSB7Kn1cbiAgICovXG4gIHRoaXMucmVzdWx0XyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRm9yIFByb21pc2VzIGNyZWF0ZWQgYnkgY2FsbGluZyB7QGNvZGUgdGhlbigpfSwgdGhlIG9yaWdpbmF0aW5nIHBhcmVudC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZX1cbiAgICovXG4gIHRoaXMucGFyZW50XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYWRkZWQgdG9cbiAgICogdGhpcyBQcm9taXNlIGJ5IGNhbGxzIHRvIHtAY29kZSB0aGVuKCl9LlxuICAgKiBAcHJpdmF0ZSB7QXJyYXkuPENhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5Xz59XG4gICAqL1xuICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBQcm9taXNlIGlzIGluIHRoZSBxdWV1ZSBvZiBQcm9taXNlcyB0byBleGVjdXRlLlxuICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZXhlY3V0aW5nXyA9IGZhbHNlO1xuXG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICAvKipcbiAgICAgKiBBIHRpbWVvdXQgSUQgdXNlZCB3aGVuIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX0gaXMgZ3JlYXRlclxuICAgICAqIHRoYW4gMCBtaWxsaXNlY29uZHMuIFRoZSBJRCBpcyBzZXQgd2hlbiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgYW5kXG4gICAgICogY2xlYXJlZCBvbmx5IGlmIGFuIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGVcbiAgICAgKiBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBiZWZvcmUgdGhlIGRlbGF5IGlzIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQgY29tcGxldGVzLCB0aGVcbiAgICAgKiByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSAwO1xuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIHNldCB0byAwIG1pbGxpc2Vjb25kcywgYVxuICAgICAqIGJvb2xlYW4gdGhhdCBpcyBzZXQgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZCByZXNldCB0byBmYWxzZSBpZiBhblxuICAgICAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGUgUHJvbWlzZSAob3Igb25lIG9mIGl0c1xuICAgICAqIGRlc2NlbmRhbnRzKS4gSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIG5leHQgdGltZXN0ZXAsXG4gICAgICogdGhlIHJlamVjdGlvbiByZWFzb24gaXMgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXNvbHZlci5jYWxsKG9wdF9jb250ZXh0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHNlbGYucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGUpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGEgcmVqZWN0ZWQgUHJvbWlzZSdzIHJlYXNvbiBpcyBwYXNzZWQgdG9cbiAqIHRoZSByZWplY3Rpb24gaGFuZGxlci4gQnkgZGVmYXVsdCwgdGhlIHJlamVjdGlvbiBoYW5kbGVyIHJldGhyb3dzIHRoZVxuICogcmVqZWN0aW9uIHJlYXNvbiBzbyB0aGF0IGl0IGFwcGVhcnMgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIG9yXG4gKiB7QGNvZGUgd2luZG93Lm9uZXJyb3J9IGhhbmRsZXIuXG4gKiBSZWplY3Rpb25zIGFyZSByZXRocm93biBhcyBxdWlja2x5IGFzIHBvc3NpYmxlIGJ5IGRlZmF1bHQuIEEgbmVnYXRpdmUgdmFsdWVcbiAqIGRpc2FibGVzIHJlamVjdGlvbiBoYW5kbGluZyBlbnRpcmVseS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID0gMDtcblxuLyoqXG4gKiBUaGUgcG9zc2libGUgaW50ZXJuYWwgc3RhdGVzIGZvciBhIFByb21pc2UuIFRoZXNlIHN0YXRlcyBhcmUgbm90IGRpcmVjdGx5XG4gKiBvYnNlcnZhYmxlIHRvIGV4dGVybmFsIGNhbGxlcnMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXyA9IHtcbiAgLyoqIFRoZSBQcm9taXNlIGlzIHdhaXRpbmcgZm9yIHJlc29sdXRpb24uICovXG4gIFBFTkRJTkc6IDAsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGlzIGJsb2NrZWQgd2FpdGluZyBmb3IgdGhlIHJlc3VsdCBvZiBhbm90aGVyIFRoZW5hYmxlLiAqL1xuICBCTE9DS0VEOiAxLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCB3aXRoIGEgZnVsZmlsbG1lbnQgdmFsdWUuICovXG4gIEZVTEZJTExFRDogMixcblxuICAvKiogVGhlIFByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIHJlamVjdGlvbiByZWFzb24uICovXG4gIFJFSkVDVEVEOiAzXG59O1xuXG4vKipcbiAqIFR5cGVkZWYgZm9yIGVudHJpZXMgaW4gdGhlIGNhbGxiYWNrIGNoYWluLiBFYWNoIGNhbGwgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5DYXRjaH0sIG9yIHtAY29kZSB0aGVuQWx3YXlzfSBjcmVhdGVzIGFuIGVudHJ5IGNvbnRhaW5pbmcgdGhlXG4gKiBmdW5jdGlvbnMgdGhhdCBtYXkgYmUgaW52b2tlZCBvbmNlIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICpcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGNoaWxkOiBDYW5jZWxsYWJsZVByb21pc2UsXG4gKiAgIG9uRnVsZmlsbGVkOiBmdW5jdGlvbigqKSxcbiAqICAgb25SZWplY3RlZDogZnVuY3Rpb24oKilcbiAqIH19XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8gPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7KFRZUEV8VGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT19IG9wdF92YWx1ZVxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgbmV3IFByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZXNvbHZlZFxuICogICAgIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAob3B0X3ZhbHVlKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZShvcHRfdmFsdWUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb3B0X3JlYXNvblxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlXG4gKiAgICAgZ2l2ZW4gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKG9wdF9yZWFzb24pIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdChvcHRfcmVhc29uKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIHRoZSByZXN1bHQgb2YgdGhlXG4gKiAgICAgZmlyc3QgUHJvbWlzZSAob3IgUHJvbWlzZS1saWtlKSBpbnB1dCB0byBjb21wbGV0ZS5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgcHJvbWlzZSA9IHByb21pc2VzW2ldOyBpKyspIHtcbiAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48IUFycmF5LjxUWVBFPj59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIGEgbGlzdCBvZlxuICogICAgIGV2ZXJ5IGZ1bGZpbGxlZCB2YWx1ZSBvbmNlIGV2ZXJ5IGlucHV0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaXNcbiAqICAgICBzdWNjZXNzZnVsbHkgZnVsZmlsbGVkLCBvciBpcyByZWplY3RlZCBieSB0aGUgZmlyc3QgcmVqZWN0aW9uIHJlc3VsdC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0b0Z1bGZpbGwgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKCF0b0Z1bGZpbGwpIHtcbiAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb25GdWxmaWxsID0gZnVuY3Rpb24gb25GdWxmaWxsKGluZGV4LCB2YWx1ZSkge1xuICAgICAgdG9GdWxmaWxsLS07XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICBpZiAodG9GdWxmaWxsID09PSAwKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24gb25SZWplY3QocmVhc29uKSB7XG4gICAgICByZWplY3QocmVhc29uKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IHByb21pc2UgPSBwcm9taXNlc1tpXTsgaSsrKSB7XG4gICAgICBwcm9taXNlLnRoZW4ocGFydGlhbChvbkZ1bGZpbGwsIGkpLCBvblJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgdGhlIHZhbHVlIG9mXG4gKiAgICAgdGhlIGZpcnN0IGlucHV0IHRvIGJlIGZ1bGZpbGxlZCwgb3IgaXMgcmVqZWN0ZWQgd2l0aCBhIGxpc3Qgb2YgZXZlcnlcbiAqICAgICByZWplY3Rpb24gcmVhc29uIGlmIGFsbCBpbnB1dHMgYXJlIHJlamVjdGVkLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmZpcnN0RnVsZmlsbGVkID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdG9SZWplY3QgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgdmFyIHJlYXNvbnMgPSBbXTtcblxuICAgIGlmICghdG9SZWplY3QpIHtcbiAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb25GdWxmaWxsID0gZnVuY3Rpb24gb25GdWxmaWxsKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24gb25SZWplY3QoaW5kZXgsIHJlYXNvbikge1xuICAgICAgdG9SZWplY3QtLTtcbiAgICAgIHJlYXNvbnNbaW5kZXhdID0gcmVhc29uO1xuICAgICAgaWYgKHRvUmVqZWN0ID09PSAwKSB7XG4gICAgICAgIHJlamVjdChyZWFzb25zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IHByb21pc2UgPSBwcm9taXNlc1tpXTsgaSsrKSB7XG4gICAgICBwcm9taXNlLnRoZW4ob25GdWxmaWxsLCBwYXJ0aWFsKG9uUmVqZWN0LCBpKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgUHJvbWlzZSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjaGlsZCBQcm9taXNlLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmVcbiAqIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzIGFuXG4gKiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIHRoZSB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogd2l0aCB0aGUgcmV0dXJuIHZhbHVlIChvciB0aHJvd24gdmFsdWUpIG9mIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9wdF9vbkZ1bGZpbGxlZCwgb3B0X29uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmFkZENoaWxkUHJvbWlzZV8oKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShvcHRfb25GdWxmaWxsZWQpID8gb3B0X29uRnVsZmlsbGVkIDogbnVsbCwgKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShvcHRfb25SZWplY3RlZCkgPyBvcHRfb25SZWplY3RlZCA6IG51bGwsIG9wdF9jb250ZXh0KTtcbn07XG5UaGVuYWJsZS5hZGRJbXBsZW1lbnRhdGlvbihDYW5jZWxsYWJsZVByb21pc2UpO1xuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGV0aGVyIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuIFRoZSBjYWxsYmFjayByZWNlaXZlcyBubyBhcmd1bWVudCwgYW5kIG5vIG5ldyBjaGlsZCBQcm9taXNlIGlzXG4gKiBjcmVhdGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBjbGVhbnVwIHRha2VzIHBsYWNlIGFmdGVyIGNlcnRhaW5cbiAqIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLiBDYWxsYmFja3MgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZVxuICogZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgd2l0aCBvdGhlciBjYWxscyB0byB7QGNvZGUgdGhlbn0sXG4gKiB7QGNvZGUgdGhlbkFsd2F5c30sIG9yIHtAY29kZSB0aGVuQ2F0Y2h9LlxuICpcbiAqIFNpbmNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSBuZXcgY2hpbGQgUHJvbWlzZSwgY2FuY2VsbGF0aW9uIHByb3BhZ2F0aW9uIGlzXG4gKiBub3QgcHJldmVudGVkIGJ5IGFkZGluZyBjYWxsYmFja3Mgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30uIEEgUHJvbWlzZSB0aGF0IGhhc1xuICogYSBjbGVhbnVwIGhhbmRsZXIgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZSBjYW5jZWxlZCBpZiBhbGwgb2ZcbiAqIGl0cyBjaGlsZHJlbiBjcmVhdGVkIGJ5IHtAY29kZSB0aGVufSAob3Ige0Bjb2RlIHRoZW5DYXRjaH0pIGFyZSBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyk6IHZvaWR9IG9uUmVzb2x2ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICogICAgIHdoZW4gdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IFRoaXMgUHJvbWlzZSwgZm9yIGNoYWluaW5nIGFkZGl0aW9uYWwgY2FsbHMuXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5BbHdheXMgPSBmdW5jdGlvbiAob25SZXNvbHZlZCwgb3B0X2NvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIG9uUmVzb2x2ZWQuXG4gICAgICBvblJlc29sdmVkLmNhbGwob3B0X2NvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmFkZENhbGxiYWNrRW50cnlfKHtcbiAgICBjaGlsZDogbnVsbCxcbiAgICBvblJlamVjdGVkOiBjYWxsYmFjayxcbiAgICBvbkZ1bGZpbGxlZDogY2FsbGJhY2tcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgb25seSBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpc1xuICogaXMgZXF1aXZhbGVudCB0byB7QGNvZGUgdGhlbihudWxsLCBvblJlamVjdGVkKX0uXG4gKlxuICogQHBhcmFtIHshZnVuY3Rpb24odGhpczpUSElTLCAqKTogKn0gb25SZWplY3RlZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICAgIGludm9rZWQgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGVcbiAqICAgICBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy4gQnkgZGVmYXVsdCwgZnVuY3Rpb25zIGFyZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBnbG9iYWwgc2NvcGUuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBBIG5ldyBQcm9taXNlIHRoYXQgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgb2YgdGhlXG4gKiAgICAgY2FsbGJhY2suXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5DYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5hZGRDaGlsZFByb21pc2VfKG51bGwsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KTtcbn07XG5cbi8qKlxuICogQWxpYXMgb2Yge0BsaW5rIENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNofVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhdGNoID0gQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2g7XG5cbi8qKlxuICogQ2FuY2VscyB0aGUgUHJvbWlzZSBpZiBpdCBpcyBzdGlsbCBwZW5kaW5nIGJ5IHJlamVjdGluZyBpdCB3aXRoIGEgY2FuY2VsXG4gKiBFcnJvci4gTm8gYWN0aW9uIGlzIHBlcmZvcm1lZCBpZiB0aGUgUHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkLlxuICpcbiAqIEFsbCBjaGlsZCBQcm9taXNlcyBvZiB0aGUgY2FuY2VsZWQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAqIGNhbmNlbCBlcnJvciwgYXMgd2l0aCBub3JtYWwgUHJvbWlzZSByZWplY3Rpb24uIElmIHRoZSBQcm9taXNlIHRvIGJlIGNhbmNlbGVkXG4gKiBpcyB0aGUgb25seSBjaGlsZCBvZiBhIHBlbmRpbmcgUHJvbWlzZSwgdGhlIHBhcmVudCBQcm9taXNlIHdpbGwgYWxzbyBiZVxuICogY2FuY2VsZWQuIENhbmNlbGxhdGlvbiBtYXkgcHJvcGFnYXRlIHVwd2FyZCB0aHJvdWdoIG11bHRpcGxlIGdlbmVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgQW4gb3B0aW9uYWwgZGVidWdnaW5nIG1lc3NhZ2UgZm9yIGRlc2NyaWJpbmcgdGhlXG4gKiAgICAgY2FuY2VsbGF0aW9uIHJlYXNvbi5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAob3B0X21lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICBfbWV0YWwuYXN5bmMucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKG9wdF9tZXNzYWdlKTtcbiAgICAgIGVyci5JU19DQU5DRUxMQVRJT05fRVJST1IgPSB0cnVlO1xuICAgICAgdGhpcy5jYW5jZWxJbnRlcm5hbF8oZXJyKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYW5jZWxzIHRoaXMgUHJvbWlzZSB3aXRoIHRoZSBnaXZlbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0geyFFcnJvcn0gZXJyIFRoZSBjYW5jZWxsYXRpb24gZXJyb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbEludGVybmFsXyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRfKSB7XG4gICAgICAvLyBDYW5jZWwgdGhlIFByb21pc2UgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQncyBjaGlsZCBsaXN0LlxuICAgICAgdGhpcy5wYXJlbnRfLmNhbmNlbENoaWxkXyh0aGlzLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbmNlbHMgYSBjaGlsZCBQcm9taXNlIGZyb20gdGhlIGxpc3Qgb2YgY2FsbGJhY2sgZW50cmllcy4gSWYgdGhlIFByb21pc2UgaGFzXG4gKiBub3QgYWxyZWFkeSBiZWVuIHJlc29sdmVkLCByZWplY3QgaXQgd2l0aCBhIGNhbmNlbCBlcnJvci4gSWYgdGhlcmUgYXJlIG5vXG4gKiBvdGhlciBjaGlsZHJlbiBpbiB0aGUgbGlzdCBvZiBjYWxsYmFjayBlbnRyaWVzLCBwcm9wYWdhdGUgdGhlIGNhbmNlbGxhdGlvblxuICogYnkgY2FuY2VsaW5nIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gY2hpbGRQcm9taXNlIFRoZSBQcm9taXNlIHRvIGNhbmNlbC5cbiAqIEBwYXJhbSB7IUVycm9yfSBlcnIgVGhlIGNhbmNlbCBlcnJvciB0byB1c2UgZm9yIHJlamVjdGluZyB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsQ2hpbGRfID0gZnVuY3Rpb24gKGNoaWxkUHJvbWlzZSwgZXJyKSB7XG4gIGlmICghdGhpcy5jYWxsYmFja0VudHJpZXNfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZENvdW50ID0gMDtcbiAgdmFyIGNoaWxkSW5kZXggPSAtMTtcblxuICAvLyBGaW5kIHRoZSBjYWxsYmFjayBlbnRyeSBmb3IgdGhlIGNoaWxkUHJvbWlzZSwgYW5kIGNvdW50IHdoZXRoZXIgdGhlcmUgYXJlXG4gIC8vIGFkZGl0aW9uYWwgY2hpbGQgUHJvbWlzZXMuXG4gIGZvciAodmFyIGkgPSAwLCBlbnRyeTsgZW50cnkgPSB0aGlzLmNhbGxiYWNrRW50cmllc19baV07IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGVudHJ5LmNoaWxkO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY2hpbGRDb3VudCsrO1xuICAgICAgaWYgKGNoaWxkID09PSBjaGlsZFByb21pc2UpIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRJbmRleCA+PSAwICYmIGNoaWxkQ291bnQgPiAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBjaGlsZCBQcm9taXNlIHdhcyB0aGUgb25seSBjaGlsZCwgY2FuY2VsIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICAvLyBPdGhlcndpc2UsIHJlamVjdCBvbmx5IHRoZSBjaGlsZCBQcm9taXNlIHdpdGggdGhlIGNhbmNlbCBlcnJvci5cbiAgaWYgKGNoaWxkSW5kZXggPj0gMCkge1xuICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HICYmIGNoaWxkQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuY2FuY2VsSW50ZXJuYWxfKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYWxsYmFja0VudHJ5ID0gdGhpcy5jYWxsYmFja0VudHJpZXNfLnNwbGljZShjaGlsZEluZGV4LCAxKVswXTtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhjYWxsYmFja0VudHJ5LCBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgZW50cnkgdG8gdGhlIGN1cnJlbnQgUHJvbWlzZSwgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICogZXhlY3V0aW9uIGlmIHRoZSBQcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99IGNhbGxiYWNrRW50cnkgUmVjb3JkIGNvbnRhaW5pbmdcbiAqICAgICB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIHRvIGV4ZWN1dGUgYWZ0ZXJcbiAqICAgICB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2FsbGJhY2tFbnRyeV8gPSBmdW5jdGlvbiAoY2FsbGJhY2tFbnRyeSkge1xuICBpZiAoKCF0aGlzLmNhbGxiYWNrRW50cmllc18gfHwgIXRoaXMuY2FsbGJhY2tFbnRyaWVzXy5sZW5ndGgpICYmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQgfHwgdGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQpKSB7XG4gICAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcbiAgfVxuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IFtdO1xuICB9XG4gIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5wdXNoKGNhbGxiYWNrRW50cnkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2hpbGQgUHJvbWlzZSBhbmQgYWRkcyBpdCB0byB0aGUgY2FsbGJhY2sgZW50cnkgbGlzdC4gVGhlIHJlc3VsdCBvZlxuICogdGhlIGNoaWxkIFByb21pc2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc3RhdGUgb2YgdGhlIHBhcmVudCBQcm9taXNlIGFuZCB0aGVcbiAqIHJlc3VsdCBvZiB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIFByb21pc2UgcmVzb2x1dGlvbiBwcm9jZWR1cmUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3RoZV9fbWV0aG9kXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpUSElTLCBUWVBFKTpcbiAqICAgICAgICAgIChSRVNVTFR8Q2FuY2VsbGFibGVQcm9taXNlLjxSRVNVTFQ+fFRoZW5hYmxlKX0gb25GdWxmaWxsZWQgQSBjYWxsYmFjayB0aGF0XG4gKiAgICAgd2lsbCBiZSBpbnZva2VkIGlmIHRoZSBQcm9taXNlIGlzIGZ1bGxmaWxsZWQsIG9yIG51bGwuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlRISVMsICopOiAqfSBvblJlamVjdGVkIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlXG4gKiAgICAgaW52b2tlZCBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgb3IgbnVsbC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLlxuICogICAgIGluIHRoZSBkZWZhdWx0IGNhbGxpbmcgY29udGV4dC5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IFRoZSBjaGlsZCBQcm9taXNlLlxuICogQHRlbXBsYXRlIFJFU1VMVCxUSElTXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmFkZENoaWxkUHJvbWlzZV8gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG5cbiAgdmFyIGNhbGxiYWNrRW50cnkgPSB7XG4gICAgY2hpbGQ6IG51bGwsXG4gICAgb25GdWxmaWxsZWQ6IG51bGwsXG4gICAgb25SZWplY3RlZDogbnVsbFxuICB9O1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBJbnZva2Ugb25GdWxmaWxsZWQsIG9yIHJlc29sdmUgd2l0aCB0aGUgcGFyZW50J3MgdmFsdWUgaWYgYWJzZW50LlxuICAgIGNhbGxiYWNrRW50cnkub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZCA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9uRnVsZmlsbGVkLmNhbGwob3B0X2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0gOiByZXNvbHZlO1xuXG4gICAgLy8gSW52b2tlIG9uUmVqZWN0ZWQsIG9yIHJlamVjdCB3aXRoIHRoZSBwYXJlbnQncyByZWFzb24gaWYgYWJzZW50LlxuICAgIGNhbGxiYWNrRW50cnkub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQgPyBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb25SZWplY3RlZC5jYWxsKG9wdF9jb250ZXh0LCByZWFzb24pO1xuICAgICAgICBpZiAoISgwLCBfbWV0YWwuaXNEZWYpKHJlc3VsdCkgJiYgcmVhc29uLklTX0NBTkNFTExBVElPTl9FUlJPUikge1xuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBjYW5jZWxsYXRpb24gdG8gY2hpbGRyZW4gaWYgbm8gb3RoZXIgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0gOiByZWplY3Q7XG4gIH0pO1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQucGFyZW50XyA9IHRoaXM7XG4gIHRoaXMuYWRkQ2FsbGJhY2tFbnRyeV8oXG4gIC8qKiBAdHlwZSB7Q2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSAqL2NhbGxiYWNrRW50cnkpO1xuICByZXR1cm4gY2FsbGJhY2tFbnRyeS5jaGlsZDtcbn07XG5cbi8qKlxuICogVW5ibG9ja3MgdGhlIFByb21pc2UgYW5kIGZ1bGZpbGxzIGl0IHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VFlQRX0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZEZ1bGZpbGxfID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgaXMgbm90IGJsb2NrZWQuJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG4gIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogVW5ibG9ja3MgdGhlIFByb21pc2UgYW5kIHJlamVjdHMgaXQgd2l0aCB0aGUgZ2l2ZW4gcmVqZWN0aW9uIHJlYXNvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHJlYXNvblxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS51bmJsb2NrQW5kUmVqZWN0XyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIGEgUHJvbWlzZSB3aXRoIGEgZ2l2ZW4gcmVzb2x1dGlvbiBzdGF0ZSBhbmQgdmFsdWUuIFRoaXNcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIGdpdmVuIFByb21pc2UgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gcmVzdWx0IGlzIGEgVGhlbmFibGUgKHN1Y2ggYXMgYW5vdGhlciBQcm9taXNlKSwgdGhlIFByb21pc2Ugd2lsbFxuICogYmUgcmVzb2x2ZWQgd2l0aCB0aGUgc2FtZSBzdGF0ZSBhbmQgcmVzdWx0IGFzIHRoZSBUaGVuYWJsZSBvbmNlIGl0IGlzIGl0c2VsZlxuICogcmVzb2x2ZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHJlc3VsdCBpcyBub3QgYSBUaGVuYWJsZSwgdGhlIFByb21pc2Ugd2lsbCBiZSBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkIHdpdGggdGhhdCByZXN1bHQgYmFzZWQgb24gdGhlIGdpdmVuIHN0YXRlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyN0aGVfcHJvbWlzZV9yZXNvbHV0aW9uX3Byb2NlZHVyZVxuICpcbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX30gc3RhdGVcbiAqIEBwYXJhbSB7Kn0geCBUaGUgcmVzdWx0IHRvIGFwcGx5IHRvIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlXyA9IGZ1bmN0aW9uIChzdGF0ZSwgeCkge1xuICBpZiAodGhpcy5zdGF0ZV8gIT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzID09PSB4KSB7XG4gICAgc3RhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEO1xuICAgIHggPSBuZXcgVHlwZUVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgY2Fubm90IHJlc29sdmUgdG8gaXRzZWxmJyk7XG4gIH0gZWxzZSBpZiAoVGhlbmFibGUuaXNJbXBsZW1lbnRlZEJ5KHgpKSB7XG4gICAgeCA9IC8qKiBAdHlwZSB7IVRoZW5hYmxlfSAqL3g7XG4gICAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQ7XG4gICAgeC50aGVuKHRoaXMudW5ibG9ja0FuZEZ1bGZpbGxfLCB0aGlzLnVuYmxvY2tBbmRSZWplY3RfLCB0aGlzKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoKDAsIF9tZXRhbC5pc09iamVjdCkoeCkpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB4LnRoZW47XG4gICAgICBpZiAoKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKSh0aGVuKSkge1xuICAgICAgICB0aGlzLnRyeVRoZW5fKHgsIHRoZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEO1xuICAgICAgeCA9IGU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXN1bHRfID0geDtcbiAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcblxuICBpZiAoc3RhdGUgPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQgJiYgIXguSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgQ2FuY2VsbGFibGVQcm9taXNlLmFkZFVuaGFuZGxlZFJlamVjdGlvbl8odGhpcywgeCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY2FsbCB0aGUge0Bjb2RlIHRoZW59IG1ldGhvZCBvbiBhbiBvYmplY3QgaW4gdGhlIGhvcGVzIHRoYXQgaXQgaXNcbiAqIGEgUHJvbWlzZS1jb21wYXRpYmxlIGluc3RhbmNlLiBUaGlzIGFsbG93cyBpbnRlcm9wZXJhdGlvbiBiZXR3ZWVuIGRpZmZlcmVudFxuICogUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMsIGhvd2V2ZXIgYSBub24tY29tcGxpYW50IG9iamVjdCBtYXkgY2F1c2UgYSBQcm9taXNlXG4gKiB0byBoYW5nIGluZGVmaW5pdGVseS4gSWYgdGhlIHtAY29kZSB0aGVufSBtZXRob2QgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdGhlXG4gKiBkZXBlbmRlbnQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzBcbiAqXG4gKiBAcGFyYW0ge1RoZW5hYmxlfSB0aGVuYWJsZSBBbiBvYmplY3Qgd2l0aCBhIHtAY29kZSB0aGVufSBtZXRob2QgdGhhdCBtYXkgYmVcbiAqICAgICBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2UvQSsgc3BlY2lmaWNhdGlvbi5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSB0aGVuIFRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIG9mIHRoZSBUaGVuYWJsZSBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRyeVRoZW5fID0gZnVuY3Rpb24gKHRoZW5hYmxlLCB0aGVuKSB7XG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEO1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb21pc2UudW5ibG9ja0FuZEZ1bGZpbGxfKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb21pc2UudW5ibG9ja0FuZFJlamVjdF8ocmVhc29uKTtcbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICB0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QoZSk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHBlbmRpbmcgY2FsbGJhY2tzIG9mIGEgcmVzb2x2ZWQgUHJvbWlzZSBhZnRlciBhIHRpbWVvdXQuXG4gKlxuICogU2VjdGlvbiAyLjIuNCBvZiB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbiByZXF1aXJlcyB0aGF0IFByb21pc2VcbiAqIGNhbGxiYWNrcyBtdXN0IG9ubHkgYmUgaW52b2tlZCBmcm9tIGEgY2FsbCBzdGFjayB0aGF0IG9ubHkgY29udGFpbnMgUHJvbWlzZVxuICogaW1wbGVtZW50YXRpb24gY29kZSwgd2hpY2ggd2UgYWNjb21wbGlzaCBieSBpbnZva2luZyBjYWxsYmFjayBleGVjdXRpb24gYWZ0ZXJcbiAqIGEgdGltZW91dC4gSWYge0Bjb2RlIHN0YXJ0RXhlY3V0aW9uX30gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICogUHJvbWlzZSwgdGhlIGNhbGxiYWNrIGNoYWluIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgb25jZS4gQWRkaXRpb25hbCBjYWxsYmFja3NcbiAqIG1heSBiZSBhZGRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gcGhhc2UsIGFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lXG4gKiBldmVudCBsb29wLlxuICpcbiAqIEFsbCBQcm9taXNlcyBhZGRlZCB0byB0aGUgd2FpdGluZyBsaXN0IGR1cmluZyB0aGUgc2FtZSBicm93c2VyIGV2ZW50IGxvb3BcbiAqIHdpbGwgYmUgZXhlY3V0ZWQgaW4gb25lIGJhdGNoIHRvIGF2b2lkIHVzaW5nIGEgc2VwYXJhdGUgdGltZW91dCBwZXIgUHJvbWlzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnNjaGVkdWxlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmV4ZWN1dGluZ18pIHtcbiAgICB0aGlzLmV4ZWN1dGluZ18gPSB0cnVlO1xuICAgIF9tZXRhbC5hc3luYy5ydW4odGhpcy5leGVjdXRlQ2FsbGJhY2tzXywgdGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIGZvciB0aGlzIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5leGVjdXRlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uICgpIHtcbiAgd2hpbGUgKHRoaXMuY2FsbGJhY2tFbnRyaWVzXyAmJiB0aGlzLmNhbGxiYWNrRW50cmllc18ubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmNhbGxiYWNrRW50cmllc187XG4gICAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhlbnRyaWVzW2ldLCB0aGlzLnN0YXRlXywgdGhpcy5yZXN1bHRfKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGVjdXRpbmdfID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcGVuZGluZyBjYWxsYmFjayBmb3IgdGhpcyBQcm9taXNlLiBJbnZva2VzIGFuIHtAY29kZSBvbkZ1bGZpbGxlZH1cbiAqIG9yIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBiYXNlZCBvbiB0aGUgcmVzb2x2ZWQgc3RhdGUgb2YgdGhlIFByb21pc2UuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSBjYWxsYmFja0VudHJ5IEFuIGVudHJ5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgb25GdWxmaWxsZWQgYW5kL29yIG9uUmVqZWN0ZWQgY2FsbGJhY2tzIGZvciB0aGlzIHN0ZXAuXG4gKiBAcGFyYW0ge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99IHN0YXRlIFRoZSByZXNvbHV0aW9uIHN0YXR1cyBvZiB0aGUgUHJvbWlzZSxcbiAqICAgICBlaXRoZXIgRlVMRklMTEVEIG9yIFJFSkVDVEVELlxuICogQHBhcmFtIHsqfSByZXN1bHQgVGhlIHJlc29sdmVkIHJlc3VsdCBvZiB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuZXhlY3V0ZUNhbGxiYWNrXyA9IGZ1bmN0aW9uIChjYWxsYmFja0VudHJ5LCBzdGF0ZSwgcmVzdWx0KSB7XG4gIGlmIChzdGF0ZSA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQpIHtcbiAgICBjYWxsYmFja0VudHJ5Lm9uRnVsZmlsbGVkKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fKCk7XG4gICAgY2FsbGJhY2tFbnRyeS5vblJlamVjdGVkKHJlc3VsdCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFya3MgdGhpcyByZWplY3RlZCBQcm9taXNlIGFzIGhhdmluZyBiZWluZyBoYW5kbGVkLiBBbHNvIG1hcmtzIGFueSBwYXJlbnRcbiAqIFByb21pc2VzIGluIHRoZSByZWplY3RlZCBzdGF0ZSBhcyBoYW5kbGVkLiBUaGUgcmVqZWN0aW9uIGhhbmRsZXIgd2lsbCBub1xuICogbG9uZ2VyIGJlIGludm9rZWQgZm9yIHRoaXMgUHJvbWlzZSAoaWYgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBhbHJlYWR5KS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnJlbW92ZVVuaGFuZGxlZFJlamVjdGlvbl8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwO1xuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLnVuaGFuZGxlZFJlamVjdGlvbklkXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfKTtcbiAgICAgIHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBmb3IgKHAgPSB0aGlzOyBwICYmIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgcC5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyB1bmhhbmRsZWQuIElmIG5vIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja1xuICogaXMgY2FsbGVkIGZvciB0aGlzIFByb21pc2UgYmVmb3JlIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX1cbiAqIGV4cGlyZXMsIHRoZSByZWFzb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci4gVGhlXG4gKiBoYW5kbGVyIHR5cGljYWxseSByZXRocm93cyB0aGUgcmVqZWN0aW9uIHJlYXNvbiBzbyB0aGF0IGl0IGJlY29tZXMgdmlzaWJsZSBpblxuICogdGhlIGRldmVsb3BlciBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gcHJvbWlzZSBUaGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gcmVhc29uIFRoZSBQcm9taXNlIHJlamVjdGlvbiByZWFzb24uXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZ1bmN0aW9uIChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID4gMCkge1xuICAgIHByb21pc2UudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIHJlYXNvbik7XG4gICAgfSwgQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkpO1xuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgcHJvbWlzZS5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gdHJ1ZTtcbiAgICBfbWV0YWwuYXN5bmMucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8pIHtcbiAgICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIHRoYXQgaXMgaW52b2tlZCB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29ucyBmb3IgUHJvbWlzZXMgdGhhdCBhcmVcbiAqIHJlamVjdGVkIGJ1dCBoYXZlIG5vIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgcmVnaXN0ZXJlZCB5ZXQuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKil9XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXyA9IF9tZXRhbC5hc3luYy50aHJvd0V4Y2VwdGlvbjtcblxuLyoqXG4gKiBTZXRzIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tIHVuaGFuZGxlZCByZWplY3RlZFxuICogUHJvbWlzZXMuIElmIHRoZSByZWplY3RlZCBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYW5cbiAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayByZWdpc3RlcmVkLCB0aGUgcmVqZWN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZFxuICogaGFuZGxlZCwgYW5kIHRoZSByZWplY3Rpb24gaGFuZGxlciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgdW5oYW5kbGVkIHJlamVjdGlvbnMgYXJlIHJldGhyb3duIHNvIHRoYXQgdGhlIGVycm9yIG1heSBiZVxuICogY2FwdHVyZWQgYnkgdGhlIGRldmVsb3BlciBjb25zb2xlIG9yIGEge0Bjb2RlIHdpbmRvdy5vbmVycm9yfSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tXG4gKiAgICAgcmVqZWN0ZWQgUHJvbWlzZXMuIERlZmF1bHRzIHRvIHtAY29kZSBhc3luYy50aHJvd0V4Y2VwdGlvbn0uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5zZXRVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8gPSBoYW5kbGVyO1xufTtcblxuLyoqXG4gKiBFcnJvciB1c2VkIGFzIGEgcmVqZWN0aW9uIHJlYXNvbiBmb3IgY2FuY2VsZWQgUHJvbWlzZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAZmluYWxcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoX2NsYXNzLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzcyhvcHRfbWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Vycm9yLmNhbGwodGhpcywgb3B0X21lc3NhZ2UpKTtcblxuICAgIGlmIChvcHRfbWVzc2FnZSkge1xuICAgICAgX3RoaXMubWVzc2FnZSA9IG9wdF9tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gX2NsYXNzO1xufShFcnJvcik7XG5cbi8qKiBAb3ZlcnJpZGUgKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdjYW5jZWwnO1xuXG5leHBvcnRzLkNhbmNlbGxhYmxlUHJvbWlzZSA9IENhbmNlbGxhYmxlUHJvbWlzZTtcbmV4cG9ydHMuZGVmYXVsdCA9IENhbmNlbGxhYmxlUHJvbWlzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtcHJvbWlzZS9saWIvcHJvbWlzZS9Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX21ldGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ldGFsKTtcblxudmFyIF9TdG9yYWdlTWVjaGFuaXNtID0gcmVxdWlyZSgnLi9tZWNoYW5pc20vU3RvcmFnZU1lY2hhbmlzbScpO1xuXG52YXIgX1N0b3JhZ2VNZWNoYW5pc20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RvcmFnZU1lY2hhbmlzbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuICAqIFByb3ZpZGVzIGEgY29udmVuaWVudCBBUEkgZm9yIGRhdGEgcGVyc2lzdGVuY2UgdXNpbmcgYSBzZWxlY3RlZCBkYXRhXG4gICogc3RvcmFnZSBtZWNoYW5pc20uXG4gICogQHBhcmFtIHshU3RvcmFnZU1lY2hhbmlzbX0gbWVjaGFuaXNtIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgbWVjaGFuaXNtLlxuICAqIEBjb25zdHJ1Y3RvclxuICAqL1xuXHRmdW5jdGlvbiBTdG9yYWdlKG1lY2hhbmlzbSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdG9yYWdlKTtcblxuXHRcdGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKTtcblx0XHRhc3NlcnRNZWNoYW5pc21JbnN0YW5jZU9mKG1lY2hhbmlzbSk7XG5cblx0XHQvKipcbiAgICogVGhlIG1lY2hhbmlzbSB1c2VkIHRvIHBlcnNpc3Qga2V5LXZhbHVlIHBhaXJzLlxuICAgKiBAdHlwZSB7U3RvcmFnZU1lY2hhbmlzbX1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLm1lY2hhbmlzbSA9IG1lY2hhbmlzbTtcblx0fVxuXG5cdC8qKlxuICAqIENsZWFyIGFsbCBpdGVtcyBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoU3RvcmFnZSwgW3tcblx0XHRrZXk6ICdjbGVhcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdFx0dGhpcy5tZWNoYW5pc20uY2xlYXIoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoIV9tZXRhbDIuZGVmYXVsdC5pc0RlZih2YWx1ZSkpIHtcblx0XHRcdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMubWVjaGFuaXNtLnNldChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBnZXQuXG4gICAqIEByZXR1cm4geyp9IERlc2VyaWFsaXplZCB2YWx1ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHRcdFx0dmFyIGpzb247XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uID0gdGhpcy5tZWNoYW5pc20uZ2V0KGtleSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX21ldGFsMi5kZWZhdWx0LmlzTnVsbChqc29uKSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHRocm93IFN0b3JhZ2UuRXJyb3JDb2RlLklOVkFMSURfVkFMVUU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdrZXlzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcblx0XHRcdHJldHVybiB0aGlzLm1lY2hhbmlzbS5rZXlzKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdFx0XHR0aGlzLm1lY2hhbmlzbS5yZW1vdmUoa2V5KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2l6ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20uc2l6ZSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZhbHVlcyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSB2YWx1ZXNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZhbHVlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRcdHJldHVybiB0aGlzLmtleXMoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXMuZ2V0KGtleSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gU3RvcmFnZTtcbn0oKTtcblxuLyoqXG4gKiBFcnJvcnMgdGhyb3duIGJ5IHRoZSBzdG9yYWdlLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuXG5cblN0b3JhZ2UuRXJyb3JDb2RlID0ge1xuXHRJTlZBTElEX1ZBTFVFOiAnU3RvcmFnZTogSW52YWxpZCB2YWx1ZSB3YXMgZW5jb3VudGVyZWQnXG59O1xuXG5mdW5jdGlvbiBhc3NlcnRNZWNoYW5pc21EZWZBbmROb3ROdWxsKG1lY2hhbmlzbSkge1xuXHRpZiAoIV9tZXRhbDIuZGVmYXVsdC5pc0RlZkFuZE5vdE51bGwobWVjaGFuaXNtKSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBpcyByZXF1aXJlZCcpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbUluc3RhbmNlT2YobWVjaGFuaXNtKSB7XG5cdGlmICghKG1lY2hhbmlzbSBpbnN0YW5jZW9mIF9TdG9yYWdlTWVjaGFuaXNtMi5kZWZhdWx0KSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBtdXN0IG1lIGFuIGltcGxlbWVudGF0aW9uIG9mIFN0b3JhZ2VNZWNoYW5pc20nKTtcblx0fVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBTdG9yYWdlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC1zdG9yYWdlL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxvY2FsU3RvcmFnZU1lY2hhbmlzbSA9IGV4cG9ydHMuU3RvcmFnZU1lY2hhbmlzbSA9IGV4cG9ydHMuU3RvcmFnZSA9IHVuZGVmaW5lZDtcblxudmFyIF9TdG9yYWdlID0gcmVxdWlyZSgnLi4vU3RvcmFnZScpO1xuXG52YXIgX1N0b3JhZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RvcmFnZSk7XG5cbnZhciBfU3RvcmFnZU1lY2hhbmlzbSA9IHJlcXVpcmUoJy4uL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtJyk7XG5cbnZhciBfU3RvcmFnZU1lY2hhbmlzbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdG9yYWdlTWVjaGFuaXNtKTtcblxudmFyIF9Mb2NhbFN0b3JhZ2VNZWNoYW5pc20gPSByZXF1aXJlKCcuLi9tZWNoYW5pc20vTG9jYWxTdG9yYWdlTWVjaGFuaXNtJyk7XG5cbnZhciBfTG9jYWxTdG9yYWdlTWVjaGFuaXNtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xvY2FsU3RvcmFnZU1lY2hhbmlzbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuU3RvcmFnZSA9IF9TdG9yYWdlMi5kZWZhdWx0O1xuZXhwb3J0cy5TdG9yYWdlTWVjaGFuaXNtID0gX1N0b3JhZ2VNZWNoYW5pc20yLmRlZmF1bHQ7XG5leHBvcnRzLkxvY2FsU3RvcmFnZU1lY2hhbmlzbSA9IF9Mb2NhbFN0b3JhZ2VNZWNoYW5pc20yLmRlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXN0b3JhZ2UvbGliL2FsbC9zdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfU3RvcmFnZU1lY2hhbmlzbTIgPSByZXF1aXJlKCcuL1N0b3JhZ2VNZWNoYW5pc20nKTtcblxudmFyIF9TdG9yYWdlTWVjaGFuaXNtMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0b3JhZ2VNZWNoYW5pc20yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEFic3RyYWN0IGludGVyZmFjZSBmb3Igc3RvcmluZyBhbmQgcmV0cmlldmluZyBkYXRhIHVzaW5nIHNvbWUgcGVyc2lzdGVuY2VcbiAqIG1lY2hhbmlzbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTG9jYWxTdG9yYWdlTWVjaGFuaXNtID0gZnVuY3Rpb24gKF9TdG9yYWdlTWVjaGFuaXNtKSB7XG5cdF9pbmhlcml0cyhMb2NhbFN0b3JhZ2VNZWNoYW5pc20sIF9TdG9yYWdlTWVjaGFuaXNtKTtcblxuXHRmdW5jdGlvbiBMb2NhbFN0b3JhZ2VNZWNoYW5pc20oKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2FsU3RvcmFnZU1lY2hhbmlzbSk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExvY2FsU3RvcmFnZU1lY2hhbmlzbSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKExvY2FsU3RvcmFnZU1lY2hhbmlzbSwgW3tcblx0XHRrZXk6ICdzdG9yYWdlJyxcblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHJlZmVyZW5jZSBmb3IgZ2xvYmFsIGxvY2FsIHN0b3JhZ2UuIGJ5IGRlZmF1bHRcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHN0b3JhZ2UoKSB7XG5cdFx0XHRyZXR1cm4gTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmdsb2JhbHMubG9jYWxTdG9yYWdlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY2xlYXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRcdHRoaXMuc3RvcmFnZSgpLmNsZWFyKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdrZXlzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UoKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdG9yYWdlKCkuZ2V0SXRlbShrZXkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlJyxcblxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdFx0XHR0aGlzLnN0b3JhZ2UoKS5yZW1vdmVJdGVtKGtleSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdFx0dGhpcy5zdG9yYWdlKCkuc2V0SXRlbShrZXksIHZhbHVlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NpemUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmxlbmd0aDtcblx0XHR9XG5cdH1dLCBbe1xuXHRcdGtleTogJ2lzU3VwcG9ydGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBMb2NhbFN0b3JhZ2VNZWNoYW5pc207XG59KF9TdG9yYWdlTWVjaGFuaXNtMy5kZWZhdWx0KTtcblxuaWYgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5pc1N1cHBvcnRlZCgpKSB7XG5cdExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzID0ge1xuXHRcdGxvY2FsU3RvcmFnZTogd2luZG93LmxvY2FsU3RvcmFnZVxuXHR9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBMb2NhbFN0b3JhZ2VNZWNoYW5pc207XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXN0b3JhZ2UvbGliL21lY2hhbmlzbS9Mb2NhbFN0b3JhZ2VNZWNoYW5pc20uanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZSBmdW5jdGlvbi5cbiAqL1xudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogQ2FzZSBpbnNlbnNpdGl2ZSBzdHJpbmcgTXVsdGltYXAgaW1wbGVtZW50YXRpb24uIEFsbG93cyBtdWx0aXBsZSB2YWx1ZXMgZm9yXG4gKiB0aGUgc2FtZSBrZXkgbmFtZS5cbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG5cbnZhciBNdWx0aU1hcCA9IGZ1bmN0aW9uIChfRGlzcG9zYWJsZSkge1xuXHRfaW5oZXJpdHMoTXVsdGlNYXAsIF9EaXNwb3NhYmxlKTtcblxuXHRmdW5jdGlvbiBNdWx0aU1hcCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlNYXApO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Rpc3Bvc2FibGUuY2FsbCh0aGlzKSk7XG5cblx0XHRfdGhpcy5rZXlzID0gY3JlYXRlKG51bGwpO1xuXHRcdF90aGlzLnZhbHVlcyA9IGNyZWF0ZShudWxsKTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBBZGRzIHZhbHVlIHRvIGEga2V5IG5hbWUuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICogQGNoYWluYWJsZVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBbXTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldLnB1c2godmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuICAqIENsZWFycyBtYXAgbmFtZXMgYW5kIHZhbHVlcy5cbiAgKiBAY2hhaW5hYmxlXG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcblx0XHR0aGlzLmtleXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0dGhpcy52YWx1ZXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG4gICogQ2hlY2tzIGlmIG1hcCBjb250YWlucyBhIHZhbHVlIHRvIHRoZSBrZXkgbmFtZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICogQGNoYWluYWJsZVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobmFtZSkge1xuXHRcdHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy52YWx1ZXM7XG5cdH07XG5cblx0LyoqXG4gICogQGluaGVyaXREb2NcbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0dGhpcy52YWx1ZXMgPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuICAqIENyZWF0ZXMgYSBgTXVsdGlNYXBgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cbiAgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICAqIEByZXR1cm4geyFNdWx0aU1hcH1cbiAgKi9cblxuXG5cdE11bHRpTWFwLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikge1xuXHRcdHZhciBtYXAgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXA7XG5cdH07XG5cblx0LyoqXG4gICogR2V0cyB0aGUgZmlyc3QgYWRkZWQgdmFsdWUgZnJvbSBhIGtleSBuYW1lLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Kn1cbiAgKiBAY2hhaW5hYmxlXG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVzWzBdO1xuXHRcdH1cblx0fTtcblxuXHQvKipcbiAgKiBHZXRzIGFsbCB2YWx1ZXMgZnJvbSBhIGtleSBuYW1lLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7QXJyYXkuPCo+fVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXAgaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cbiAgKiBAcmV0dXJuIHtib29sZWFufVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuXHRcdHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcblx0fTtcblxuXHQvKipcbiAgKiBHZXRzIGFycmF5IG9mIGtleSBuYW1lcy5cbiAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5uYW1lcyA9IGZ1bmN0aW9uIG5hbWVzKCkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuIF90aGlzMi5rZXlzW2tleV07XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG4gICogUmVtb3ZlcyBhbGwgdmFsdWVzIGZyb20gYSBrZXkgbmFtZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAqIEBjaGFpbmFibGVcbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRkZWxldGUgdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcbiAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGtleSBuYW1lLiBSZWxldmFudCB0byByZXBsYWNlIHRoZSBjdXJyZW50IHZhbHVlcyB3aXRoXG4gICogYSBuZXcgb25lLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICogQHBhcmFtIHsqfSB2YWx1ZVxuICAqIEBjaGFpbmFibGVcbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IFt2YWx1ZV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG4gICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgbWFwIGtleSBuYW1lcy5cbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubmFtZXMoKS5sZW5ndGg7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0aGUgcGFyc2VkIHZhbHVlcyBhcyBhIHN0cmluZy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpO1xuXHR9O1xuXG5cdHJldHVybiBNdWx0aU1hcDtcbn0oX21ldGFsLkRpc3Bvc2FibGUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNdWx0aU1hcDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtc3RydWN0cy9saWIvTXVsdGlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogR2VuZXJpYyB0cmVlIG5vZGUgZGF0YSBzdHJ1Y3R1cmUgd2l0aCBhcmJpdHJhcnkgbnVtYmVyIG9mIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIHtWfSB2YWx1ZSBWYWx1ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVHJlZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFRyZWVOb2RlKHZhbHVlKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyZWVOb2RlKTtcblxuXHRcdC8qKlxuICAgKiBUaGUgdmFsdWUuXG4gICAqIEBwcml2YXRlIHtWfVxuICAgKi9cblx0XHR0aGlzLnZhbHVlXyA9IHZhbHVlO1xuXG5cdFx0LyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG5vZGUgb3IgbnVsbCBpZiBpdCBoYXMgbm8gcGFyZW50LlxuICAgKiBAcHJpdmF0ZSB7VHJlZU5vZGV9XG4gICAqL1xuXHRcdHRoaXMucGFyZW50XyA9IG51bGw7XG5cblx0XHQvKipcbiAgICogQ2hpbGQgbm9kZXMgb3IgbnVsbCBpbiBjYXNlIG9mIGxlYWYgbm9kZS5cbiAgICogQHByaXZhdGUge0FycmF5PCFUcmVlTm9kZT59XG4gICAqL1xuXHRcdHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuICAqIEFwcGVuZHMgYSBjaGlsZCBub2RlIHRvIHRoaXMgbm9kZS5cbiAgKiBAcGFyYW0geyFUcmVlTm9kZX0gY2hpbGQgT3JwaGFuIGNoaWxkIG5vZGUuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuXHRcdGFzc2VydENoaWxkSGFzTm9QYXJlbnQoY2hpbGQpO1xuXHRcdGNoaWxkLnNldFBhcmVudCh0aGlzKTtcblx0XHR0aGlzLmNoaWxkcmVuXyA9IHRoaXMuY2hpbGRyZW5fIHx8IFtdO1xuXHRcdHRoaXMuY2hpbGRyZW5fLnB1c2goY2hpbGQpO1xuXHR9O1xuXG5cdC8qKlxuICAqIFRlbGxzIHdoZXRoZXIgdGhpcyBub2RlIGlzIHRoZSBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgKiBAcGFyYW0geyFUcmVlTm9kZX0gbm9kZSBBIG5vZGUuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG5vZGUgaXMgdGhlIGFuY2VzdG9yIG9mIHtAY29kZSBub2RlfS5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUpIHtcblx0XHR2YXIgY3VycmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0d2hpbGUgKGN1cnJlbnQpIHtcblx0XHRcdGlmIChjdXJyZW50ID09PSB0aGlzKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcbiAgKiBAcmV0dXJuIHshQXJyYXk8VHJlZU5vZGU+fSBBbGwgYW5jZXN0b3Igbm9kZXMgaW4gYm90dG9tLXVwIG9yZGVyLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmdldEFuY2VzdG9ycyA9IGZ1bmN0aW9uIGdldEFuY2VzdG9ycygpIHtcblx0XHR2YXIgYW5jZXN0b3JzID0gW107XG5cdFx0dmFyIG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuXHRcdHdoaWxlIChub2RlKSB7XG5cdFx0XHRhbmNlc3RvcnMucHVzaChub2RlKTtcblx0XHRcdG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5jZXN0b3JzO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgdGhlIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQ2hpbGQgaW5kZXguXG4gICogQHJldHVybiB7P1RyZWVOb2RlfSBUaGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgKiBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5nZXRDaGlsZEF0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRBdChpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKClbaW5kZXhdIHx8IG51bGw7XG5cdH07XG5cblx0LyoqXG4gICogQHJldHVybiB7P0FycmF5PCFUcmVlTm9kZT59IENoaWxkIG5vZGVzIG9yIG51bGwgaW4gY2FzZSBvZiBsZWFmIG5vZGUuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbl8gfHwgVHJlZU5vZGUuRU1QVFlfQVJSQVk7XG5cdH07XG5cblx0LyoqXG4gICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbiBnZXRDaGlsZENvdW50KCkge1xuXHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKCkubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBhbmNlc3RvcnMgb2YgdGhlIG5vZGUuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCgpIHtcblx0XHR2YXIgZGVwdGggPSAwO1xuXHRcdHZhciBub2RlID0gdGhpcztcblx0XHR3aGlsZSAobm9kZS5nZXRQYXJlbnQoKSkge1xuXHRcdFx0ZGVwdGgrKztcblx0XHRcdG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGVwdGg7XG5cdH07XG5cblx0LyoqXG4gICogQHJldHVybiB7P1RyZWVOb2RlfSBQYXJlbnQgbm9kZSBvciBudWxsIGlmIGl0IGhhcyBubyBwYXJlbnQuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudF87XG5cdH07XG5cblx0LyoqXG4gICogQHJldHVybiB7IVRyZWVOb2RlfSBUaGUgcm9vdCBvZiB0aGUgdHJlZSBzdHJ1Y3R1cmUsIGkuZS4gdGhlIGZhcnRoZXN0XG4gICogYW5jZXN0b3Igb2YgdGhlIG5vZGUgb3IgdGhlIG5vZGUgaXRzZWxmIGlmIGl0IGhhcyBubyBwYXJlbnRzLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiBnZXRSb290KCkge1xuXHRcdHZhciByb290ID0gdGhpcztcblx0XHR3aGlsZSAocm9vdC5nZXRQYXJlbnQoKSkge1xuXHRcdFx0cm9vdCA9IHJvb3QuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiByb290O1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgdGhlIHZhbHVlLlxuICAqIEByZXR1cm4ge1Z9IFRoZSB2YWx1ZS5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlXztcblx0fTtcblxuXHQvKipcbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uIGlzTGVhZigpIHtcblx0XHRyZXR1cm4gIXRoaXMuZ2V0Q2hpbGRDb3VudCgpO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlLlxuICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkIFRoZSBub2RlIHRvIHJlbW92ZS5cbiAgKiBAcmV0dXJuIHtUcmVlTm9kZX0gVGhlIHJlbW92ZWQgbm9kZSBpZiBhbnksIG51bGwgb3RoZXJ3aXNlLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0XHRpZiAoX21ldGFsLmFycmF5LnJlbW92ZSh0aGlzLmdldENoaWxkcmVuKCksIGNoaWxkKSkge1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcbiAgKiBTZXRzIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGlzIG5vZGUuIFRoZSBjYWxsZXJzIG11c3QgZW5zdXJlIHRoYXQgdGhlXG4gICogcGFyZW50IG5vZGUgYW5kIG9ubHkgdGhhdCBoYXMgdGhpcyBub2RlIGFtb25nIGl0cyBjaGlsZHJlbi5cbiAgKiBAcGFyYW0ge1RyZWVOb2RlfSBwYXJlbnQgVGhlIHBhcmVudCB0byBzZXQuIElmIG51bGwsIHRoZSBub2RlIHdpbGwgYmVcbiAgKiBkZXRhY2hlZCBmcm9tIHRoZSB0cmVlLlxuICAqIEBwcm90ZWN0ZWRcbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiBzZXRQYXJlbnQocGFyZW50KSB7XG5cdFx0dGhpcy5wYXJlbnRfID0gcGFyZW50O1xuXHR9O1xuXG5cdC8qKlxuICAqIFRyYXZlcnNlcyB0aGUgc3VidHJlZS4gVGhlIGZpcnN0IGNhbGxiYWNrIHN0YXJ0cyB3aXRoIHRoaXMgbm9kZSxcbiAgKiBhbmQgdmlzaXRzIHRoZSBkZXNjZW5kYW50IG5vZGVzIGRlcHRoLWZpcnN0LCBpbiBwcmVvcmRlci5cbiAgKiBUaGUgc2Vjb25kIGNhbGxiYWNrLCBzdGFydHMgd2l0aCBkZWVwZXN0IGNoaWxkIHRoZW4gdmlzaXRzXG4gICogdGhlIGFuY2VzdG9yIG5vZGVzIGRlcHRoLWZpcnN0LCBpbiBwb3N0b3JkZXIuIEUuZy5cbiAgKlxuICAqICBcdCBBXG4gICogICAgLyBcXFxuICAqICAgQiAgIENcbiAgKiAgLyAgIC8gXFxcbiAgKiBEICAgRSAgIEZcbiAgKlxuICAqIHByZW9yZGVyIC0+IFsnQScsICdCJywgJ0QnLCAnQycsICdFJywgJ0YnXVxuICAqIHBvc3RvcmRlciAtPiBbJ0QnLCAnQicsICdFJywgJ0YnLCAnQycsICdBJ11cbiAgKlxuICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvcHRfcHJlb3JkZXJGbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHZpc2l0aW5nIGEgbm9kZS5cbiAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb3B0X3Bvc3RvcmRlckZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSBsZWF2aW5nIGEgbm9kZS5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKG9wdF9wcmVvcmRlckZuLCBvcHRfcG9zdG9yZGVyRm4pIHtcblx0XHRpZiAob3B0X3ByZW9yZGVyRm4pIHtcblx0XHRcdG9wdF9wcmVvcmRlckZuKHRoaXMpO1xuXHRcdH1cblx0XHR0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0XHRcdHJldHVybiBjaGlsZC50cmF2ZXJzZShvcHRfcHJlb3JkZXJGbiwgb3B0X3Bvc3RvcmRlckZuKTtcblx0XHR9KTtcblx0XHRpZiAob3B0X3Bvc3RvcmRlckZuKSB7XG5cdFx0XHRvcHRfcG9zdG9yZGVyRm4odGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBUcmVlTm9kZTtcbn0oKTtcblxuLyoqXG4gKiBDb25zdGFudCBmb3IgZW1wdHkgYXJyYXkgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYWxsb2NhdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVHJlZU5vZGUuRU1QVFlfQVJSQVkgPSBbXTtcblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgY2hpbGQgaGFzIG5vIHBhcmVudC5cbiAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkIEEgY2hpbGQuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYXNzZXJ0Q2hpbGRIYXNOb1BhcmVudCA9IGZ1bmN0aW9uIGFzc2VydENoaWxkSGFzTm9QYXJlbnQoY2hpbGQpIHtcblx0aWYgKGNoaWxkLmdldFBhcmVudCgpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGNoaWxkIHdpdGggcGFyZW50LicpO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUcmVlTm9kZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtc3RydWN0cy9saWIvVHJlZU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9wYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcblxudmFyIF9wYXJzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZSk7XG5cbnZhciBfbWV0YWxTdHJ1Y3RzID0gcmVxdWlyZSgnbWV0YWwtc3RydWN0cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgcGFyc2VGbl8gPSBfcGFyc2UyLmRlZmF1bHQ7XG5cbnZhciBVcmkgPSBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG4gICogVGhpcyBjbGFzcyBjb250YWlucyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciB0aGUgcGFydHMgb2YgdGhlIFVSSS5cbiAgKiBUaGUgZm9sbG93aW5nIGZpZ3VyZSBkaXNwbGF5cyBhbiBleGFtcGxlIFVSSXMgYW5kIHRoZWlyIGNvbXBvbmVudCBwYXJ0cy5cbiAgKlxuICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhcbiAgKlx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIzilIDilIDilIDilLTilIDilIDilIDilIDilJBcbiAgKlx0ICBhYmM6Ly9leGFtcGxlLmNvbToxMjMvcGF0aC9kYXRhP2tleT12YWx1ZSNmcmFnaWQxXG4gICpcdCAg4pSU4pSs4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSYIOKUlOKUrOKUmCAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSYIOKUlOKUgOKUgOKUrOKUgOKUgOKUmFxuICAqIHByb3RvY29sICBob3N0bmFtZSAgcG9ydCAgICAgICAgICAgIHNlYXJjaCAgICBoYXNoXG4gICogICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICogICAgICAgICAgICAgICAgaG9zdFxuICAqXG4gICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG4gICogQGNvbnN0cnVjdG9yXG4gICovXG5cdGZ1bmN0aW9uIFVyaSgpIHtcblx0XHR2YXIgb3B0X3VyaSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXJpKTtcblxuXHRcdHRoaXMudXJsID0gVXJpLnBhcnNlKHRoaXMubWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSk7XG5cdH1cblxuXHQvKipcbiAgKiBBZGRzIHBhcmFtZXRlcnMgdG8gdXJpIGZyb20gYSA8Y29kZT5NdWx0aU1hcDwvY29kZT4gYXMgc291cmNlLlxuICAqIEBwYXJhbSB7TXVsdGlNYXB9IG11bHRpbWFwIFRoZSA8Y29kZT5NdWx0aU1hcDwvY29kZT4gY29udGFpbmluZyB0aGVcbiAgKiAgIHBhcmFtZXRlcnMuXG4gICogQHByb3RlY3RlZFxuICAqIEBjaGFpbmFibGVcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhVcmksIFt7XG5cdFx0a2V5OiAnYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAobXVsdGltYXApIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRcdG11bHRpbWFwLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRtdWx0aW1hcC5nZXRBbGwobmFtZSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRfdGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS4gV2lsbCBiZSBleHBsaWNpdGx5IGNhc3RlZCB0byBTdHJpbmcuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZFBhcmFtZXRlclZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpIHtcblx0XHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRcdGlmICgoMCwgX21ldGFsLmlzRGVmKSh2YWx1ZSkpIHtcblx0XHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5xdWVyeS5hZGQobmFtZSwgdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZFBhcmFtZXRlclZhbHVlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFBhcmFtZXRlclZhbHVlcyhuYW1lLCB2YWx1ZXMpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzMi5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFbnN1cmVzIHF1ZXJ5IGludGVybmFsIG1hcCBpcyBpbml0aWFsaXplZCBhbmQgc3luY2VkIHdpdGggaW5pdGlhbCB2YWx1ZVxuICAgKiBleHRyYWN0ZWQgZnJvbSBVUkkgc2VhcmNoIHBhcnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Vuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKSB7XG5cdFx0XHR2YXIgX3RoaXMzID0gdGhpcztcblxuXHRcdFx0aWYgKHRoaXMucXVlcnkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5xdWVyeSA9IG5ldyBfbWV0YWxTdHJ1Y3RzLk11bHRpTWFwKCk7XG5cdFx0XHR2YXIgc2VhcmNoID0gdGhpcy51cmwuc2VhcmNoO1xuXHRcdFx0aWYgKHNlYXJjaCkge1xuXHRcdFx0XHRzZWFyY2guc3Vic3RyaW5nKDEpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcblx0XHRcdFx0XHR2YXIgX3BhcmFtJHNwbGl0ID0gcGFyYW0uc3BsaXQoJz0nKSxcblx0XHRcdFx0XHQgICAgX3BhcmFtJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9wYXJhbSRzcGxpdCwgMiksXG5cdFx0XHRcdFx0ICAgIGtleSA9IF9wYXJhbSRzcGxpdDJbMF0sXG5cdFx0XHRcdFx0ICAgIHZhbHVlID0gX3BhcmFtJHNwbGl0MlsxXTtcblxuXHRcdFx0XHRcdGlmICgoMCwgX21ldGFsLmlzRGVmKSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gVXJpLnVybERlY29kZSh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF90aGlzMy5hZGRQYXJhbWV0ZXJWYWx1ZShrZXksIHZhbHVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGhhc2ggcGFydCBvZiB1cmkuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEhhc2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRIYXNoKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudXJsLmhhc2ggfHwgJyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGhvc3QgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+W2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRIb3N0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0SG9zdCgpIHtcblx0XHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0bmFtZSgpO1xuXHRcdFx0aWYgKGhvc3QpIHtcblx0XHRcdFx0dmFyIHBvcnQgPSB0aGlzLmdldFBvcnQoKTtcblx0XHRcdFx0aWYgKHBvcnQgJiYgcG9ydCAhPT0gJzgwJykge1xuXHRcdFx0XHRcdGhvc3QgKz0gJzonICsgcG9ydDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhvc3Q7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGhvc3RuYW1lIHBhcnQgb2YgdXJpIHdpdGhvdXQgcHJvdG9jb2wgYW5kIHBvcnQuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEhvc3RuYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0SG9zdG5hbWUoKSB7XG5cdFx0XHR2YXIgaG9zdG5hbWUgPSB0aGlzLnVybC5ob3N0bmFtZTtcblx0XHRcdGlmIChob3N0bmFtZSA9PT0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBob3N0bmFtZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgb3JpZ2luIHBhcnQgb2YgdXJpLiBFLmcuIDxjb2RlPmh0dHA6Ly9baG9zdG5hbWVdOltwb3J0XTwvY29kZT4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE9yaWdpbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9yaWdpbigpIHtcblx0XHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0KCk7XG5cdFx0XHRpZiAoaG9zdCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRQcm90b2NvbCgpICsgJy8vJyArIGhvc3Q7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlciBvciB1bmRlZmluZWQgaWYgdGhlIGdpdmVuXG4gICAqIHBhcmFtZXRlciBuYW1lIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcXVlcnkgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lIFVuZXNjYXBlZCBwYXJhbWV0ZXIgbmFtZS5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIGZpcnN0IHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlciBvclxuICAgKiAgIHVuZGVmaW5lZCBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUgZG9lcyBub3QgYXBwZWFyIGluIHRoZSBxdWVyeVxuICAgKiAgIHN0cmluZy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFBhcmFtZXRlclZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyYW1ldGVyVmFsdWUobmFtZSkge1xuXHRcdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdFx0cmV0dXJuIHRoaXMucXVlcnkuZ2V0KG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZTxiPnM8L2I+IGZvciBhIGdpdmVuIHBhcmFtZXRlciBhcyBhIGxpc3Qgb2YgZGVjb2RlZFxuICAgKiBxdWVyeSBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcGFyYW1ldGVyIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8Pz59IFRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIGFzIGEgbGlzdCBvZiBkZWNvZGVkXG4gICAqICAgcXVlcnkgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFBhcmFtZXRlclZhbHVlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhcmFtZXRlclZhbHVlcyhuYW1lKSB7XG5cdFx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXRBbGwobmFtZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWU8Yj5zPC9iPiBvZiB0aGUgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IFRoZSBuYW1lcyBmb3IgdGhlIHBhcmFtZXRlcnMgYXMgYSBsaXN0IG9mXG4gICAqICAgc3RyaW5ncy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFBhcmFtZXRlck5hbWVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyYW1ldGVyTmFtZXMoKSB7XG5cdFx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5xdWVyeS5uYW1lcygpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBmdW5jdGlvbiBjdXJyZW50bHkgYmVpbmcgdXNlZCB0byBwYXJzZSBVUklzLlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFBhdGhuYW1lJyxcblxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIHBhdGhuYW1lIHBhcnQgb2YgdXJpLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRobmFtZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnVybC5wYXRobmFtZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgcG9ydCBudW1iZXIgcGFydCBvZiB1cmkgYXMgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UG9ydCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnVybC5wb3J0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBwcm90b2NvbCBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5odHRwOjwvY29kZT4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFByb3RvY29sJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvdG9jb2woKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy51cmwucHJvdG9jb2w7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIHNlYXJjaCBwYXJ0IG9mIHVyaS4gU2VhcmNoIHZhbHVlIGlzIHJldHJpZXZlZCBmcm9tIHF1ZXJ5XG4gICAqIHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFNlYXJjaCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFNlYXJjaCgpIHtcblx0XHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXG5cdFx0XHR2YXIgc2VhcmNoID0gJyc7XG5cdFx0XHR2YXIgcXVlcnlzdHJpbmcgPSAnJztcblx0XHRcdHRoaXMuZ2V0UGFyYW1ldGVyTmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdF90aGlzNC5nZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRxdWVyeXN0cmluZyArPSBuYW1lO1xuXHRcdFx0XHRcdGlmICgoMCwgX21ldGFsLmlzRGVmKSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHF1ZXJ5c3RyaW5nICs9ICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHF1ZXJ5c3RyaW5nICs9ICcmJztcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdHF1ZXJ5c3RyaW5nID0gcXVlcnlzdHJpbmcuc2xpY2UoMCwgLTEpO1xuXHRcdFx0aWYgKHF1ZXJ5c3RyaW5nKSB7XG5cdFx0XHRcdHNlYXJjaCArPSAnPycgKyBxdWVyeXN0cmluZztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzZWFyY2g7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB1cmkgY29udGFpbnMgdGhlIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc1BhcmFtZXRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc1BhcmFtZXRlcihuYW1lKSB7XG5cdFx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5xdWVyeS5jb250YWlucyhuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogTWFrZXMgdGhpcyBVUkwgdW5pcXVlIGJ5IGFkZGluZyBhIHJhbmRvbSBwYXJhbSB0byBpdC4gVXNlZnVsIGZvciBhdm9pZGluZ1xuICAgKiBjYWNoZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21ha2VVbmlxdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYWtlVW5pcXVlKCkge1xuXHRcdFx0dGhpcy5zZXRQYXJhbWV0ZXJWYWx1ZShVcmkuUkFORE9NX1BBUkFNLCBfbWV0YWwuc3RyaW5nLmdldFJhbmRvbVN0cmluZygpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBNYXliZSBhZGRzIHByb3RvY29sIGFuZCBhIGhvc3RuYW1lIHBsYWNlaG9sZGVyIG9uIGEgcGFyaWFsIFVSSSBpZiBuZWVkZWQuXG4gICAqIFJlbGV2ZW50IGZvciBjb21wYXRpYmlsaXR5IHdpdGggPGNvZGU+VVJMPC9jb2RlPiBuYXRpdmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF91cmlcbiAgICogQHJldHVybiB7c3RyaW5nfSBVUkkgd2l0aCBwcm90b2NvbCBhbmQgaG9zdG5hbWUgcGxhY2Vob2xkZXIuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSB7XG5cdFx0XHR2YXIgdXJsID0gb3B0X3VyaTtcblx0XHRcdGlmIChvcHRfdXJpLmluZGV4T2YoJzovLycpID09PSAtMSAmJiBvcHRfdXJpLmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgIT09IDApIHtcblx0XHRcdFx0Ly8ganNoaW50IGlnbm9yZTpsaW5lXG5cblx0XHRcdFx0dXJsID0gVXJpLkRFRkFVTFRfUFJPVE9DT0w7XG5cdFx0XHRcdGlmIChvcHRfdXJpWzBdICE9PSAnLycgfHwgb3B0X3VyaVsxXSAhPT0gJy8nKSB7XG5cdFx0XHRcdFx0dXJsICs9ICcvLyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKG9wdF91cmkuY2hhckF0KDApKSB7XG5cdFx0XHRcdFx0Y2FzZSAnLic6XG5cdFx0XHRcdFx0Y2FzZSAnPyc6XG5cdFx0XHRcdFx0Y2FzZSAnIyc6XG5cdFx0XHRcdFx0XHR1cmwgKz0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSO1xuXHRcdFx0XHRcdFx0dXJsICs9ICcvJztcblx0XHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnJzpcblx0XHRcdFx0XHRjYXNlICcvJzpcblx0XHRcdFx0XHRcdGlmIChvcHRfdXJpWzFdICE9PSAnLycpIHtcblx0XHRcdFx0XHRcdFx0dXJsICs9IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdXJsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlUGFyYW1ldGVyJyxcblxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciB0byByZW1vdmUuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVBhcmFtZXRlcihuYW1lKSB7XG5cdFx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0XHR0aGlzLnF1ZXJ5LnJlbW92ZShuYW1lKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHVuaXF1ZW5lc3MgcGFyYW1ldGVyIG9mIHRoZSB1cmkuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZVVuaXF1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVuaXF1ZSgpIHtcblx0XHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKFVyaS5SQU5ET01fUEFSQU0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIGhhc2guXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEhhc2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRIYXNoKGhhc2gpIHtcblx0XHRcdHRoaXMudXJsLmhhc2ggPSBoYXNoO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIGhvc3RuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWVcbiAgICogQGNoYWluYWJsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0SG9zdG5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRIb3N0bmFtZShob3N0bmFtZSkge1xuXHRcdFx0dGhpcy51cmwuaG9zdG5hbWUgPSBob3N0bmFtZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG4gICAqIGZvciB0aGF0IGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRQYXJhbWV0ZXJWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTtcblx0XHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG4gICAqIGZvciB0aGF0IGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRQYXJhbWV0ZXJWYWx1ZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSwgdmFsdWVzKSB7XG5cdFx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblxuXHRcdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7XG5cdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzNS5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBwYXRobmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFBhdGhuYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0UGF0aG5hbWUocGF0aG5hbWUpIHtcblx0XHRcdHRoaXMudXJsLnBhdGhuYW1lID0gcGF0aG5hbWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgcG9ydCBudW1iZXIuXG4gICAqIEBwYXJhbSB7Kn0gcG9ydCBQb3J0IG51bWJlci5cbiAgICogQGNoYWluYWJsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0UG9ydCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFBvcnQocG9ydCkge1xuXHRcdFx0dGhpcy51cmwucG9ydCA9IHBvcnQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHBhcnNpbmcgdGhlIG9yaWdpbmFsIHN0cmluZyB1cmlcbiAgICogaW50byBhbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHBhcnNlRm5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFByb3RvY29sJyxcblxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHByb3RvY29sLiBJZiBtaXNzaW5nIDxjb2RlPmh0dHA6PC9jb2RlPiBpcyB1c2VkIGFzIGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQcm90b2NvbChwcm90b2NvbCkge1xuXHRcdFx0dGhpcy51cmwucHJvdG9jb2wgPSBwcm90b2NvbDtcblx0XHRcdGlmICh0aGlzLnVybC5wcm90b2NvbFt0aGlzLnVybC5wcm90b2NvbC5sZW5ndGggLSAxXSAhPT0gJzonKSB7XG5cdFx0XHRcdHRoaXMudXJsLnByb3RvY29sICs9ICc6Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgdXJsLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RvU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0XHR2YXIgaHJlZiA9ICcnO1xuXHRcdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRcdGlmIChob3N0KSB7XG5cdFx0XHRcdGhyZWYgKz0gdGhpcy5nZXRQcm90b2NvbCgpICsgJy8vJztcblx0XHRcdH1cblx0XHRcdGhyZWYgKz0gaG9zdCArIHRoaXMuZ2V0UGF0aG5hbWUoKSArIHRoaXMuZ2V0U2VhcmNoKCkgKyB0aGlzLmdldEhhc2goKTtcblx0XHRcdHJldHVybiBocmVmO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBKb2lucyB0aGUgZ2l2ZW4gcGF0aHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aFxuICAgKiBAcGFyYW0gey4uLnN0cmluZ30gLi4ucGF0aHMgQW55IG51bWJlciBvZiBwYXRocyB0byBiZSBqb2luZWQgd2l0aCB0aGUgYmFzZSB1cmwuXG4gICAqIEBzdGF0aWNcbiAgICovXG5cblx0fV0sIFt7XG5cdFx0a2V5OiAnZ2V0UGFyc2VGbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhcnNlRm4oKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VGbl87XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncGFyc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwYXJzZShvcHRfdXJpKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VGbl8ob3B0X3VyaSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0UGFyc2VGbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFBhcnNlRm4ocGFyc2VGbikge1xuXHRcdFx0cGFyc2VGbl8gPSBwYXJzZUZuO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2pvaW5QYXRocycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGpvaW5QYXRocyhiYXNlUGF0aCkge1xuXHRcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhdGhzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHRcdFx0XHRwYXRoc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChiYXNlUGF0aC5jaGFyQXQoYmFzZVBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuXHRcdFx0XHRiYXNlUGF0aCA9IGJhc2VQYXRoLnN1YnN0cmluZygwLCBiYXNlUGF0aC5sZW5ndGggLSAxKTtcblx0XHRcdH1cblx0XHRcdHBhdGhzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0XHRcdHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gW2Jhc2VQYXRoXS5jb25jYXQocGF0aHMpLmpvaW4oJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBVUkwtZGVjb2RlcyB0aGUgc3RyaW5nLiBXZSBuZWVkIHRvIHNwZWNpYWxseSBoYW5kbGUgJysncyBiZWNhdXNlXG4gICAqIHRoZSBqYXZhc2NyaXB0IGxpYnJhcnkgZG9lc24ndCBjb252ZXJ0IHRoZW0gdG8gc3BhY2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXJsIGRlY29kZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCB7QGNvZGUgc3RyfS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3VybERlY29kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHVybERlY29kZShzdHIpIHtcblx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gVXJpO1xufSgpO1xuXG4vKipcbiAqIERlZmF1bHQgcHJvdG9jb2wgdmFsdWUuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGRlZmF1bHQgaHR0cDpcbiAqIEBzdGF0aWNcbiAqL1xuXG5cbnZhciBpc1NlY3VyZSA9IGZ1bmN0aW9uIGlzU2VjdXJlKCkge1xuXHRyZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cHMnKSA9PT0gMDtcbn07XG5cblVyaS5ERUZBVUxUX1BST1RPQ09MID0gaXNTZWN1cmUoKSA/ICdodHRwczonIDogJ2h0dHA6JztcblxuLyoqXG4gKiBIb3N0bmFtZSBwbGFjZWhvbGRlci4gUmVsZXZhbnQgdG8gaW50ZXJuYWwgdXNhZ2Ugb25seS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUiA9ICdob3N0bmFtZScgKyBEYXRlLm5vdygpO1xuXG4vKipcbiAqIE5hbWUgdXNlZCBieSB0aGUgcGFyYW0gZ2VuZXJhdGVkIGJ5IGBtYWtlVW5pcXVlYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5SQU5ET01fUEFSQU0gPSAnengnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBVcmk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXVyaS9saWIvVXJpLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX3BhcnNlRnJvbUFuY2hvciA9IHJlcXVpcmUoJy4vcGFyc2VGcm9tQW5jaG9yJyk7XG5cbnZhciBfcGFyc2VGcm9tQW5jaG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlRnJvbUFuY2hvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB1cmkgc3RyaW5nIGludG8gYW4gb2JqZWN0LiBUaGUgVVJMIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZFxuICogd2hlbiBwcmVzZW50LCBvdGhlcndpc2Ugd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBhbmNob3Igbm9kZSBlbGVtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKG9wdF91cmkpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikoVVJMKSAmJiBVUkwubGVuZ3RoKSB7XG5cdFx0dmFyIHVybCA9IG5ldyBVUkwob3B0X3VyaSk7XG5cblx0XHQvLyBTYWZhcmkgQnJvd3NlcnMgd2lsbCBjYXAgcG9ydCB0byB0aGUgbWF4IDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyICg2NTUzNSkgaW5zdGVhZFxuXHRcdC8vIG9mIHRocm93aW5nIGEgVHlwZUVycm9yIGFzIHBlciBzcGVjLiBJdCB3aWxsIHN0aWxsIGtlZXAgdGhlIHBvcnQgbnVtYmVyIGluIHRoZVxuXHRcdC8vIGhyZWYgYXR0cmlidXRlLCBzbyB3ZSBjYW4gdXNlIHRoaXMgbWlzbWF0Y2ggdG8gcmFpc2UgdGhlIGV4cGVjdGVkIGV4Y2VwdGlvbi5cblx0XHRpZiAodXJsLnBvcnQgJiYgdXJsLmhyZWYuaW5kZXhPZih1cmwucG9ydCkgPT09IC0xKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKG9wdF91cmkgKyAnIGlzIG5vdCBhIHZhbGlkIFVSTCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1cmw7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICgwLCBfcGFyc2VGcm9tQW5jaG9yMi5kZWZhdWx0KShvcHRfdXJpKTtcblx0fVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtdXJpL2xpYi9wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5mdW5jdGlvbiBwYXJzZUZyb21BbmNob3Iob3B0X3VyaSkge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0bGluay5ocmVmID0gb3B0X3VyaTtcblxuXHRpZiAobGluay5wcm90b2NvbCA9PT0gJzonIHx8ICEvOi8udGVzdChsaW5rLmhyZWYpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihvcHRfdXJpICsgJyBpcyBub3QgYSB2YWxpZCBVUkwnKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aGFzaDogbGluay5oYXNoLFxuXHRcdGhvc3RuYW1lOiBsaW5rLmhvc3RuYW1lLFxuXHRcdHBhc3N3b3JkOiBsaW5rLnBhc3N3b3JkLFxuXHRcdHBhdGhuYW1lOiBsaW5rLnBhdGhuYW1lWzBdID09PSAnLycgPyBsaW5rLnBhdGhuYW1lIDogJy8nICsgbGluay5wYXRobmFtZSxcblx0XHRwb3J0OiBsaW5rLnBvcnQsXG5cdFx0cHJvdG9jb2w6IGxpbmsucHJvdG9jb2wsXG5cdFx0c2VhcmNoOiBsaW5rLnNlYXJjaCxcblx0XHR1c2VybmFtZTogbGluay51c2VybmFtZVxuXHR9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZUZyb21BbmNob3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXVyaS9saWIvcGFyc2VGcm9tQW5jaG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBhcnJheSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgYXJyYXkpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGFycmF5LCBudWxsLCBbe1xuXHRcdGtleTogJ2VxdWFsJyxcblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIxXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBlcXVhbChhcnIxLCBhcnIyKSB7XG5cdFx0XHRpZiAoYXJyMSA9PT0gYXJyMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgaXNuJ3QgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0geyFBcnJheX0gYXJyXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmaXJzdERlZmluZWRWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKGFycikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFycltpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dCBuZXN0ZWQgYXJyYXkgdG8gYmVjb21lIGZsYXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPCp8QXJyYXkuPCo+Pn0gYXJyIE5lc3RlZCBhcnJheSB0byBmbGF0dGVuLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gb3B0X291dHB1dCBPcHRpb25hbCBvdXRwdXQgYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5LjwqPn0gRmxhdCBhcnJheS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZsYXR0ZW4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmbGF0dGVuKGFyciwgb3B0X291dHB1dCkge1xuXHRcdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG5cdFx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG5cdFx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0XHR2YXIgcnYgPSB2b2lkIDA7XG5cdFx0XHRpZiAocnYgPSBpID49IDApIHtcblx0XHRcdFx0YXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBydjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIEFycmF5IG9yIGFycmF5IGxpa2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVBdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcnIsIGksIDEpLmxlbmd0aCA9PT0gMTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcbiAgICogaXMgZmFzdGVyIGFuZCB3b3JraW5nIG9uIGFsbCBhcnJheS1saWtlIG9iamVjdHMgKGxpa2UgYXJndW1lbnRzKS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIGluZGV4IHdoZXJlIHRoZSBzbGljZSBzaG91bGQgZW5kLCBub3RcbiAgICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuICAgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NsaWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdFx0dmFyIGVuZCA9ICgwLCBfY29yZS5pc0RlZikob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRcdHNsaWNlZC5wdXNoKGFycltpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2xpY2VkO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBhcnJheTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXJyYXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsL2xpYi9hcnJheS9hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXN5bmMgPSB7fTtcblxuLyoqXG4gKiBUaHJvdyBhbiBpdGVtIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LiAgRm9yXG4gKiBleGFtcGxlLCBpZiBwcm9jZXNzaW5nIGEgZ3JvdXAgb2YgaXRlbXMgaW4gYSBsb29wLCBzb21ldGltZXMgaXQgaXMgdXNlZnVsXG4gKiB0byByZXBvcnQgYW4gZXJyb3Igd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIHRvIGJlXG4gKiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0geyp9IGV4Y2VwdGlvblxuICovXG5hc3luYy50aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgY2FsbHN0YWNrIHVud2luZHMsIG9yIGFzXG4gKiBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbiBjb250ZXh0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpfSBjYWxsYmFja1xuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgT2JqZWN0IHRvIHVzZSBhcyB0aGUgXCJ0aGlzIHZhbHVlXCIgd2hlbiBjYWxsaW5nXG4gKiAgICAgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuYXN5bmMucnVuID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2gobmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG4vKiogQHByaXZhdGUgeyFBcnJheS48IWFzeW5jLnJ1bi5Xb3JrSXRlbV8+fSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblxuLyoqXG4gKiBSdW4gYW55IHBlbmRpbmcgYXN5bmMucnVuIHdvcmsgaXRlbXMuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGludGVuZGVkXG4gKiBmb3IgZ2VuZXJhbCB1c2UsIGJ1dCBmb3IgdXNlIGJ5IGVudHJ5IHBvaW50IGhhbmRsZXJzIHRvIHJ1biBpdGVtcyBhaGVhZCBvZlxuICogYXN5bmMubmV4dFRpY2suXG4gKi9cbmFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuZm4gPSBmbjtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG4vKipcbiAqIENhY2hlIGZvciB0aGUgc2V0SW1tZWRpYXRlIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IG51bGw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24gKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWwgPSB2b2lkIDA7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8qKiBAY29uc3RydWN0b3IgKi9cblx0XHRDaGFubmVsID0gZnVuY3Rpb24gQ2hhbm5lbCgpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIFZhbGlkYXRlIG9yaWdpbiBhbmQgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG1lc3NhZ2Ugd2FzXG5cdFx0XHRcdC8vIGludGVuZGVkIGZvciB1cy5cblx0XHRcdFx0aWYgKGUub3JpZ2luICE9PSBvcmlnaW4gJiYgZS5kYXRhICE9PSBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucG9ydDEub25tZXNzYWdlKCk7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5wb3J0MSA9IHt9O1xuXHRcdFx0dGhpcy5wb3J0MiA9IHtcblx0XHRcdFx0cG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKCkge1xuXHRcdFx0XHRcdHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlLCBvcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGVvZiBDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBjaGFubmVsID0gbmV3IENoYW5uZWwoKTtcblx0XHQvLyBVc2UgYSBmaWZvIGxpbmtlZCBsaXN0IHRvIGNhbGwgY2FsbGJhY2tzIGluIHRoZSByaWdodCBvcmRlci5cblx0XHR2YXIgaGVhZCA9IHt9O1xuXHRcdHZhciB0YWlsID0gaGVhZDtcblx0XHRjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0c2V0VGltZW91dChjYiwgMCk7XG5cdH07XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uIChvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFzeW5jO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5hYnN0cmFjdE1ldGhvZCA9IGFic3RyYWN0TWV0aG9kO1xuZXhwb3J0cy5kaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmVuYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSA9IGdldENvbXBhdGliaWxpdHlNb2RlRGF0YTtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuZXhwb3J0cy5nZXRTdGF0aWNQcm9wZXJ0eSA9IGdldFN0YXRpY1Byb3BlcnR5O1xuZXhwb3J0cy5nZXRVaWQgPSBnZXRVaWQ7XG5leHBvcnRzLmlkZW50aXR5RnVuY3Rpb24gPSBpZGVudGl0eUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzRGVmID0gaXNEZWY7XG5leHBvcnRzLmlzRGVmQW5kTm90TnVsbCA9IGlzRGVmQW5kTm90TnVsbDtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzRG9jdW1lbnRGcmFnbWVudCA9IGlzRG9jdW1lbnRGcmFnbWVudDtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc1dpbmRvdyA9IGlzV2luZG93O1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzU2VydmVyU2lkZSA9IGlzU2VydmVyU2lkZTtcbmV4cG9ydHMubnVsbEZ1bmN0aW9uID0gbnVsbEZ1bmN0aW9uO1xudmFyIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB2b2lkIDA7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xudmFyIFVJRF9QUk9QRVJUWSA9IGV4cG9ydHMuVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBhYnN0cmFjdE1ldGhvZCgpIHtcbiAgdGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBFbmFibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlIHdpdGggdGhlIGZvbGxvd2luZyBmZWF0dXJlcyBmcm9tIHJjXG4gKiBhbmQgMS54IHZlcnNpb25zOlxuICogICAgIC0gVXNpbmcgXCJrZXlcIiB0byByZWZlcmVuY2UgY29tcG9uZW50IGluc3RhbmNlcy4gSW4gdGhlIGN1cnJlbnQgdmVyc2lvblxuICogICAgICAgdGhpcyBzaG91bGQgYmUgZG9uZSB2aWEgXCJyZWZcIiBpbnN0ZWFkLiBUaGlzIGFsbG93cyBvbGQgY29kZSBzdGlsbFxuICogICAgICAgdXNpbmcgXCJrZXlcIiB0byBrZWVwIHdvcmtpbmcgbGlrZSBiZWZvcmUuIE5PVEU6IHRoaXMgbWF5IGNhdXNlXG4gKiAgICAgICBwcm9ibGVtcywgc2luY2UgXCJrZXlcIiBpcyBtZWFudCB0byBiZSB1c2VkIGRpZmZlcmVudGx5LiBPbmx5IHVzZSB0aGlzXG4gKiAgICAgICBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byB1cGdyYWRlIHRoZSBjb2RlIHRvIHVzZSBcInJlZlwiIGluc3RlYWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9kYXRhIE9wdGlvbmFsIG9iamVjdCB3aXRoIGRhdGEgdG8gc3BlY2lmeSBtb3JlXG4gKiAgICAgZGV0YWlscywgc3VjaCBhczpcbiAqICAgICAgICAgLSByZW5kZXJlcnMge0FycmF5fSB0aGUgdGVtcGxhdGUgcmVuZGVyZXJzIHRoYXQgc2hvdWxkIGJlIGluXG4gKiAgICAgICAgICAgY29tcGF0aWJpbGl0eSBtb2RlLCBlaXRoZXIgdGhlaXIgY29uc3RydWN0b3JzIG9yIHN0cmluZ3NcbiAqICAgICAgICAgICByZXByZXNlbnRpbmcgdGhlbSAoZS5nLiAnc295JyBvciAnanN4JykuIEJ5IGRlZmF1bHQsIGFsbCB0aGUgb25lc1xuICogICAgICAgICAgIHRoYXQgZXh0ZW5kIGZyb20gSW5jcmVtZW50YWxEb21SZW5kZXJlci5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICB2YXIgb3B0X2RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBvcHRfZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHVzZWQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZSwgb3Igbm90aGluZyBpZiBpdCBoYXNuJ3QgYmVlblxuICogZW5hYmxlZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuICAvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG4gIGlmIChjb21wYXRpYmlsaXR5TW9kZURhdGFfID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKSB7XG4gICAgICBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSh3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcGF0aWJpbGl0eU1vZGVEYXRhXztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCdzIHRydXRoeSwgb3IgdGhlIHNlY29uZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RUcnV0aHlfKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkb2Vzbid0XG4gKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICogY29udGVudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKCFmbi5uYW1lKSB7XG4gICAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG4gIH1cbiAgcmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgcHJvcGVydHkgaW4gdGhlIGdpdmVuIGNsYXNzLiBUaGUgdmFsdWUgd2lsbCBiZVxuICogaW5oZXJpdGVkIGZyb20gYW5jZXN0b3JzIGFzIGV4cGVjdGVkLCB1bmxlc3MgYSBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gaXMgZ2l2ZW4sXG4gKiB3aGljaCBjYW4gY2hhbmdlIGhvdyB0aGUgc3VwZXIgY2xhc3NlcycgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkgd2lsbCBiZSBtZXJnZWRcbiAqIHRvZ2V0aGVyLlxuICogVGhlIGZpbmFsIG1lcmdlZCB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBpbiBhbm90aGVyIHByb3BlcnR5LCBzbyB0aGF0IGl0IHdvbid0XG4gKiBiZSByZWNhbGN1bGF0ZWQgZXZlbiBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbWVyZ2VkXG4gKiAgICAgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHNvIGZhciBhbmQgdGhlIG5leHQgdmFsdWUgdG8gYmUgbWVyZ2VkIHRvIGl0LlxuICogICAgIFNob3VsZCByZXR1cm4gdGhlc2UgdHdvIG1lcmdlZCB0b2dldGhlci4gSWYgbm90IHBhc3NlZCB0aGUgZmluYWwgcHJvcGVydHlcbiAqICAgICB3aWxsIGJlIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgYW1vbmcgYW5jZXN0b3JzLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG4gIHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuICBpZiAoIWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcbiAgICB2YXIgbWVyZ2VkID0gY3Rvci5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpID8gY3Rvcltwcm9wZXJ0eU5hbWVdIDogbnVsbDtcbiAgICBpZiAoY3Rvci5fX3Byb3RvX18gJiYgIWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG4gICAgICB2YXIgbWVyZ2VGbiA9IG9wdF9tZXJnZUZuIHx8IGdldEZpcnN0VHJ1dGh5XztcbiAgICAgIG1lcmdlZCA9IG1lcmdlRm4obWVyZ2VkLCBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLl9fcHJvdG9fXywgcHJvcGVydHlOYW1lLCBtZXJnZUZuKSk7XG4gICAgfVxuICAgIGN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG4gIH1cbiAgcmV0dXJuIGN0b3JbbWVyZ2VkTmFtZV07XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcbiAgaWYgKG9wdF9vYmplY3QpIHtcbiAgICB2YXIgaWQgPSBvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV07XG4gICAgaWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KFVJRF9QUk9QRVJUWSkpIHtcbiAgICAgIGlkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV0gPSB1bmlxdWVJZENvdW50ZXJfKyspO1xuICB9XG4gIHJldHVybiB1bmlxdWVJZENvdW50ZXJfKys7XG59XG5cbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF9yZXR1cm5WYWx1ZSBUaGUgc2luZ2xlIHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcbiAgcmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRGVmKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG4gIHJldHVybiBpc0RlZih2YWwpICYmICFpc051bGwodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LWZyYWdtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3codmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsID09PSB2YWwud2luZG93O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBhcnJheXNcbiAqIGFuZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogU2V0cyB0byB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aCBleHRyYSBjaGVjayBmb3JcbiAqIGBwcm9jZXNzLmJyb3dzZXJgIHRvIHNraXAgS2FybWEgcnVubmVyIGVudmlyb25tZW50LiBLYXJtYSBlbnZpcm9ubWVudCBoYXNcbiAqIGBwcm9jZXNzYCBkZWZpbmVkIGV2ZW4gdGhvdWdoIGl0IHJ1bnMgb24gdGhlIGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmICFwcm9jZXNzLmJyb3dzZXI7XG59XG5cbi8qKlxuICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsL2xpYi9jb3JlTmFtZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEaXNwb3NhYmxlIHV0aWxpdHkuIFdoZW4gaW5oZXJpdGVkIHByb3ZpZGVzIHRoZSBgZGlzcG9zZWAgZnVuY3Rpb24gdG8gaXRzXG4gKiBzdWJjbGFzcywgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyBvZiBhbnkgb2JqZWN0IHJlZmVyZW5jZXNcbiAqIHdoZW4gYW4gaW5zdGFuY2Ugd29uJ3QgYmUgdXNlZCBhbnltb3JlLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICogYGRpc3Bvc2VJbnRlcm5hbGAgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpYyBkaXNwb3NpbmcgbG9naWMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcG9zYWJsZSk7XG5cblx0XHQvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRGlzcG9zYWJsZSwgW3tcblx0XHRrZXk6ICdkaXNwb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdFx0dGhpcy5kaXNwb3NlSW50ZXJuYWwoKTtcblx0XHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG4gICAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuICAgKiBkaXNwb3NhYmxlcykuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0Rpc3Bvc2VkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRGlzcG9zYWJsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGlzcG9zYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBvYmplY3QoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIG9iamVjdCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Mob2JqZWN0LCBudWxsLCBbe1xuXHRcdGtleTogJ21peGluJyxcblxuXHRcdC8qKlxuICAgKiBDb3BpZXMgYWxsIHRoZSBtZW1iZXJzIG9mIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIFRoZSBvYmplY3RzIGZyb20gd2hpY2ggdmFsdWVzIHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG5cdFx0XHR2YXIga2V5ID0gdm9pZCAwLFxuXHRcdFx0ICAgIHNvdXJjZSA9IHZvaWQgMDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gICAqICAgICA8Y29kZT53aW5kb3c8L2NvZGU+LlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgdmFsdWUgKG9iamVjdCBvciBwcmltaXRpdmUpIG9yLCBpZiBub3QgZm91bmQsIHVuZGVmaW5lZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE9iamVjdEJ5TmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHRcdHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcblx0XHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnQsIGtleSkge1xuXHRcdFx0XHRyZXR1cm4gcGFydFtrZXldO1xuXHRcdFx0fSwgc2NvcGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcbiAgICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0XHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcHBlZE9iajtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG4gICAqIGNoZWNrLCBpbmNsdWRpbmcgb25seSB0aGUga2V5cyBkaXJlY3RseSBjb250YWluZWQgYnkgdGhlIDIgb2JqZWN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NoYWxsb3dFcXVhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmoxLCBvYmoyKSB7XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRcdGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIG9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBzdHJpbmcoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIHN0cmluZyk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Moc3RyaW5nLCBudWxsLCBbe1xuXHRcdGtleTogJ2Nhc2VJbnNlbnNpdGl2ZUNvbXBhcmUnLFxuXG5cdFx0LyoqXG4gICAqIENvbXBhcmVzIHRoZSBnaXZlbiBzdHJpbmdzIHdpdGhvdXQgdGFraW5nIHRoZSBjYXNlIGludG8gYWNjb3VudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIxXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEVpdGhlciAtMSwgMCBvciAxLCBhY2NvcmRpbmcgdG8gaWYgdGhlIGZpcnN0IHN0cmluZyBpc1xuICAgKiAgICAgXCJzbWFsbGVyXCIsIGVxdWFsIG9yIFwiYmlnZ2VyXCIgdGhhbiB0aGUgc2Vjb25kIGdpdmVuIHN0cmluZy5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmUoc3RyMSwgc3RyMikge1xuXHRcdFx0dmFyIHRlc3QxID0gU3RyaW5nKHN0cjEpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgdGVzdDIgPSBTdHJpbmcoc3RyMikudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKHRlc3QxIDwgdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSBlbHNlIGlmICh0ZXN0MSA9PT0gdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG4gICAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cbiAgICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NvbGxhcHNlQnJlYWtpbmdTcGFjZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx0XFxyXFxuIF0rL2csICcgJykucmVwbGFjZSgvXltcXHRcXHJcXG4gXSt8W1xcdFxcclxcbiBdKyQvZywgJycpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cbiAgKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuICAqICAgICB0byBvbmUuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIFJlZ0V4cCBzYWZlLCBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN9LlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlc2NhcGVSZWdleCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFx4MDgnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UmFuZG9tU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZG9tU3RyaW5nKCkge1xuXHRcdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArIE1hdGguYWJzKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpIF4gRGF0ZS5ub3coKSkudG9TdHJpbmcoMzYpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuICAgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuICAgKiBwcm9wZXJ0eSBvZiB1c2luZyAzMSBwcmltZSBpcyB0aGF0IHRoZSBtdWx0aXBsaWNhdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnlcbiAgICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuICAgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUYXJnZXQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc2hDb2RlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFzaENvZGUodmFsKSB7XG5cdFx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXBsYWNlcyBpbnRlcnZhbCBpbnRvIHRoZSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgdmFsdWUsIGUuZy5cbiAgICogYHJlcGxhY2VJbnRlcnZhbChcImFiY2RlXCIsIDEsIDQsIFwiXCIpYCByZXR1cm5zIFwiYWVcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgaW5wdXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcmVwbGFjZXMgdGhlIHNwZWNpZmllZCBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVwbGFjZUludGVydmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBzdHJpbmc7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVueWNvZGUvcHVueWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdXJsL3VybC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VybC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXX0=
